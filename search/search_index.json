{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NDIcalc-marder-matlab \u00b6 About \u00b6 This package contains a set of database document types and code for performing analysis of Marder lab data. It requires and depends on the Neuroscience Data Interface, NDI . Installation \u00b6 Check out the NDI Installation Guide . Help and Support \u00b6 Use the issue tracker to submit questions, bugs, and issues.","title":"Home"},{"location":"#ndicalc-marder-matlab","text":"","title":"NDIcalc-marder-matlab"},{"location":"#about","text":"This package contains a set of database document types and code for performing analysis of Marder lab data. It requires and depends on the Neuroscience Data Interface, NDI .","title":"About"},{"location":"#installation","text":"Check out the NDI Installation Guide .","title":"Installation"},{"location":"#help-and-support","text":"Use the issue tracker to submit questions, bugs, and issues.","title":"Help and Support"},{"location":"contributing/","text":"Contributing \u00b6 Anyone with a GitHub account can contribute. Please see the guidelines below! How to contribute \u00b6 If you have code that you would like to write, do the following. Press the Fork button in the upper-right corner of the NDIcalc-marder-matlab GitHub repository to make a copy of NDIcalc-marder-matlab in your own GitHub space. Make your changes to NDIcalc-marder-matlab. Commit your changes back to your fork. Finally, issue a Pull Request on GitHub from your fork. The request will be received by the NDI development team for integration.","title":"Contributing"},{"location":"contributing/#contributing","text":"Anyone with a GitHub account can contribute. Please see the guidelines below!","title":"Contributing"},{"location":"contributing/#how-to-contribute","text":"If you have code that you would like to write, do the following. Press the Fork button in the upper-right corner of the NDIcalc-marder-matlab GitHub repository to make a copy of NDIcalc-marder-matlab in your own GitHub space. Make your changes to NDIcalc-marder-matlab. Commit your changes back to your fork. Finally, issue a Pull Request on GitHub from your fork. The request will be received by the NDI development team for integration.","title":"How to contribute"},{"location":"installation/","text":"Installation: \u00b6 Install NDI See the NDI Installation Guide and check out its requirements. In a terminal or DOS shell, use the function cd to navigate to your user account Matlab documents directory. On a Mac, for example, it is /Users/yourusername/Documents/MATLAB/ . Then, navigate to the tools directory within. Finally, clone this repository using git clone https://github.com/VH-Lab/NDIcalc-matlab-matlab .","title":"Installation"},{"location":"installation/#installation","text":"Install NDI See the NDI Installation Guide and check out its requirements. In a terminal or DOS shell, use the function cd to navigate to your user account Matlab documents directory. On a Mac, for example, it is /Users/yourusername/Documents/MATLAB/ . Then, navigate to the tools directory within. Finally, clone this repository using git clone https://github.com/VH-Lab/NDIcalc-matlab-matlab .","title":"Installation:"},{"location":"documents/heart/ppg_beats/","text":"ppg_beats (ndi.document class) \u00b6 Class definition \u00b6 Class name : ppg_beats Short name : ppg_beats Superclasses : base , epochid Definition : $NDICALCDOCUMENTPATH/heart/ppg_beats.json Schema for validation : $NDICALCSCHEMAPATH/heart/ppg_beats.json Property_list_name : ppg_beats Class_version : 1 ppg_beats fields \u00b6 Accessed by ppg_beats.field where field is one of the field names below field default_value data type description detection_parameters fields base fields \u00b6 Accessed by base.field where field is one of the field names below field default_value data type description id session_id name datestamp epochid fields \u00b6 Accessed by epochid.field where field is one of the field names below field default_value data type description epochid","title":"ppg_beats"},{"location":"documents/heart/ppg_beats/#ppg_beats-ndidocument-class","text":"","title":"ppg_beats (ndi.document class)"},{"location":"documents/heart/ppg_beats/#class-definition","text":"Class name : ppg_beats Short name : ppg_beats Superclasses : base , epochid Definition : $NDICALCDOCUMENTPATH/heart/ppg_beats.json Schema for validation : $NDICALCSCHEMAPATH/heart/ppg_beats.json Property_list_name : ppg_beats Class_version : 1","title":"Class definition"},{"location":"documents/heart/ppg_beats/#ppg_beats-fields","text":"Accessed by ppg_beats.field where field is one of the field names below field default_value data type description detection_parameters fields","title":"ppg_beats fields"},{"location":"documents/heart/ppg_beats/#base-fields","text":"Accessed by base.field where field is one of the field names below field default_value data type description id session_id name datestamp","title":"base fields"},{"location":"documents/heart/ppg_beats/#epochid-fields","text":"Accessed by epochid.field where field is one of the field names below field default_value data type description epochid","title":"epochid fields"},{"location":"documents/heart/spectrogram/","text":"spectrogram (ndi.document class) \u00b6 Class definition \u00b6 Class name : spectrogram Short name : spectrogram Superclasses : base , ngrid , epochid Definition : $NDICALCDOCUMENTPATH/heart/spectrogram.json Schema for validation : $NDICALCSCHEMAPATH/heart/spectrogram_schema.json Property_list_name : spectrogram Class_version : 1 spectrogram fields \u00b6 Accessed by spectrogram.field where field is one of the field names below field default_value data type description frequency_ngrid_dim timestamp_ngrid_dim decibels base fields \u00b6 Accessed by base.field where field is one of the field names below field default_value data type description id session_id name datestamp ngrid fields \u00b6 Accessed by ngrid.field where field is one of the field names below field default_value data type description data_size data_type data_dim coordinates epochid fields \u00b6 Accessed by epochid.field where field is one of the field names below field default_value data type description epochid","title":"spectrogram"},{"location":"documents/heart/spectrogram/#spectrogram-ndidocument-class","text":"","title":"spectrogram (ndi.document class)"},{"location":"documents/heart/spectrogram/#class-definition","text":"Class name : spectrogram Short name : spectrogram Superclasses : base , ngrid , epochid Definition : $NDICALCDOCUMENTPATH/heart/spectrogram.json Schema for validation : $NDICALCSCHEMAPATH/heart/spectrogram_schema.json Property_list_name : spectrogram Class_version : 1","title":"Class definition"},{"location":"documents/heart/spectrogram/#spectrogram-fields","text":"Accessed by spectrogram.field where field is one of the field names below field default_value data type description frequency_ngrid_dim timestamp_ngrid_dim decibels","title":"spectrogram fields"},{"location":"documents/heart/spectrogram/#base-fields","text":"Accessed by base.field where field is one of the field names below field default_value data type description id session_id name datestamp","title":"base fields"},{"location":"documents/heart/spectrogram/#ngrid-fields","text":"Accessed by ngrid.field where field is one of the field names below field default_value data type description data_size data_type data_dim coordinates","title":"ngrid fields"},{"location":"documents/heart/spectrogram/#epochid-fields","text":"Accessed by epochid.field where field is one of the field names below field default_value data type description epochid","title":"epochid fields"},{"location":"reference/%2Bmlt/graceAnalysisAll.m/","text":"mlt.graceAnalysisAll \u00b6 GRACEANALYSISALL Runs the complete pre-processing and analysis pipeline for a session. mlt . graceAnalysisAll ( S ) This is the main , top - level wrapper function that executes the entire pre - processing and analysis pipeline for all PPG ( photoplethysmogram ) probes in a given NDI session . It performs the following steps in order : 1. Downsamples the raw PPG data to create the '_lp_whole' elements . 2. Calculates spectrograms and saves them as . mat files . 3. Calculates spectrograms and saves them as NDI documents . 4. Detects heart beats and saves them as . mat files . 5. Detects heart beats and saves them as NDI documents . Inputs : S - An ndi . session or ndi . dataset object . Example : % Run the entire analysis pipeline on a session mlt . graceAnalysisAll ( mySession ); See also mlt.ppg.downsampleAll, mlt.spectrogram.calculateForFiles, mlt . spectrogram . calculateForDocs , mlt . beats . calculateForFiles , mlt . beats . calculateForDocs","title":"mlt.graceAnalysisAll"},{"location":"reference/%2Bmlt/graceAnalysisAll.m/#mltgraceanalysisall","text":"GRACEANALYSISALL Runs the complete pre-processing and analysis pipeline for a session. mlt . graceAnalysisAll ( S ) This is the main , top - level wrapper function that executes the entire pre - processing and analysis pipeline for all PPG ( photoplethysmogram ) probes in a given NDI session . It performs the following steps in order : 1. Downsamples the raw PPG data to create the '_lp_whole' elements . 2. Calculates spectrograms and saves them as . mat files . 3. Calculates spectrograms and saves them as NDI documents . 4. Detects heart beats and saves them as . mat files . 5. Detects heart beats and saves them as NDI documents . Inputs : S - An ndi . session or ndi . dataset object . Example : % Run the entire analysis pipeline on a session mlt . graceAnalysisAll ( mySession ); See also mlt.ppg.downsampleAll, mlt.spectrogram.calculateForFiles, mlt . spectrogram . calculateForDocs , mlt . beats . calculateForFiles , mlt . beats . calculateForDocs","title":"mlt.graceAnalysisAll"},{"location":"reference/%2Bmlt/gracedemo.m/","text":"mlt.gracedemo \u00b6 mlt.gracedemo is a script.","title":"mlt.gracedemo"},{"location":"reference/%2Bmlt/gracedemo.m/#mltgracedemo","text":"mlt.gracedemo is a script.","title":"mlt.gracedemo"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBinQuantize.m/","text":"mlt.beats.beatRateBinQuantize \u00b6 BEATRATEBINQUANTIZE Quantizes continuous rate data into discrete symbols . [ discrete_seq , edges ] = mlt . beatRateBinQuantize ( rates , NumSymbols ) converts a vector of continuous rate data into a sequence of integer symbols from 1 to NumSymbols . It uses the quantile function to define the bin edges , which helps ensure that each symbol has a similar number of occurrences in the output sequence , even if the input data is highly skewed . INPUTS : rates - A vector of observed continuous rates . NumSymbols - The number of discrete symbols to quantize the data into . OUTPUTS : discrete_seq - A vector the same length as 'rates' containing the corresponding integer symbol for each rate . edges - The vector of bin edges used for quantization .","title":"mlt.beats.beatRateBinQuantize"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBinQuantize.m/#mltbeatsbeatratebinquantize","text":"BEATRATEBINQUANTIZE Quantizes continuous rate data into discrete symbols . [ discrete_seq , edges ] = mlt . beatRateBinQuantize ( rates , NumSymbols ) converts a vector of continuous rate data into a sequence of integer symbols from 1 to NumSymbols . It uses the quantile function to define the bin edges , which helps ensure that each symbol has a similar number of occurrences in the output sequence , even if the input data is highly skewed . INPUTS : rates - A vector of observed continuous rates . NumSymbols - The number of discrete symbols to quantize the data into . OUTPUTS : discrete_seq - A vector the same length as 'rates' containing the corresponding integer symbol for each rate . edges - The vector of bin edges used for quantization .","title":"mlt.beats.beatRateBinQuantize"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBins.m/","text":"mlt.beats.beatRateBins \u00b6 BEATRATEBINS Estimates beat rate in regularly spaced time bins. [ rates , bin_centers ] = mlt . beats . beatRateBins ( beat_times ) estimates the heart rate from a vector of beat times ( beat_times ). The function uses a sliding window approach to calculate the rate at regular intervals . The input beat_times can be a numeric vector ( assumed to be in seconds ) or a datetime vector . The output bin_centers will be of the same type . This function is part of the mlt ( Marder Lab Tools ) namespace . SYNTAX : [ rates , bin_centers ] = mlt . beats . beatRateBins ( beat_times ) [ rates , bin_centers ] = mlt . beats . beatRateBins ( beat_times , 'deltaT' , dt , 'W' , w ) INPUTS : beat_times - A vector of beat times . Can be a numeric vector ( e . g ., seconds from the start of a recording ) or a datetime vector . Must be sorted chronologically . OPTIONAL NAME - VALUE PAIR ARGUMENTS : 'deltaT' - The time step ( in seconds ) between the centers of consecutive bins . Default : 0.5 seconds . 'W' - The total width of the sliding window ( in seconds ) used to count beats for each bin . Default : 5 seconds . OUTPUTS : rates - A vector of the calculated beat rates in beats per second ( Hz ) for each bin . bin_centers - A vector of the timestamps for the center of each bin . The data type will match the input 'beat_times' ( double or datetime ). EXAMPLE : % Generate some noisy, simulated beat data where rate changes true_rate = @( t ) 2 + 0.5 * sin ( 2 * pi * t / 60 ); % Rate oscillates over time t_sim = 0 : 0.01 : 120 ; % 120 seconds of simulation time beats = []; next_beat = 0 ; while next_beat < 120 current_rate = true_rate ( next_beat ); ibi = 1 / current_rate * ( 1 + 0.1 * ( rand - 0.5 )); % Add noise to inter-beat interval next_beat = next_beat + ibi ; beats ( end + 1 ) = next_beat ; end % 1. Calculate beat rate with default parameters [ rates , centers ] = mlt . beats . beatRateBins ( beats ); % 2. Calculate with custom window and step size [ rates_custom , centers_custom ] = mlt . beats . beatRateBins ( beats , 'deltaT' , 1 , 'W' , 10 ); % Plot results figure ; plot ( beats ( 2 : end ), 1 ./ diff ( beats ), '.' , 'Color' , [ 0.7 0.7 0.7 ], 'DisplayName' , 'Instantaneous Rate' ); hold on ; plot ( centers , rates , 'b-o' , 'LineWidth' , 1.5 , 'DisplayName' , 'Binned Rate (W=5, deltaT=0.5)' ); plot ( centers_custom , rates_custom , 'r-s' , 'LineWidth' , 1.5 , 'DisplayName' , 'Binned Rate (W=10, deltaT=1)' ); plot ( t_sim , true_rate ( t_sim ), 'k--' , 'LineWidth' , 2 , 'DisplayName' , 'True Rate' ); hold off ; xlabel ( 'Time (s)' ); ylabel ( 'Beat Rate (Hz)' ); title ( 'Heart Beat Rate Estimation' ); legend ; grid on ;","title":"mlt.beats.beatRateBins"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBins.m/#mltbeatsbeatratebins","text":"BEATRATEBINS Estimates beat rate in regularly spaced time bins. [ rates , bin_centers ] = mlt . beats . beatRateBins ( beat_times ) estimates the heart rate from a vector of beat times ( beat_times ). The function uses a sliding window approach to calculate the rate at regular intervals . The input beat_times can be a numeric vector ( assumed to be in seconds ) or a datetime vector . The output bin_centers will be of the same type . This function is part of the mlt ( Marder Lab Tools ) namespace . SYNTAX : [ rates , bin_centers ] = mlt . beats . beatRateBins ( beat_times ) [ rates , bin_centers ] = mlt . beats . beatRateBins ( beat_times , 'deltaT' , dt , 'W' , w ) INPUTS : beat_times - A vector of beat times . Can be a numeric vector ( e . g ., seconds from the start of a recording ) or a datetime vector . Must be sorted chronologically . OPTIONAL NAME - VALUE PAIR ARGUMENTS : 'deltaT' - The time step ( in seconds ) between the centers of consecutive bins . Default : 0.5 seconds . 'W' - The total width of the sliding window ( in seconds ) used to count beats for each bin . Default : 5 seconds . OUTPUTS : rates - A vector of the calculated beat rates in beats per second ( Hz ) for each bin . bin_centers - A vector of the timestamps for the center of each bin . The data type will match the input 'beat_times' ( double or datetime ). EXAMPLE : % Generate some noisy, simulated beat data where rate changes true_rate = @( t ) 2 + 0.5 * sin ( 2 * pi * t / 60 ); % Rate oscillates over time t_sim = 0 : 0.01 : 120 ; % 120 seconds of simulation time beats = []; next_beat = 0 ; while next_beat < 120 current_rate = true_rate ( next_beat ); ibi = 1 / current_rate * ( 1 + 0.1 * ( rand - 0.5 )); % Add noise to inter-beat interval next_beat = next_beat + ibi ; beats ( end + 1 ) = next_beat ; end % 1. Calculate beat rate with default parameters [ rates , centers ] = mlt . beats . beatRateBins ( beats ); % 2. Calculate with custom window and step size [ rates_custom , centers_custom ] = mlt . beats . beatRateBins ( beats , 'deltaT' , 1 , 'W' , 10 ); % Plot results figure ; plot ( beats ( 2 : end ), 1 ./ diff ( beats ), '.' , 'Color' , [ 0.7 0.7 0.7 ], 'DisplayName' , 'Instantaneous Rate' ); hold on ; plot ( centers , rates , 'b-o' , 'LineWidth' , 1.5 , 'DisplayName' , 'Binned Rate (W=5, deltaT=0.5)' ); plot ( centers_custom , rates_custom , 'r-s' , 'LineWidth' , 1.5 , 'DisplayName' , 'Binned Rate (W=10, deltaT=1)' ); plot ( t_sim , true_rate ( t_sim ), 'k--' , 'LineWidth' , 2 , 'DisplayName' , 'True Rate' ); hold off ; xlabel ( 'Time (s)' ); ylabel ( 'Beat Rate (Hz)' ); title ( 'Heart Beat Rate Estimation' ); legend ; grid on ;","title":"mlt.beats.beatRateBins"},{"location":"reference/%2Bmlt/%2Bbeats/beatsdoc2struct.m/","text":"mlt.beats.beatsdoc2struct \u00b6 BEATSDOC2STRUCT Reads PPG beat data from an NDI document into a structure . BEATS = BEATSDOC2STRUCT ( S , DOC ) reads photoplethysmogram ( PPG ) beat information associated with a specific NDI document DOC within the context of an NDI session or dataset S . It retrieves the beat data from a binary file ( 'beats.vhsb' ) , formats it into a table based on metadata in DOC , and returns the result as a structure array . Inputs : S - An NDI session object ( ` ndi . session ` ) or NDI dataset object ( ` ndi . dataset ` ) . DOC - An NDI document object ( ` ndi . document ` ) that references the PPG beat data . This document must contain the property ` ppg_beats . fields ` ( a comma - separated string of field names ) . Outputs : BEATS - A structure array where each element represents a single PPG beat . The fields of the structure include : - onset : Beat onset time . - offset : Beat offset time . - peak_time : Time of the beat 's peak. - peak_val : Signal value at the beat 's peak. - valley_time : Time of the beat 's valley (trough). - valley_val : Signal value at the beat 's valley. - up_time: Time of the upward slope. - down_time: Time of the downward slope. - duty_cycle: Ratio of beat duration to the period between beats. - period: Time between consecutive beats. - instant_freq: Instantaneous heart rate (beats per second). - amplitude: Peak-to-peak amplitude. - amplitude_high: Amplitude above a high threshold. - amplitude_low: Amplitude below a low threshold. - valid: Boolean indicating if the beat meets validity criteria. - up_duration: Duration of the upward slope of the beat. See also: mlt.beats.detectHeartBeatsImproved, mlt.beats.beatsstruct2doc, vlt.file.custom_file_formats.vhsb_read","title":"mlt.beats.beatsdoc2struct"},{"location":"reference/%2Bmlt/%2Bbeats/beatsdoc2struct.m/#mltbeatsbeatsdoc2struct","text":"BEATSDOC2STRUCT Reads PPG beat data from an NDI document into a structure . BEATS = BEATSDOC2STRUCT ( S , DOC ) reads photoplethysmogram ( PPG ) beat information associated with a specific NDI document DOC within the context of an NDI session or dataset S . It retrieves the beat data from a binary file ( 'beats.vhsb' ) , formats it into a table based on metadata in DOC , and returns the result as a structure array . Inputs : S - An NDI session object ( ` ndi . session ` ) or NDI dataset object ( ` ndi . dataset ` ) . DOC - An NDI document object ( ` ndi . document ` ) that references the PPG beat data . This document must contain the property ` ppg_beats . fields ` ( a comma - separated string of field names ) . Outputs : BEATS - A structure array where each element represents a single PPG beat . The fields of the structure include : - onset : Beat onset time . - offset : Beat offset time . - peak_time : Time of the beat 's peak. - peak_val : Signal value at the beat 's peak. - valley_time : Time of the beat 's valley (trough). - valley_val : Signal value at the beat 's valley. - up_time: Time of the upward slope. - down_time: Time of the downward slope. - duty_cycle: Ratio of beat duration to the period between beats. - period: Time between consecutive beats. - instant_freq: Instantaneous heart rate (beats per second). - amplitude: Peak-to-peak amplitude. - amplitude_high: Amplitude above a high threshold. - amplitude_low: Amplitude below a low threshold. - valid: Boolean indicating if the beat meets validity criteria. - up_duration: Duration of the upward slope of the beat. See also: mlt.beats.detectHeartBeatsImproved, mlt.beats.beatsstruct2doc, vlt.file.custom_file_formats.vhsb_read","title":"mlt.beats.beatsdoc2struct"},{"location":"reference/%2Bmlt/%2Bbeats/beatsstruct2doc.m/","text":"mlt.beats.beatsstruct2doc \u00b6 MLT . BEATS . BEATSSTRUCT2DOC Adds PPG beat data from a structure to an NDI document . DOC_OUT = BEATSSTRUCT2DOC ( DOC_IN , BEATS ) takes photoplethysmogram ( PPG ) beat information stored in a structure array BEATS and writes it to a binary file ( 'beats.vhsb' ) . It then associates this file with the provided NDI document object DOC_IN . Inputs : DOC_IN - An NDI document object ( ` ndi . document ` ) to which the beat data file will be added . BEATS - A structure array where each element represents a single PPG beat . The fields of the structure include : - onset : Beat onset time . - offset : Beat offset time . - peak_time : Time of the beat 's peak. - peak_val : Signal value at the beat 's peak. - valley_time : Time of the beat 's valley (trough). - valley_val : Signal value at the beat 's valley. - up_time: Time of the upward slope. - down_time: Time of the downward slope. - duty_cycle: Ratio of beat duration to the period between beats. - period: Time between consecutive beats. - instant_freq: Instantaneous heart rate (beats per second). - amplitude: Peak-to-peak amplitude. - amplitude_high: Amplitude above a high threshold. - amplitude_low: Amplitude below a low threshold. - valid: Boolean indicating if the beat meets validity criteria. - up_duration: Duration of the upward slope of the beat. Outputs: DOC_OUT - The updated NDI document object (`ndi.document`) that now includes a reference to the newly created 'beats.vhsb' file containing the beat data . See also : mlt . beats . detectHeartBeatsImproved , mlt . beats . beatsdoc2struct , vlt . file . custom_file_formats . vhsb_write","title":"mlt.beats.beatsstruct2doc"},{"location":"reference/%2Bmlt/%2Bbeats/beatsstruct2doc.m/#mltbeatsbeatsstruct2doc","text":"MLT . BEATS . BEATSSTRUCT2DOC Adds PPG beat data from a structure to an NDI document . DOC_OUT = BEATSSTRUCT2DOC ( DOC_IN , BEATS ) takes photoplethysmogram ( PPG ) beat information stored in a structure array BEATS and writes it to a binary file ( 'beats.vhsb' ) . It then associates this file with the provided NDI document object DOC_IN . Inputs : DOC_IN - An NDI document object ( ` ndi . document ` ) to which the beat data file will be added . BEATS - A structure array where each element represents a single PPG beat . The fields of the structure include : - onset : Beat onset time . - offset : Beat offset time . - peak_time : Time of the beat 's peak. - peak_val : Signal value at the beat 's peak. - valley_time : Time of the beat 's valley (trough). - valley_val : Signal value at the beat 's valley. - up_time: Time of the upward slope. - down_time: Time of the downward slope. - duty_cycle: Ratio of beat duration to the period between beats. - period: Time between consecutive beats. - instant_freq: Instantaneous heart rate (beats per second). - amplitude: Peak-to-peak amplitude. - amplitude_high: Amplitude above a high threshold. - amplitude_low: Amplitude below a low threshold. - valid: Boolean indicating if the beat meets validity criteria. - up_duration: Duration of the upward slope of the beat. Outputs: DOC_OUT - The updated NDI document object (`ndi.document`) that now includes a reference to the newly created 'beats.vhsb' file containing the beat data . See also : mlt . beats . detectHeartBeatsImproved , mlt . beats . beatsdoc2struct , vlt . file . custom_file_formats . vhsb_write","title":"mlt.beats.beatsstruct2doc"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForDocs.m/","text":"mlt.beats.calculateForDocs \u00b6 CALCULATEFORDOCS - Calculate and save heart beat data as NDI documents for a session . mlt . beats . calculateForDocs ( S ) This is a high - level wrapper function that automates the process of heart beat detection for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls the core processing function , mlt . beats . wholeDayHeartBeatDoc , to perform the beat detection and save the results as a 'ppg_beats' NDI document . Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . beats . calculateForDocs ( mySession ); See also mlt.beats.wholeDayHeartBeatDoc, ndi.session","title":"mlt.beats.calculateForDocs"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForDocs.m/#mltbeatscalculatefordocs","text":"CALCULATEFORDOCS - Calculate and save heart beat data as NDI documents for a session . mlt . beats . calculateForDocs ( S ) This is a high - level wrapper function that automates the process of heart beat detection for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls the core processing function , mlt . beats . wholeDayHeartBeatDoc , to perform the beat detection and save the results as a 'ppg_beats' NDI document . Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . beats . calculateForDocs ( mySession ); See also mlt.beats.wholeDayHeartBeatDoc, ndi.session","title":"mlt.beats.calculateForDocs"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForFiles.m/","text":"mlt.beats.calculateForFiles \u00b6 CALCULATEFORFILES - Calculate and save heart beat data as . mat files for a session . mlt . beats . calculateForFiles ( S ) This is a high - level wrapper function that automates the process of heart beat detection for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls a core processing function to perform the beat detection and save the results to a standalone . mat file in the session ' s path . The output files are named according to the convention : 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat' Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . beats . calculateForFiles ( mySession ); See also mlt.beats.wholeDayHeartBeatFile, ndi.session","title":"mlt.beats.calculateForFiles"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForFiles.m/#mltbeatscalculateforfiles","text":"CALCULATEFORFILES - Calculate and save heart beat data as . mat files for a session . mlt . beats . calculateForFiles ( S ) This is a high - level wrapper function that automates the process of heart beat detection for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls a core processing function to perform the beat detection and save the results to a standalone . mat file in the session ' s path . The output files are named according to the convention : 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat' Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . beats . calculateForFiles ( mySession ); See also mlt.beats.wholeDayHeartBeatFile, ndi.session","title":"mlt.beats.calculateForFiles"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeats.m/","text":"mlt.beats.detectHeartBeats \u00b6 DETECTHEARTBEATS Detect heartbeats in a pulsatile signal . BEATS = DETECTHEARTBEATS ( T , D , OPTIONS ) detects heartbeats in a pulsatile signal , such as a photoplethysmography ( PPG ) signal . The function uses a threshold - based approach to identify individual beats and their characteristics . Inputs : T : A vector of timestamps corresponding to the signal . Can be either : - Numeric vector in seconds . - Datetime vector . D : A vector of signal values ( e . g . , PPG signal ) . OPTIONS : ( Optional ) A structure specifying detection parameters : THRESHOLD_HIGH : Upper threshold for beat detection ( default : 0.75 ) . THRESHOLD_LOW : Lower threshold for beat detection ( default : - 0.75 ) . REFRACT : Minimum time between consecutive beats ( refractory period , default : 0.2 ) . amplitude_high_min : Minimum amplitude above THRESHOLD_HIGH ( default : 0 ) . amplitude_low_min : Minimum amplitude below THRESHOLD_LOW ( default : 0 ) . amplitude_min : Minimum peak - to - peak amplitude ( default : 0 ) . duration_min : Minimum beat duration ( default : 0 ) . Outputs : BEATS : A structure array where each element represents a detected beat . Fields include : onset : Beat onset time ( datetime if T is datetime , double in seconds otherwise ) . offset : Beat offset time ( datetime if T is datetime , double in seconds otherwise ) . duty_cycle : Ratio of beat duration to the period between beats ( double ) . period : Time between consecutive beats ( double in seconds ) . instant_freq : Instantaneous heart rate ( double in beats per second ) . amplitude : Peak - to - peak amplitude ( double ) . amplitude_high : Amplitude above THRESHOLD_HIGH ( double ) . amplitude_low : Amplitude below THRESHOLD_LOW ( double ) . valid : Boolean indicating if the beat meets validity criteria . up_duration : Duration of the upward slope of the beat ( double in seconds ) . Notes : - The input signal D is assumed to be preprocessed and normalized . - The algorithm detects beats by identifying upward and downward crossings of the specified thresholds . - The validity of each beat is assessed based on amplitude and duration criteria . - The function handles edge cases , such as incomplete beats at the end of the signal . - If T is a datetime vector , the output onset and offset times will be datetime values , while durations , period , and instant_freq will be double values in seconds . Example : % Load PPG data with time in seconds %%%% [ t_sec , d ] = load_ppg_data_seconds somehow ; beats_sec = detectHeartBeats ( t_sec , d ); % Load PPG data with datetime values %%%%% [ t_datetime , d ] = load_ppg_data_datetime somehow beats_datetime = detectHeartBeats ( t_datetime , d );","title":"mlt.beats.detectHeartBeats"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeats.m/#mltbeatsdetectheartbeats","text":"DETECTHEARTBEATS Detect heartbeats in a pulsatile signal . BEATS = DETECTHEARTBEATS ( T , D , OPTIONS ) detects heartbeats in a pulsatile signal , such as a photoplethysmography ( PPG ) signal . The function uses a threshold - based approach to identify individual beats and their characteristics . Inputs : T : A vector of timestamps corresponding to the signal . Can be either : - Numeric vector in seconds . - Datetime vector . D : A vector of signal values ( e . g . , PPG signal ) . OPTIONS : ( Optional ) A structure specifying detection parameters : THRESHOLD_HIGH : Upper threshold for beat detection ( default : 0.75 ) . THRESHOLD_LOW : Lower threshold for beat detection ( default : - 0.75 ) . REFRACT : Minimum time between consecutive beats ( refractory period , default : 0.2 ) . amplitude_high_min : Minimum amplitude above THRESHOLD_HIGH ( default : 0 ) . amplitude_low_min : Minimum amplitude below THRESHOLD_LOW ( default : 0 ) . amplitude_min : Minimum peak - to - peak amplitude ( default : 0 ) . duration_min : Minimum beat duration ( default : 0 ) . Outputs : BEATS : A structure array where each element represents a detected beat . Fields include : onset : Beat onset time ( datetime if T is datetime , double in seconds otherwise ) . offset : Beat offset time ( datetime if T is datetime , double in seconds otherwise ) . duty_cycle : Ratio of beat duration to the period between beats ( double ) . period : Time between consecutive beats ( double in seconds ) . instant_freq : Instantaneous heart rate ( double in beats per second ) . amplitude : Peak - to - peak amplitude ( double ) . amplitude_high : Amplitude above THRESHOLD_HIGH ( double ) . amplitude_low : Amplitude below THRESHOLD_LOW ( double ) . valid : Boolean indicating if the beat meets validity criteria . up_duration : Duration of the upward slope of the beat ( double in seconds ) . Notes : - The input signal D is assumed to be preprocessed and normalized . - The algorithm detects beats by identifying upward and downward crossings of the specified thresholds . - The validity of each beat is assessed based on amplitude and duration criteria . - The function handles edge cases , such as incomplete beats at the end of the signal . - If T is a datetime vector , the output onset and offset times will be datetime values , while durations , period , and instant_freq will be double values in seconds . Example : % Load PPG data with time in seconds %%%% [ t_sec , d ] = load_ppg_data_seconds somehow ; beats_sec = detectHeartBeats ( t_sec , d ); % Load PPG data with datetime values %%%%% [ t_datetime , d ] = load_ppg_data_datetime somehow beats_datetime = detectHeartBeats ( t_datetime , d );","title":"mlt.beats.detectHeartBeats"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeatsImproved.m/","text":"mlt.beats.detectHeartBeatsImproved \u00b6 DETECTHEARTBEATSIMPROVED Detect heartbeats in a pulsatile signal . BEATS = DETECTHEARTBEATSIMPROVED ( T , D , DRAW , OPTIONS ) detects heartbeats in a pulsatile signal , such as a photoplethysmography ( PPG ) signal . The function uses a threshold - based approach to identify individual beats and their characteristics . Inputs : T : A vector of timestamps corresponding to the signal . Can be either : - Numeric vector in seconds . - Datetime vector . D : A vector of signal values ( e . g . , PPG signal ) . DRAW : The raw data signal . OPTIONS : ( Optional ) A structure specifying detection parameters : threshold_high : Upper threshold for beat detection ( default : 0.75 ) . threshold_low : Lower threshold for beat detection ( default : - 0.75 ) . refractory_period : Minimum time between consecutive beats ( refractory period , default : 0.2 ) . amplitude_high_min : Minimum amplitude above THRESHOLD_HIGH ( default : 0 ) . amplitude_low_min : Minimum amplitude below THRESHOLD_LOW ( default : 0 ) . amplitude_min : Minimum peak - to - peak amplitude ( default : 0 ) . duration_min : Minimum beat duration ( default : 0 ) . Outputs : BEATS : A structure array where each element represents a detected beat . Fields include : onset : Beat onset time ( datetime if T is datetime , double in seconds otherwise ) . offset : Beat offset time ( datetime if T is datetime , double in seconds otherwise ) . duty_cycle : Ratio of beat duration to the period between beats ( double ) . period : Time between consecutive beats ( double in seconds ) . instant_freq : Instantaneous heart rate ( double in beats per second ) . amplitude : Peak - to - peak amplitude ( double ) . amplitude_high : Amplitude above THRESHOLD_HIGH ( double ) . amplitude_low : Amplitude below THRESHOLD_LOW ( double ) . valid : Boolean indicating if the beat meets validity criteria . up_duration : Duration of the upward slope of the beat ( double in seconds ) . OPTIONS : A structure specifying the detection parameters used . Notes : - The input signal D is assumed to be preprocessed and normalized . - The algorithm detects beats by identifying upward and downward crossings of the specified thresholds . - The validity of each beat is assessed based on amplitude and duration criteria . - The function handles edge cases , such as incomplete beats at the end of the signal . - If T is a datetime vector , the output onset and offset times will be datetime values , while durations , period , and instant_freq will be double values in seconds . Example : % Load PPG data with time in seconds %%%% [ t_sec , d ] = load_ppg_data_seconds somehow ; beats_sec = detectHeartBeats ( t_sec , d ); % Load PPG data with datetime values %%%%% [ t_datetime , d ] = load_ppg_data_datetime somehow beats_datetime = detectHeartBeats ( t_datetime , d );","title":"mlt.beats.detectHeartBeatsImproved"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeatsImproved.m/#mltbeatsdetectheartbeatsimproved","text":"DETECTHEARTBEATSIMPROVED Detect heartbeats in a pulsatile signal . BEATS = DETECTHEARTBEATSIMPROVED ( T , D , DRAW , OPTIONS ) detects heartbeats in a pulsatile signal , such as a photoplethysmography ( PPG ) signal . The function uses a threshold - based approach to identify individual beats and their characteristics . Inputs : T : A vector of timestamps corresponding to the signal . Can be either : - Numeric vector in seconds . - Datetime vector . D : A vector of signal values ( e . g . , PPG signal ) . DRAW : The raw data signal . OPTIONS : ( Optional ) A structure specifying detection parameters : threshold_high : Upper threshold for beat detection ( default : 0.75 ) . threshold_low : Lower threshold for beat detection ( default : - 0.75 ) . refractory_period : Minimum time between consecutive beats ( refractory period , default : 0.2 ) . amplitude_high_min : Minimum amplitude above THRESHOLD_HIGH ( default : 0 ) . amplitude_low_min : Minimum amplitude below THRESHOLD_LOW ( default : 0 ) . amplitude_min : Minimum peak - to - peak amplitude ( default : 0 ) . duration_min : Minimum beat duration ( default : 0 ) . Outputs : BEATS : A structure array where each element represents a detected beat . Fields include : onset : Beat onset time ( datetime if T is datetime , double in seconds otherwise ) . offset : Beat offset time ( datetime if T is datetime , double in seconds otherwise ) . duty_cycle : Ratio of beat duration to the period between beats ( double ) . period : Time between consecutive beats ( double in seconds ) . instant_freq : Instantaneous heart rate ( double in beats per second ) . amplitude : Peak - to - peak amplitude ( double ) . amplitude_high : Amplitude above THRESHOLD_HIGH ( double ) . amplitude_low : Amplitude below THRESHOLD_LOW ( double ) . valid : Boolean indicating if the beat meets validity criteria . up_duration : Duration of the upward slope of the beat ( double in seconds ) . OPTIONS : A structure specifying the detection parameters used . Notes : - The input signal D is assumed to be preprocessed and normalized . - The algorithm detects beats by identifying upward and downward crossings of the specified thresholds . - The validity of each beat is assessed based on amplitude and duration criteria . - The function handles edge cases , such as incomplete beats at the end of the signal . - If T is a datetime vector , the output onset and offset times will be datetime values , while durations , period , and instant_freq will be double values in seconds . Example : % Load PPG data with time in seconds %%%% [ t_sec , d ] = load_ppg_data_seconds somehow ; beats_sec = detectHeartBeats ( t_sec , d ); % Load PPG data with datetime values %%%%% [ t_datetime , d ] = load_ppg_data_datetime somehow beats_datetime = detectHeartBeats ( t_datetime , d );","title":"mlt.beats.detectHeartBeatsImproved"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValues.m/","text":"mlt.beats.getRawBeatValues \u00b6 GETRAWBEATVALUES Recalculates beat amplitudes using the raw signal . beats_out = mlt . beats . getRawBeatValues ( beats_in , t_raw , d_raw ) This function takes a 'beats' structure , whose timing was likely determined from a normalized signal , and adds new amplitude fields calculated from the original , un - normalized ( raw ) signal . This is useful for recovering the true physiological amplitudes of detected beats . Inputs : beats - A structure array of detected beats , with at least 'onset' and 'offset' time fields . t_raw - The time vector ( numeric or datetime ) of the raw signal . d_raw - The raw ( un - normalized ) signal vector . Outputs : beats - The input 'beats' structure with the following new fields added to each element : . rawPeak : The maximum signal value during the beat . . rawTrough : The minimum signal value in the period preceding the beat onset . . rawAmplitude : The peak - to - trough amplitude ( rawPeak - rawTrough ) . See also mlt . beats . getRawBeatValuesFromDoc , mlt . beats . detectHeartBeatsImproved","title":"mlt.beats.getRawBeatValues"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValues.m/#mltbeatsgetrawbeatvalues","text":"GETRAWBEATVALUES Recalculates beat amplitudes using the raw signal . beats_out = mlt . beats . getRawBeatValues ( beats_in , t_raw , d_raw ) This function takes a 'beats' structure , whose timing was likely determined from a normalized signal , and adds new amplitude fields calculated from the original , un - normalized ( raw ) signal . This is useful for recovering the true physiological amplitudes of detected beats . Inputs : beats - A structure array of detected beats , with at least 'onset' and 'offset' time fields . t_raw - The time vector ( numeric or datetime ) of the raw signal . d_raw - The raw ( un - normalized ) signal vector . Outputs : beats - The input 'beats' structure with the following new fields added to each element : . rawPeak : The maximum signal value during the beat . . rawTrough : The minimum signal value in the period preceding the beat onset . . rawAmplitude : The peak - to - trough amplitude ( rawPeak - rawTrough ) . See also mlt . beats . getRawBeatValuesFromDoc , mlt . beats . detectHeartBeatsImproved","title":"mlt.beats.getRawBeatValues"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValuesFromDoc.m/","text":"mlt.beats.getRawBeatValuesFromDoc \u00b6 GETRAWBEATVALUESFROMDOC Loads beat data and adds raw amplitude values . beats_out = mlt . beats . getRawBeatValuesFromDoc ( S , name , number ) This is a high - level function that loads a 'ppg_beats' NDI document for a specified element , reads the corresponding raw ( un - normalized ) time series data , and then calls mlt . beats . getRawBeatValues to add raw amplitude information to the beats structure . Inputs : S - An ndi . session object . name - The record name ( 'pylorus' , 'heart' , or 'gastric' ) . number - The record number ( a positive integer ) . Outputs : beats_with_raw - The 'beats' structure from the document , with the new raw amplitude fields ( . rawPeak , . rawTrough , . rawAmplitude ) added . Example : % Get beats with raw amplitudes for the 'pylorus' element , record 1 b_raw = mlt . beats . getRawBeatValuesFromDoc ( mySession , 'pylorus' , 1 ); See also mlt . beats . getRawBeatValues , mlt . beats . beatsdoc2struct","title":"mlt.beats.getRawBeatValuesFromDoc"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValuesFromDoc.m/#mltbeatsgetrawbeatvaluesfromdoc","text":"GETRAWBEATVALUESFROMDOC Loads beat data and adds raw amplitude values . beats_out = mlt . beats . getRawBeatValuesFromDoc ( S , name , number ) This is a high - level function that loads a 'ppg_beats' NDI document for a specified element , reads the corresponding raw ( un - normalized ) time series data , and then calls mlt . beats . getRawBeatValues to add raw amplitude information to the beats structure . Inputs : S - An ndi . session object . name - The record name ( 'pylorus' , 'heart' , or 'gastric' ) . number - The record number ( a positive integer ) . Outputs : beats_with_raw - The 'beats' structure from the document , with the new raw amplitude fields ( . rawPeak , . rawTrough , . rawAmplitude ) added . Example : % Get beats with raw amplitudes for the 'pylorus' element , record 1 b_raw = mlt . beats . getRawBeatValuesFromDoc ( mySession , 'pylorus' , 1 ); See also mlt . beats . getRawBeatValues , mlt . beats . beatsdoc2struct","title":"mlt.beats.getRawBeatValuesFromDoc"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatDoc.m/","text":"mlt.beats.wholeDayHeartBeatDoc \u00b6 MLT . BEATS . WHOLEDAYHEARTBEATDOC Generate heartbeat record for a whole day 's recording. [BEATS, D, T] = mlt.beats.wholeDayHeartBeatDoc(S, OPTIONS) computes heart beat analysis for an entire day 's worth of data from an ndi.element, typically 'ppg_heart_lp' . The function reads the data from the specified element and performs heart beat detection . Inputs : S : An ndi . session or ndi . dataset object containing the data . OPTIONS : A structure containing optional parameters . e_name : The name of the ndi . element to analyze ( default : 'ppg_heart_lp' ) . e_reference : The reference number of the ndi . element ( default : 1 ) . zscoreWindowTime : The z - score time window in seconds ( default : 3600 ) . Outputs : DOC : A document containing the saved beats data BEATS : A structure of heart beat data . D : The data stream used for heart beat detection . T : The timestamps corresponding to the data stream .","title":"mlt.beats.wholeDayHeartBeatDoc"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatDoc.m/#mltbeatswholedayheartbeatdoc","text":"MLT . BEATS . WHOLEDAYHEARTBEATDOC Generate heartbeat record for a whole day 's recording. [BEATS, D, T] = mlt.beats.wholeDayHeartBeatDoc(S, OPTIONS) computes heart beat analysis for an entire day 's worth of data from an ndi.element, typically 'ppg_heart_lp' . The function reads the data from the specified element and performs heart beat detection . Inputs : S : An ndi . session or ndi . dataset object containing the data . OPTIONS : A structure containing optional parameters . e_name : The name of the ndi . element to analyze ( default : 'ppg_heart_lp' ) . e_reference : The reference number of the ndi . element ( default : 1 ) . zscoreWindowTime : The z - score time window in seconds ( default : 3600 ) . Outputs : DOC : A document containing the saved beats data BEATS : A structure of heart beat data . D : The data stream used for heart beat detection . T : The timestamps corresponding to the data stream .","title":"mlt.beats.wholeDayHeartBeatDoc"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatFile.m/","text":"mlt.beats.wholeDayHeartBeatFile \u00b6 MLT . BEATS . WHOLEDAYHEARTBEATFILE Generate heartbeat record for a whole day 's recording. [BEATS, D, T] = WHOLEDAYHEARTBEATFILE(S, OPTIONS) computes heart beat analysis for an entire day 's worth of data from an ndi.element, typically 'ppg_heart_lp' . The function reads the data from the specified element and performs heart beat detection . Inputs : S : An ndi . session or ndi . dataset object containing the data . OPTIONS : A structure containing optional parameters . e_name : The name of the ndi . element to analyze ( default : 'ppg_heart_lp' ) . e_reference : The reference number of the ndi . element ( default : 1 ) . zscoreWindowTime : The z - score time window in seconds ( default : 3600 ) . Outputs : BEATS : A vector of heart beat timestamps . D : The data stream used for heart beat detection . T : The timestamps corresponding to the data stream .","title":"mlt.beats.wholeDayHeartBeatFile"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatFile.m/#mltbeatswholedayheartbeatfile","text":"MLT . BEATS . WHOLEDAYHEARTBEATFILE Generate heartbeat record for a whole day 's recording. [BEATS, D, T] = WHOLEDAYHEARTBEATFILE(S, OPTIONS) computes heart beat analysis for an entire day 's worth of data from an ndi.element, typically 'ppg_heart_lp' . The function reads the data from the specified element and performs heart beat detection . Inputs : S : An ndi . session or ndi . dataset object containing the data . OPTIONS : A structure containing optional parameters . e_name : The name of the ndi . element to analyze ( default : 'ppg_heart_lp' ) . e_reference : The reference number of the ndi . element ( default : 1 ) . zscoreWindowTime : The z - score time window in seconds ( default : 3600 ) . Outputs : BEATS : A vector of heart beat timestamps . D : The data stream used for heart beat detection . T : The timestamps corresponding to the data stream .","title":"mlt.beats.wholeDayHeartBeatFile"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeatAndSpectrogram.m/","text":"mlt.doc.getHeartBeatAndSpectrogram \u00b6 MLT . DOC . GETHEARTBEATANDSPECTROGRAM Fetches heartbeats and spectrograms for a subject across multiple sessions . DATA = mlt . doc . getHeartBeatAndSpectrogram ( S_IN , SUBJECT_NAME , RECORD_TYPE ) This function retrieves both heart beat and spectrogram data for a single , unique subject element identified by SUBJECT_NAME and RECORD_TYPE . It can operate on one or more sessions . It internally calls ` mlt . doc . getHeartBeats ` and ` mlt . doc . getSpectrogramData ` to fetch the respective data and documents for each session . The function returns a structure array with the following fields : 'session' - The ndi . session or ndi . dataset object for that entry . 'subject_local_identifier' - The name of the subject . 'recordType' - The type of record ( 'heart' , 'pylorus' , 'gastric' ) . 'HeartBeatDocs' - Cell array of 'ppg_beats' ndi . document objects . 'HeartBeatData' - Cell array of heart beat data structures . 'SpectrogramDocs' - Cell array of 'spectrogram' ndi . document objects . 'SpectrogramData' - Cell array of spectrogram data structures . Inputs : S_IN - An ndi . session , ndi . dataset object , or a cell array of them . SUBJECT_NAME - The name of the subject ( e . g ., 'SubjectA' ) . RECORD_TYPE - The record type ( e . g ., 'heart' ) . Outputs : DATA - A structure array containing the combined data , with one entry per session . See also : mlt . doc . getHeartBeats , mlt . doc . getSpectrogramData","title":"mlt.doc.getHeartBeatAndSpectrogram"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeatAndSpectrogram.m/#mltdocgetheartbeatandspectrogram","text":"MLT . DOC . GETHEARTBEATANDSPECTROGRAM Fetches heartbeats and spectrograms for a subject across multiple sessions . DATA = mlt . doc . getHeartBeatAndSpectrogram ( S_IN , SUBJECT_NAME , RECORD_TYPE ) This function retrieves both heart beat and spectrogram data for a single , unique subject element identified by SUBJECT_NAME and RECORD_TYPE . It can operate on one or more sessions . It internally calls ` mlt . doc . getHeartBeats ` and ` mlt . doc . getSpectrogramData ` to fetch the respective data and documents for each session . The function returns a structure array with the following fields : 'session' - The ndi . session or ndi . dataset object for that entry . 'subject_local_identifier' - The name of the subject . 'recordType' - The type of record ( 'heart' , 'pylorus' , 'gastric' ) . 'HeartBeatDocs' - Cell array of 'ppg_beats' ndi . document objects . 'HeartBeatData' - Cell array of heart beat data structures . 'SpectrogramDocs' - Cell array of 'spectrogram' ndi . document objects . 'SpectrogramData' - Cell array of spectrogram data structures . Inputs : S_IN - An ndi . session , ndi . dataset object , or a cell array of them . SUBJECT_NAME - The name of the subject ( e . g ., 'SubjectA' ) . RECORD_TYPE - The record type ( e . g ., 'heart' ) . Outputs : DATA - A structure array containing the combined data , with one entry per session . See also : mlt . doc . getHeartBeats , mlt . doc . getSpectrogramData","title":"mlt.doc.getHeartBeatAndSpectrogram"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeats.m/","text":"mlt.doc.getHeartBeats \u00b6 MLT . DOC . GETHEARTBEATS Finds heart beat documents for a unique subject element . [ HEARTBEAT_DOCS , HEARTBEAT_DATA ] = mlt . doc . getHeartBeats ( S , SUBJECT_NAME , RECORD_TYPE ) Searches an NDI session for a UNIQUE element that corresponds to a specific subject and recording location ( e . g ., 'heart' ) by calling `mlt.ndi.getElement` . It then finds all associated 'ppg_beats' NDI documents for that single element . If zero or more than one element matches the subject / type criteria , this function will error . For each document found , it calls `mlt.doc.heartBeatData` to extract the beat structure , performing time conversions to `datetime` objects if a global clock is available for the epoch . Inputs : S - An ndi . session or ndi . dataset object . SUBJECT_NAME - The name of the subject ( e . g ., 'SubjectA' ) as a character vector or string . RECORD_TYPE - The type of record to search for . Must be one of 'heart' , 'pylorus' , or 'gastric' . Outputs : HEARTBEAT_DOCS - A cell array of all matching 'ppg_beats' `ndi.document` objects for the single found element . HEARTBEAT_DATA - A cell array of the same size as HEARTBEAT_DOCS , where each cell contains the corresponding beat data structure returned by `mlt.doc.heartBeatData` . Example : % Find the heart beat records for 'SubjectB' , assuming they have only one 'heart' element . [ docs , data ] = mlt . doc . getHeartBeats ( mySession , 'SubjectB' , 'heart' ); See also : mlt . ndi . getElement , mlt . doc . heartBeatData","title":"mlt.doc.getHeartBeats"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeats.m/#mltdocgetheartbeats","text":"MLT . DOC . GETHEARTBEATS Finds heart beat documents for a unique subject element . [ HEARTBEAT_DOCS , HEARTBEAT_DATA ] = mlt . doc . getHeartBeats ( S , SUBJECT_NAME , RECORD_TYPE ) Searches an NDI session for a UNIQUE element that corresponds to a specific subject and recording location ( e . g ., 'heart' ) by calling `mlt.ndi.getElement` . It then finds all associated 'ppg_beats' NDI documents for that single element . If zero or more than one element matches the subject / type criteria , this function will error . For each document found , it calls `mlt.doc.heartBeatData` to extract the beat structure , performing time conversions to `datetime` objects if a global clock is available for the epoch . Inputs : S - An ndi . session or ndi . dataset object . SUBJECT_NAME - The name of the subject ( e . g ., 'SubjectA' ) as a character vector or string . RECORD_TYPE - The type of record to search for . Must be one of 'heart' , 'pylorus' , or 'gastric' . Outputs : HEARTBEAT_DOCS - A cell array of all matching 'ppg_beats' `ndi.document` objects for the single found element . HEARTBEAT_DATA - A cell array of the same size as HEARTBEAT_DOCS , where each cell contains the corresponding beat data structure returned by `mlt.doc.heartBeatData` . Example : % Find the heart beat records for 'SubjectB' , assuming they have only one 'heart' element . [ docs , data ] = mlt . doc . getHeartBeats ( mySession , 'SubjectB' , 'heart' ); See also : mlt . ndi . getElement , mlt . doc . heartBeatData","title":"mlt.doc.getHeartBeats"},{"location":"reference/%2Bmlt/%2Bdoc/getSpectrogramData.m/","text":"mlt.doc.getSpectrogramData \u00b6 MLT . DOC . GETSPECTROGRAMDATA Finds spectrogram documents for a unique subject element . [ SPECTROGRAM_DOCS , SPECTROGRAM_DATA ] = mlt . doc . getSpectrogramData ( S , SUBJECT_NAME , RECORD_TYPE ) Searches an NDI session for a UNIQUE element that corresponds to a specific subject and recording location ( e . g ., 'heart' ) by calling `mlt.ndi.getElement` . It then finds all associated 'spectrogram' NDI documents for that single element . If zero or more than one element matches the subject / type criteria , this function will error . For each document found , it calls `mlt.doc.spectrogramData` to extract the spectrogram matrix , frequency vector , and time vector , performing time conversions to `datetime` objects if a global clock is available . Inputs : S - An ndi . session or ndi . dataset object . SUBJECT_NAME - The name of the subject ( e . g ., 'SubjectA' ) as a character vector or string . RECORD_TYPE - The type of record to search for . Must be one of 'heart' , 'pylorus' , or 'gastric' . Outputs : SPECTROGRAM_DOCS - A cell array of all matching 'spectrogram' `ndi.document` objects for the single found element . SPECTROGRAM_DATA - A cell array of the same size as SPECTROGRAM_DOCS . Each cell contains a structure with the fields : . spec - The spectrogram data matrix . f - The frequency vector . ts - The time vector ( `datetime` or numeric ) Example : % Find the spectrogram records for 'SubjectB' , assuming they have only one 'heart' element . [ docs , data ] = mlt . doc . getSpectrogramData ( mySession , 'SubjectB' , 'heart' ); See also : mlt . ndi . getElement , mlt . doc . spectrogramData","title":"mlt.doc.getSpectrogramData"},{"location":"reference/%2Bmlt/%2Bdoc/getSpectrogramData.m/#mltdocgetspectrogramdata","text":"MLT . DOC . GETSPECTROGRAMDATA Finds spectrogram documents for a unique subject element . [ SPECTROGRAM_DOCS , SPECTROGRAM_DATA ] = mlt . doc . getSpectrogramData ( S , SUBJECT_NAME , RECORD_TYPE ) Searches an NDI session for a UNIQUE element that corresponds to a specific subject and recording location ( e . g ., 'heart' ) by calling `mlt.ndi.getElement` . It then finds all associated 'spectrogram' NDI documents for that single element . If zero or more than one element matches the subject / type criteria , this function will error . For each document found , it calls `mlt.doc.spectrogramData` to extract the spectrogram matrix , frequency vector , and time vector , performing time conversions to `datetime` objects if a global clock is available . Inputs : S - An ndi . session or ndi . dataset object . SUBJECT_NAME - The name of the subject ( e . g ., 'SubjectA' ) as a character vector or string . RECORD_TYPE - The type of record to search for . Must be one of 'heart' , 'pylorus' , or 'gastric' . Outputs : SPECTROGRAM_DOCS - A cell array of all matching 'spectrogram' `ndi.document` objects for the single found element . SPECTROGRAM_DATA - A cell array of the same size as SPECTROGRAM_DOCS . Each cell contains a structure with the fields : . spec - The spectrogram data matrix . f - The frequency vector . ts - The time vector ( `datetime` or numeric ) Example : % Find the spectrogram records for 'SubjectB' , assuming they have only one 'heart' element . [ docs , data ] = mlt . doc . getSpectrogramData ( mySession , 'SubjectB' , 'heart' ); See also : mlt . ndi . getElement , mlt . doc . spectrogramData","title":"mlt.doc.getSpectrogramData"},{"location":"reference/%2Bmlt/%2Bdoc/heartBeatData.m/","text":"mlt.doc.heartBeatData \u00b6 MLT . DOC . HEARTBEATDATA Retrieves heart beat data from an NDI document with datetime conversion . BEATS = mlt . doc . heartBeatData ( S , PPG_BEATS_DOC ) This function accesses the beat information stored in a 'ppg_beats' NDI document . A key feature of this function is its handling of time . It inspects the epoch 's clock information from the element the document depends on. If a global time clock (e.g., ' exp_global_time ') is available for the epoch, the time fields within the returned BEATS structure (e.g., ' . onset ', ' . offset ') are converted to MATLAB `datetime` objects. If no global clock is found, these timestamps remain as numeric values in seconds from the start of the epoch. Inputs: S - An ndi.session or ndi.dataset object. PPG_BEATS_DOC - An ' ppg_beats ' ndi.document object. Outputs: BEATS - A structure array where each element represents a detected beat. Time-related fields will be `datetime` objects if a global clock is present, otherwise they will be numeric (seconds). Example: % Assume ' mySession ' is a valid NDI session object and we have found % a ' ppg_beats ' document. e = mySession.getelements(' element . name ', ' ppg_heart_lp_whole ', ' element . reference ', 1); et = e{1}.epochtable(); ppg_beats_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ... e{1}.id(), et(1).epoch_id, ' ppg_beats '); if ~isempty(ppg_beats_doc) beats_with_datetime = mlt.doc.heartBeatData(mySession, ppg_beats_doc{1}); % Check the class of the onset time for the first beat disp([' Class of beat onset time : ' class(beats_with_datetime(1).onset)]); end See also: mlt.beats.beatsdoc2struct, ndi.time.syncgraph.time_convert","title":"mlt.doc.heartBeatData"},{"location":"reference/%2Bmlt/%2Bdoc/heartBeatData.m/#mltdocheartbeatdata","text":"MLT . DOC . HEARTBEATDATA Retrieves heart beat data from an NDI document with datetime conversion . BEATS = mlt . doc . heartBeatData ( S , PPG_BEATS_DOC ) This function accesses the beat information stored in a 'ppg_beats' NDI document . A key feature of this function is its handling of time . It inspects the epoch 's clock information from the element the document depends on. If a global time clock (e.g., ' exp_global_time ') is available for the epoch, the time fields within the returned BEATS structure (e.g., ' . onset ', ' . offset ') are converted to MATLAB `datetime` objects. If no global clock is found, these timestamps remain as numeric values in seconds from the start of the epoch. Inputs: S - An ndi.session or ndi.dataset object. PPG_BEATS_DOC - An ' ppg_beats ' ndi.document object. Outputs: BEATS - A structure array where each element represents a detected beat. Time-related fields will be `datetime` objects if a global clock is present, otherwise they will be numeric (seconds). Example: % Assume ' mySession ' is a valid NDI session object and we have found % a ' ppg_beats ' document. e = mySession.getelements(' element . name ', ' ppg_heart_lp_whole ', ' element . reference ', 1); et = e{1}.epochtable(); ppg_beats_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ... e{1}.id(), et(1).epoch_id, ' ppg_beats '); if ~isempty(ppg_beats_doc) beats_with_datetime = mlt.doc.heartBeatData(mySession, ppg_beats_doc{1}); % Check the class of the onset time for the first beat disp([' Class of beat onset time : ' class(beats_with_datetime(1).onset)]); end See also: mlt.beats.beatsdoc2struct, ndi.time.syncgraph.time_convert","title":"mlt.doc.heartBeatData"},{"location":"reference/%2Bmlt/%2Bdoc/spectrogramData.m/","text":"mlt.doc.spectrogramData \u00b6 MLT . DOC . SPECTROGRAMDATA Retrieves spectrogram data from an NDI document . [ SPEC , F , TS ] = mlt . doc . spectrogramData ( S , SPECTROGRAM_DOC ) This function extracts the full spectrogram data matrix , frequency vector , and time vector from a 'spectrogram' NDI document . A key feature of this function is its handling of time . It inspects the epoch 's clock information from the element the document depends on. If a global time clock (e.g., ' exp_global_time ') is available for the epoch, the output time vector ' TS ' is converted to a MATLAB `datetime` object. If no global clock is found, the time vector is returned as numeric values in seconds from the start of the epoch. Inputs: S - An ndi.session or ndi.dataset object. SPECTROGRAM_DOC - A ' spectrogram ' ndi.document object. Outputs: SPEC - The spectrogram data matrix, with dimensions [frequency x time]. F - A column vector of frequencies (Hz) corresponding to the rows of SPEC. TS - A column vector of timestamps for the spectrogram. Will be a `datetime` vector if a global clock is present, otherwise numeric (seconds). Example: % Assume ' mySession ' is a valid NDI session object and we have found % a ' spectrogram ' document for a pylorus element. e_pylorus = mySession.getelements(' element . name ', ' ppg_pylorus_lp_whole ', ' element . reference ', 1); et = e_pylorus{1}.epochtable(); spectrogram_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ... e_pylorus{1}.id(), et(1).epoch_id, ' spectrogram '); if ~isempty(spectrogram_doc) [spec_data, freqs, times] = mlt.doc.spectrogramData(mySession, spectrogram_doc{1}); % Check the class of the time vector disp([' Class of time vector TS : ' class(times)]); % Plot the spectrogram figure; imagesc(times, freqs, spec_data); set(gca, ' YDir ', ' normal '); ylabel(' Frequency ( Hz ) '); % datetick(' x '); % Use if times are datetime end See also: ndi.fun.data.readngrid, ndi.time.syncgraph.time_convert","title":"mlt.doc.spectrogramData"},{"location":"reference/%2Bmlt/%2Bdoc/spectrogramData.m/#mltdocspectrogramdata","text":"MLT . DOC . SPECTROGRAMDATA Retrieves spectrogram data from an NDI document . [ SPEC , F , TS ] = mlt . doc . spectrogramData ( S , SPECTROGRAM_DOC ) This function extracts the full spectrogram data matrix , frequency vector , and time vector from a 'spectrogram' NDI document . A key feature of this function is its handling of time . It inspects the epoch 's clock information from the element the document depends on. If a global time clock (e.g., ' exp_global_time ') is available for the epoch, the output time vector ' TS ' is converted to a MATLAB `datetime` object. If no global clock is found, the time vector is returned as numeric values in seconds from the start of the epoch. Inputs: S - An ndi.session or ndi.dataset object. SPECTROGRAM_DOC - A ' spectrogram ' ndi.document object. Outputs: SPEC - The spectrogram data matrix, with dimensions [frequency x time]. F - A column vector of frequencies (Hz) corresponding to the rows of SPEC. TS - A column vector of timestamps for the spectrogram. Will be a `datetime` vector if a global clock is present, otherwise numeric (seconds). Example: % Assume ' mySession ' is a valid NDI session object and we have found % a ' spectrogram ' document for a pylorus element. e_pylorus = mySession.getelements(' element . name ', ' ppg_pylorus_lp_whole ', ' element . reference ', 1); et = e_pylorus{1}.epochtable(); spectrogram_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ... e_pylorus{1}.id(), et(1).epoch_id, ' spectrogram '); if ~isempty(spectrogram_doc) [spec_data, freqs, times] = mlt.doc.spectrogramData(mySession, spectrogram_doc{1}); % Check the class of the time vector disp([' Class of time vector TS : ' class(times)]); % Plot the spectrogram figure; imagesc(times, freqs, spec_data); set(gca, ' YDir ', ' normal '); ylabel(' Frequency ( Hz ) '); % datetick(' x '); % Use if times are datetime end See also: ndi.fun.data.readngrid, ndi.time.syncgraph.time_convert","title":"mlt.doc.spectrogramData"},{"location":"reference/%2Bmlt/%2Bhmm/Analysis.m/","text":"mlt.hmm.Analysis \u00b6 ANALYSIS Performs a full HMM analysis pipeline on beat time data . [ states , timestamps , rates , state_stats ] = mlt . hmm . Analysis ( beat_times ) This high - level function runs a complete Hidden Markov Model ( HMM ) pipeline . It takes a vector of beat times , calculates a continuous beat rate signal , fits an HMM to this signal , and decodes the most likely sequence of hidden states . Inputs : beat_times - A vector of beat times ( numeric seconds or datetime ) . Optional Name - Value Pair Arguments : N ( 1 , 1 ) double = 2 Number of hidden states . ModelType ( 1 , 1 ) string = \"gaussian\" Model to use : \"discrete\" or \"gaussian\" . The \"gaussian\" model requires Kevin Murphy 's Bayes Net Toolbox (BNT). InitialModel ( 1 , 1 ) struct = struct () A pre - trained model struct ( from mlt . hmm . fit or mlt . hmm . fitGauss ) . If provided , the fitting step is skipped and this model is used directly for decoding . deltaT ( 1 , 1 ) double = 0.5 Time step for rate binning ( seconds ) . W ( 1 , 1 ) double = 5 Window size for rate binning ( seconds ) . ( And other model - specific options for fitting ... ) Outputs : states - Vector of the most likely ( sorted ) state for each bin . timestamps - Timestamps for the center of each bin . rates - The calculated beat rate ( Hz ) for each bin . state_stats - N - by - 2 matrix of [ mean_rate , std_dev_rate ] for each state . Example 1 : Standard Fitting and Visualization % First , load the beat times from a pre - processed _beats . mat file L = load ( 'ppg_ppg_heart_lp_whole_1_beats.mat' ); beat_times = [ L . beats . onset ]; % Perform a 2 - state Gaussian HMM analysis using default settings [ states , ts , rates , stats ] = mlt . hmm . Analysis ( beat_times ); % Visualize the state sequence overlaid on the beat rate mlt . plot . HMMStates ( states , ts , rates ); % Optionally , calculate and plot dwell time distributions DwellStats = mlt . hmm . StateDwellTimes ( states , ts ); mlt . plot . HMMStateDwellTimes ( DwellStats ); Example 2 : Using a Pre - Defined 'InitialModel' to Decode % Define a fixed 2 - state Gaussian model struct myFixedModel . prior = [ 0.2 ; 0.8 ]; myFixedModel . transmat = [ 0.9 0.1 ; 0.1 0.9 ]; % BNT requires specific dimensions : [ ObsDim x NumStates x NumMixes ] myFixedModel . mu = reshape ([ 0 1 ], [ 1 2 1 ]); % BNT requires specific dimensions : [ ObsDim x ObsDim x NumStates x NumMixes ] myFixedModel . Sigma = reshape ([ 0.05 , 1 ], [ 1 1 2 1 ]); myFixedModel . mixmat = ones ( 2 , 1 ); % For a single Gaussian per state myFixedModel . StateRemap = [ 1 2 ]; % Run analysis , which will now skip the fitting step [ states , ts , rates , stats ] = mlt . hmm . Analysis ( beat_times , ... 'ModelType' , 'gaussian' , ... 'InitialModel' , myFixedModel ); See also mlt . hmm . fit , mlt . hmm . decode , mlt . hmm . fitGauss , mlt . hmm . decodeGauss , mlt . plot . HMMStates","title":"mlt.hmm.Analysis"},{"location":"reference/%2Bmlt/%2Bhmm/Analysis.m/#mlthmmanalysis","text":"ANALYSIS Performs a full HMM analysis pipeline on beat time data . [ states , timestamps , rates , state_stats ] = mlt . hmm . Analysis ( beat_times ) This high - level function runs a complete Hidden Markov Model ( HMM ) pipeline . It takes a vector of beat times , calculates a continuous beat rate signal , fits an HMM to this signal , and decodes the most likely sequence of hidden states . Inputs : beat_times - A vector of beat times ( numeric seconds or datetime ) . Optional Name - Value Pair Arguments : N ( 1 , 1 ) double = 2 Number of hidden states . ModelType ( 1 , 1 ) string = \"gaussian\" Model to use : \"discrete\" or \"gaussian\" . The \"gaussian\" model requires Kevin Murphy 's Bayes Net Toolbox (BNT). InitialModel ( 1 , 1 ) struct = struct () A pre - trained model struct ( from mlt . hmm . fit or mlt . hmm . fitGauss ) . If provided , the fitting step is skipped and this model is used directly for decoding . deltaT ( 1 , 1 ) double = 0.5 Time step for rate binning ( seconds ) . W ( 1 , 1 ) double = 5 Window size for rate binning ( seconds ) . ( And other model - specific options for fitting ... ) Outputs : states - Vector of the most likely ( sorted ) state for each bin . timestamps - Timestamps for the center of each bin . rates - The calculated beat rate ( Hz ) for each bin . state_stats - N - by - 2 matrix of [ mean_rate , std_dev_rate ] for each state . Example 1 : Standard Fitting and Visualization % First , load the beat times from a pre - processed _beats . mat file L = load ( 'ppg_ppg_heart_lp_whole_1_beats.mat' ); beat_times = [ L . beats . onset ]; % Perform a 2 - state Gaussian HMM analysis using default settings [ states , ts , rates , stats ] = mlt . hmm . Analysis ( beat_times ); % Visualize the state sequence overlaid on the beat rate mlt . plot . HMMStates ( states , ts , rates ); % Optionally , calculate and plot dwell time distributions DwellStats = mlt . hmm . StateDwellTimes ( states , ts ); mlt . plot . HMMStateDwellTimes ( DwellStats ); Example 2 : Using a Pre - Defined 'InitialModel' to Decode % Define a fixed 2 - state Gaussian model struct myFixedModel . prior = [ 0.2 ; 0.8 ]; myFixedModel . transmat = [ 0.9 0.1 ; 0.1 0.9 ]; % BNT requires specific dimensions : [ ObsDim x NumStates x NumMixes ] myFixedModel . mu = reshape ([ 0 1 ], [ 1 2 1 ]); % BNT requires specific dimensions : [ ObsDim x ObsDim x NumStates x NumMixes ] myFixedModel . Sigma = reshape ([ 0.05 , 1 ], [ 1 1 2 1 ]); myFixedModel . mixmat = ones ( 2 , 1 ); % For a single Gaussian per state myFixedModel . StateRemap = [ 1 2 ]; % Run analysis , which will now skip the fitting step [ states , ts , rates , stats ] = mlt . hmm . Analysis ( beat_times , ... 'ModelType' , 'gaussian' , ... 'InitialModel' , myFixedModel ); See also mlt . hmm . fit , mlt . hmm . decode , mlt . hmm . fitGauss , mlt . hmm . decodeGauss , mlt . plot . HMMStates","title":"mlt.hmm.Analysis"},{"location":"reference/%2Bmlt/%2Bhmm/StateDwellTimes.m/","text":"mlt.hmm.StateDwellTimes \u00b6 STATEDWELLTIMES Calculates and histograms the dwell time for each HMM state. DwellStats = mlt . hmm . StateDwellTimes ( states , timestamps ) Takes the state sequence output from mlt . hmm . Analysis and calculates the duration of each consecutive period spent in a given state . It then computes a histogram of these durations for each state . Inputs : states - A vector of integer state assignments , e . g ., from mlt . hmm . Analysis . timestamps - A vector of timestamps corresponding to each state assignment . Can be numeric ( seconds ) or datetime . Must be evenly spaced . Optional Name - Value Pair Arguments : timeBins - A vector of bin edges for the histogram . Default : 100 log - spaced bins from 0 . 1 s to 3600 s . Outputs : DwellStats - A structure array with one entry for each state . Each element has the fields : - . state : The state number . - . histBinTimes : The center time of each histogram bin ( s ). - . histBinCount : The number of dwells in each bin . Example & Plotting : % First, run the main analysis pipeline [ states , timestamps ] = mlt . hmm . Analysis ( beat_times ); % Now, calculate the dwell time statistics DwellStats = mlt . hmm . StateDwellTimes ( states , timestamps ); % Finally, generate the plot with the dedicated plotting function mlt . plot . HMMStateDwellTimes ( DwellStats ); See also mlt.hmm.Analysis, mlt.plot.HMMStateDwellTimes, histcounts","title":"mlt.hmm.StateDwellTimes"},{"location":"reference/%2Bmlt/%2Bhmm/StateDwellTimes.m/#mlthmmstatedwelltimes","text":"STATEDWELLTIMES Calculates and histograms the dwell time for each HMM state. DwellStats = mlt . hmm . StateDwellTimes ( states , timestamps ) Takes the state sequence output from mlt . hmm . Analysis and calculates the duration of each consecutive period spent in a given state . It then computes a histogram of these durations for each state . Inputs : states - A vector of integer state assignments , e . g ., from mlt . hmm . Analysis . timestamps - A vector of timestamps corresponding to each state assignment . Can be numeric ( seconds ) or datetime . Must be evenly spaced . Optional Name - Value Pair Arguments : timeBins - A vector of bin edges for the histogram . Default : 100 log - spaced bins from 0 . 1 s to 3600 s . Outputs : DwellStats - A structure array with one entry for each state . Each element has the fields : - . state : The state number . - . histBinTimes : The center time of each histogram bin ( s ). - . histBinCount : The number of dwells in each bin . Example & Plotting : % First, run the main analysis pipeline [ states , timestamps ] = mlt . hmm . Analysis ( beat_times ); % Now, calculate the dwell time statistics DwellStats = mlt . hmm . StateDwellTimes ( states , timestamps ); % Finally, generate the plot with the dedicated plotting function mlt . plot . HMMStateDwellTimes ( DwellStats ); See also mlt.hmm.Analysis, mlt.plot.HMMStateDwellTimes, histcounts","title":"mlt.hmm.StateDwellTimes"},{"location":"reference/%2Bmlt/%2Bhmm/decode.m/","text":"mlt.hmm.decode \u00b6 DECODE Finds the most likely state sequence using the Viterbi algorithm. STATES = mlt . hmm . decode ( rates , TRANS , EMIS , fit_info ) Calculates the most likely sequence of hidden states for a discrete HMM given a sequence of continuous observations ( 'rates' ). It uses the 'fit_info' struct from mlt . hmm . fit to discretize the rate data and then remaps the output states to match the sorted order from the fitting step . Inputs : rates - A vector of observed continuous rates . TRANS - An N - by - N state transition matrix from mlt . hmm . fit . EMIS - The emission probability matrix from mlt . hmm . fit . fit_info - The fit_info struct output by mlt . hmm . fit . Outputs : states - A vector the same length as 'rates' containing the most likely sequence of hidden states ( sorted 1 to N ). Example : % Assume 'training_rates' and 'new_rates' are vectors of data % 1. Fit an HMM to a training dataset num_states = 4 ; [ TRANS_est , EMIS_est , fit_info ] = mlt . hmm . fit ( training_rates , num_states ); % 2. Decode a new sequence of rates using the fitted model most_likely_states = mlt . hmm . decode ( new_rates , TRANS_est , EMIS_est , fit_info ); See also mlt.hmm.fit, hmmviterbi","title":"mlt.hmm.decode"},{"location":"reference/%2Bmlt/%2Bhmm/decode.m/#mlthmmdecode","text":"DECODE Finds the most likely state sequence using the Viterbi algorithm. STATES = mlt . hmm . decode ( rates , TRANS , EMIS , fit_info ) Calculates the most likely sequence of hidden states for a discrete HMM given a sequence of continuous observations ( 'rates' ). It uses the 'fit_info' struct from mlt . hmm . fit to discretize the rate data and then remaps the output states to match the sorted order from the fitting step . Inputs : rates - A vector of observed continuous rates . TRANS - An N - by - N state transition matrix from mlt . hmm . fit . EMIS - The emission probability matrix from mlt . hmm . fit . fit_info - The fit_info struct output by mlt . hmm . fit . Outputs : states - A vector the same length as 'rates' containing the most likely sequence of hidden states ( sorted 1 to N ). Example : % Assume 'training_rates' and 'new_rates' are vectors of data % 1. Fit an HMM to a training dataset num_states = 4 ; [ TRANS_est , EMIS_est , fit_info ] = mlt . hmm . fit ( training_rates , num_states ); % 2. Decode a new sequence of rates using the fitted model most_likely_states = mlt . hmm . decode ( new_rates , TRANS_est , EMIS_est , fit_info ); See also mlt.hmm.fit, hmmviterbi","title":"mlt.hmm.decode"},{"location":"reference/%2Bmlt/%2Bhmm/decodeGauss.m/","text":"mlt.hmm.decodeGauss \u00b6 DECODEGAUSS Finds the most likely state sequence for a Gaussian HMM. STATES = mlt . hmm . decodeGauss ( rates , model ) Calculates the most likely sequence of hidden states for an HMM with Gaussian emissions using the Viterbi algorithm . *** REQUIRES KEVIN MURPHY ' S BAYES NET TOOLBOX ( BNT ) *** Inputs : rates - A vector of observed continuous rates . model - The trained Gaussian HMM model struct from mlt . hmm . fitGauss . Outputs : states - A vector of the most likely ( sorted ) state for each time point . Example : % Assume 'training_rates' and 'new_rates' are vectors of data % 1. Fit a Gaussian HMM to a training dataset num_states = 4 ; model = mlt . hmm . fitGauss ( training_rates , num_states ); % 2. Decode a new sequence of rates using the fitted model most_likely_states = mlt . hmm . decodeGauss ( new_rates , model ); See also mlt.hmm.fitGauss, viterbi_path","title":"mlt.hmm.decodeGauss"},{"location":"reference/%2Bmlt/%2Bhmm/decodeGauss.m/#mlthmmdecodegauss","text":"DECODEGAUSS Finds the most likely state sequence for a Gaussian HMM. STATES = mlt . hmm . decodeGauss ( rates , model ) Calculates the most likely sequence of hidden states for an HMM with Gaussian emissions using the Viterbi algorithm . *** REQUIRES KEVIN MURPHY ' S BAYES NET TOOLBOX ( BNT ) *** Inputs : rates - A vector of observed continuous rates . model - The trained Gaussian HMM model struct from mlt . hmm . fitGauss . Outputs : states - A vector of the most likely ( sorted ) state for each time point . Example : % Assume 'training_rates' and 'new_rates' are vectors of data % 1. Fit a Gaussian HMM to a training dataset num_states = 4 ; model = mlt . hmm . fitGauss ( training_rates , num_states ); % 2. Decode a new sequence of rates using the fitted model most_likely_states = mlt . hmm . decodeGauss ( new_rates , model ); See also mlt.hmm.fitGauss, viterbi_path","title":"mlt.hmm.decodeGauss"},{"location":"reference/%2Bmlt/%2Bhmm/fit.m/","text":"mlt.hmm.fit \u00b6 FIT Fits a discrete HMM and characterizes states by rate statistics. [ TRANS , EMIS , state_stats , fit_info ] = mlt . hmm . fit ( rates , N ) Fits an N - state Hidden Markov Model ( HMM ) to the provided rate data . It uses a discrete emission model , which is required by MATLAB ' s hmmtrain function . To do this , it first quantizes the continuous rate data into a finite number of symbols . After fitting , it characterizes each state by the mean and standard deviation of the continuous rates that were assigned to it . The states are then sorted and re - ordered based on this mean rate ( lowest to highest ). Inputs : rates - A vector of observed rates , e . g ., from mlt . beats . beatRateBins . N - The number of hidden states for the model . Optional Name - Value Pair Arguments : NumSymbols ( 1 , 1 ) double = 10 The number of discrete symbols to quantize the 'rates' data into . MaxIterations ( 1 , 1 ) double = 100 Maximum number of iterations for the Baum - Welch algorithm . Tolerance ( 1 , 1 ) double = 1e-4 Convergence tolerance for the Baum - Welch algorithm . Outputs : TRANS - An N - by - N matrix of sorted state transition probabilities . EMIS - An N - by - NumSymbols sorted emission probability matrix . state_stats - An N - by - 2 matrix where column 1 is the mean rate and column 2 is the std . dev . of the rate for each sorted state . fit_info - A struct containing information ( quantization edges and state remapping ) needed for decoding new data with mlt . hmm . decode . Example : % Assume 'training_rates' is a vector of beat-to-beat rates num_states = 4 ; [ TRANS , EMIS , stats , info ] = mlt . hmm . fit ( training_rates , num_states ); % Now you can use these outputs to decode a new rate sequence: % decoded_states = mlt.hmm.decode(new_rates, TRANS, EMIS, info); See also mlt.hmm.decode, hmmtrain, hmmviterbi","title":"mlt.hmm.fit"},{"location":"reference/%2Bmlt/%2Bhmm/fit.m/#mlthmmfit","text":"FIT Fits a discrete HMM and characterizes states by rate statistics. [ TRANS , EMIS , state_stats , fit_info ] = mlt . hmm . fit ( rates , N ) Fits an N - state Hidden Markov Model ( HMM ) to the provided rate data . It uses a discrete emission model , which is required by MATLAB ' s hmmtrain function . To do this , it first quantizes the continuous rate data into a finite number of symbols . After fitting , it characterizes each state by the mean and standard deviation of the continuous rates that were assigned to it . The states are then sorted and re - ordered based on this mean rate ( lowest to highest ). Inputs : rates - A vector of observed rates , e . g ., from mlt . beats . beatRateBins . N - The number of hidden states for the model . Optional Name - Value Pair Arguments : NumSymbols ( 1 , 1 ) double = 10 The number of discrete symbols to quantize the 'rates' data into . MaxIterations ( 1 , 1 ) double = 100 Maximum number of iterations for the Baum - Welch algorithm . Tolerance ( 1 , 1 ) double = 1e-4 Convergence tolerance for the Baum - Welch algorithm . Outputs : TRANS - An N - by - N matrix of sorted state transition probabilities . EMIS - An N - by - NumSymbols sorted emission probability matrix . state_stats - An N - by - 2 matrix where column 1 is the mean rate and column 2 is the std . dev . of the rate for each sorted state . fit_info - A struct containing information ( quantization edges and state remapping ) needed for decoding new data with mlt . hmm . decode . Example : % Assume 'training_rates' is a vector of beat-to-beat rates num_states = 4 ; [ TRANS , EMIS , stats , info ] = mlt . hmm . fit ( training_rates , num_states ); % Now you can use these outputs to decode a new rate sequence: % decoded_states = mlt.hmm.decode(new_rates, TRANS, EMIS, info); See also mlt.hmm.decode, hmmtrain, hmmviterbi","title":"mlt.hmm.fit"},{"location":"reference/%2Bmlt/%2Bhmm/fitGauss.m/","text":"mlt.hmm.fitGauss \u00b6 FITGAUSS Fits a Hidden Markov Model with Gaussian emissions using BNT . MODEL = mlt . hmm . fitGauss ( rates , N ) fits an N - state HMM to the continuous rate data using Gaussian distributions for the emissions . The states are sorted by their mean emission rate ( lowest to highest ) . *** REQUIRES KEVIN MURPHY 'S BAYES NET TOOLBOX (BNT) *** Download from : https : // github . com / bayesnet / bnt And add to your MATLAB path using : addpath ( genpath ( 'path/to/bnt' )) Inputs : rates - A vector of observed continuous rates . N - The number of hidden states for the model . Optional Name - Value Pair Arguments : MaxIterations - Maximum number of iterations for the EM algorithm . Default : 100. Outputs : model - A struct containing the trained and sorted HMM parameters , ready for use with mlt . hmm . decodeGauss . Example : % Assume 'training_rates' is a vector of your data num_states = 4 ; model = mlt . hmm . fitGauss ( training_rates , num_states ); % The 'model' struct can now be used to decode new sequences : % decoded_states = mlt . hmm . decodeGauss ( new_rates , model ); See also mlt . hmm . decodeGauss , mhmm_em , kmeans","title":"mlt.hmm.fitGauss"},{"location":"reference/%2Bmlt/%2Bhmm/fitGauss.m/#mlthmmfitgauss","text":"FITGAUSS Fits a Hidden Markov Model with Gaussian emissions using BNT . MODEL = mlt . hmm . fitGauss ( rates , N ) fits an N - state HMM to the continuous rate data using Gaussian distributions for the emissions . The states are sorted by their mean emission rate ( lowest to highest ) . *** REQUIRES KEVIN MURPHY 'S BAYES NET TOOLBOX (BNT) *** Download from : https : // github . com / bayesnet / bnt And add to your MATLAB path using : addpath ( genpath ( 'path/to/bnt' )) Inputs : rates - A vector of observed continuous rates . N - The number of hidden states for the model . Optional Name - Value Pair Arguments : MaxIterations - Maximum number of iterations for the EM algorithm . Default : 100. Outputs : model - A struct containing the trained and sorted HMM parameters , ready for use with mlt . hmm . decodeGauss . Example : % Assume 'training_rates' is a vector of your data num_states = 4 ; model = mlt . hmm . fitGauss ( training_rates , num_states ); % The 'model' struct can now be used to decode new sequences : % decoded_states = mlt . hmm . decodeGauss ( new_rates , model ); See also mlt . hmm . decodeGauss , mhmm_em , kmeans","title":"mlt.hmm.fitGauss"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/findInhibitoryBouts.m/","text":"mlt.inhibitoryBouts.findInhibitoryBouts \u00b6 MLT . FINDINHIBITORYBOUTS Identifies inhibitory bouts from beat time data . bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ) analyzes a vector of beat times to identify periods of significant heart rate slowdown ( inhibition ) and the subsequent recovery . The function first calculates the beat rate in sliding time windows . It then iterates through the rate data to find onsets and offsets . SYNTAX : bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ) bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times , Name , Value , ... ) INPUTS : beat_times - A vector of beat times ( numeric seconds or datetime ). OPTIONAL NAME - VALUE PAIR ARGUMENTS : 'deltaT' - The time step ( in seconds ) for rate binning . Default : 0.5 seconds . 'W' - The total width of the sliding window ( in seconds ) for rate binning . Default : 5 seconds . 'InhibitoryBoutSlowDownOnsetThreshold' - The fractional threshold for detecting an inhibitory bout onset . Default : 0.5 ( i . e ., a 50 % slowdown). 'InhibitoryBoutEndOnsetThreshold' - The fractional threshold for detecting the end of a bout . Default : 1.5 ( i . e ., a 150 % speedup). 'InhibitoryBoutOnsetOffsetTimeWindow' - The duration ( in seconds ) over which the rate change is evaluated . Default : 1 second . OUTPUTS : bouts - A structure with four fields : . inhibitoryBoutOnset : A vector of timestamps for the start of each detected inhibitory bout . . inhibitoryBoutOffset : A vector of timestamps for the end of each detected inhibitory bout . . beatRate : The vector of binned beat rates ( Hz ). . beatRateTimes : The timestamps for each binned rate . EXAMPLE : beat_times = [ ( 0 : 0.4 : 10 ), ( 10.5 : 1 : 20 ), ( 20.4 : 0.4 : 30 ) ] ' ; bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ); % The 'bouts' struct now contains onsets, offsets, and the rate data.","title":"mlt.inhibitoryBouts.findInhibitoryBouts"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/findInhibitoryBouts.m/#mltinhibitoryboutsfindinhibitorybouts","text":"MLT . FINDINHIBITORYBOUTS Identifies inhibitory bouts from beat time data . bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ) analyzes a vector of beat times to identify periods of significant heart rate slowdown ( inhibition ) and the subsequent recovery . The function first calculates the beat rate in sliding time windows . It then iterates through the rate data to find onsets and offsets . SYNTAX : bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ) bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times , Name , Value , ... ) INPUTS : beat_times - A vector of beat times ( numeric seconds or datetime ). OPTIONAL NAME - VALUE PAIR ARGUMENTS : 'deltaT' - The time step ( in seconds ) for rate binning . Default : 0.5 seconds . 'W' - The total width of the sliding window ( in seconds ) for rate binning . Default : 5 seconds . 'InhibitoryBoutSlowDownOnsetThreshold' - The fractional threshold for detecting an inhibitory bout onset . Default : 0.5 ( i . e ., a 50 % slowdown). 'InhibitoryBoutEndOnsetThreshold' - The fractional threshold for detecting the end of a bout . Default : 1.5 ( i . e ., a 150 % speedup). 'InhibitoryBoutOnsetOffsetTimeWindow' - The duration ( in seconds ) over which the rate change is evaluated . Default : 1 second . OUTPUTS : bouts - A structure with four fields : . inhibitoryBoutOnset : A vector of timestamps for the start of each detected inhibitory bout . . inhibitoryBoutOffset : A vector of timestamps for the end of each detected inhibitory bout . . beatRate : The vector of binned beat rates ( Hz ). . beatRateTimes : The timestamps for each binned rate . EXAMPLE : beat_times = [ ( 0 : 0.4 : 10 ), ( 10.5 : 1 : 20 ), ( 20.4 : 0.4 : 30 ) ] ' ; bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ); % The 'bouts' struct now contains onsets, offsets, and the rate data.","title":"mlt.inhibitoryBouts.findInhibitoryBouts"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibBoutAnalysis.m/","text":"mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis \u00b6 MLT . inhibitoryBouts . SPECTROGRAMINHIBBOUTANALYSIS Analyze spectrogram FWHM around inhibition bout times . [ SPECDATA_MATRIX , F , FWHM_VECTOR , LOW_CUTOFF_VECTOR , HIGH_CUTOFF_VECTOR ] = ... mlt . inhibitoryBouts . spectrogramInhibBoutAnalysis ( E , INHIBBOUTTIMES , SKIP , TIMEWINDOW ) Analyzes the spectrogram associated with an ndi . element E around specified inhibition bout times . For each time provided in INHIBBOUTTIMES , it defines a time window starting at INHIBBOUTTIMES ( i ) + SKIP and lasting for TIMEWINDOW seconds . It calculates the time - averaged spectrogram within that window and computes its Full Width at Half Maximum ( FWHM ) . Inputs : E - An ndi . element object . The session is retrieved from e . session . The element should have associated 'spectrogram' documents . INHIBBOUTTIMES - A vector of Matlab datetime objects indicating the start times of inhibition bouts . SKIP - A double scalar indicating the time offset in seconds relative to each inhibBoutTime to start the analysis window . Can be positive or negative . TIMEWINDOW - A double scalar indicating the duration in seconds of the analysis window . Can be positive ( window goes forward from start ) or negative ( window goes backward from start ) . Outputs : SPECDATA_MATRIX - A matrix where each column is the time - averaged power spectrum ( column vector ) calculated for the window corresponding to each entry in INHIBBOUTTIMES . If analysis fails for a specific bout time , the corresponding column might be omitted or filled with NaNs depending on downstream processing needs ( currently , only successful results are concatenated ) . Returns [] if no successful analyses are performed . F - The frequency vector ( numeric column vector ) corresponding to the rows of SPECDATA_MATRIX . Assumes the frequency vector is consistent across all analyses . Returns [] if no successful analyses are performed . FWHM_VECTOR - A row vector containing the FWHM value for each successfully analyzed time window . Contains NaN for windows where calculation failed or was not possible . LOW_CUTOFF_VECTOR - A row vector containing the lower frequency cutoff at half maximum for each successfully analyzed window . Contains NaN for windows where calculation failed . HIGH_CUTOFF_VECTOR - A row vector containing the upper frequency cutoff at half maximum for each successfully analyzed window . Contains NaN for windows where calculation failed . Requires : - NDI toolbox ( + ndi ) - vhlab - toolbox - matlab ( + vlt ), specifically vlt . signal . fwhm - NDIcalc - marder - matlab ( + mlt ), specifically mlt . spectrograph . readSpectrogramTimeWindow and this function ( mlt . inhibitoryBouts .. spectrogramInhibBoutAnalysis ) . - Associated helper functions like ` ndi . fun . data . readngrid ` ( if not standard )","title":"mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibBoutAnalysis.m/#mltinhibitoryboutsspectrograminhibboutanalysis","text":"MLT . inhibitoryBouts . SPECTROGRAMINHIBBOUTANALYSIS Analyze spectrogram FWHM around inhibition bout times . [ SPECDATA_MATRIX , F , FWHM_VECTOR , LOW_CUTOFF_VECTOR , HIGH_CUTOFF_VECTOR ] = ... mlt . inhibitoryBouts . spectrogramInhibBoutAnalysis ( E , INHIBBOUTTIMES , SKIP , TIMEWINDOW ) Analyzes the spectrogram associated with an ndi . element E around specified inhibition bout times . For each time provided in INHIBBOUTTIMES , it defines a time window starting at INHIBBOUTTIMES ( i ) + SKIP and lasting for TIMEWINDOW seconds . It calculates the time - averaged spectrogram within that window and computes its Full Width at Half Maximum ( FWHM ) . Inputs : E - An ndi . element object . The session is retrieved from e . session . The element should have associated 'spectrogram' documents . INHIBBOUTTIMES - A vector of Matlab datetime objects indicating the start times of inhibition bouts . SKIP - A double scalar indicating the time offset in seconds relative to each inhibBoutTime to start the analysis window . Can be positive or negative . TIMEWINDOW - A double scalar indicating the duration in seconds of the analysis window . Can be positive ( window goes forward from start ) or negative ( window goes backward from start ) . Outputs : SPECDATA_MATRIX - A matrix where each column is the time - averaged power spectrum ( column vector ) calculated for the window corresponding to each entry in INHIBBOUTTIMES . If analysis fails for a specific bout time , the corresponding column might be omitted or filled with NaNs depending on downstream processing needs ( currently , only successful results are concatenated ) . Returns [] if no successful analyses are performed . F - The frequency vector ( numeric column vector ) corresponding to the rows of SPECDATA_MATRIX . Assumes the frequency vector is consistent across all analyses . Returns [] if no successful analyses are performed . FWHM_VECTOR - A row vector containing the FWHM value for each successfully analyzed time window . Contains NaN for windows where calculation failed or was not possible . LOW_CUTOFF_VECTOR - A row vector containing the lower frequency cutoff at half maximum for each successfully analyzed window . Contains NaN for windows where calculation failed . HIGH_CUTOFF_VECTOR - A row vector containing the upper frequency cutoff at half maximum for each successfully analyzed window . Contains NaN for windows where calculation failed . Requires : - NDI toolbox ( + ndi ) - vhlab - toolbox - matlab ( + vlt ), specifically vlt . signal . fwhm - NDIcalc - marder - matlab ( + mlt ), specifically mlt . spectrograph . readSpectrogramTimeWindow and this function ( mlt . inhibitoryBouts .. spectrogramInhibBoutAnalysis ) . - Associated helper functions like ` ndi . fun . data . readngrid ` ( if not standard )","title":"mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibitoryBoutOnsetOffsetAnalysis.m/","text":"mlt.inhibitoryBouts.spectrogramInhibitoryBoutOnsetOffsetAnalysis \u00b6 MLT . SPECTROGRAMINHIBITORYBOUTONSETOFFSETANALYSIS Analyze spectrogram FWHM around inhibition bout onset / offset times . [ ONSETDATA , OFFSETDATA ] = mlt . spectrogramInhibitoryBoutOnsetOffsetAnalysis ( S , RECORD_NAME , ... REFERENCE , INHIBBOUTONSETS , INHIBBOUTOFFSETS , SKIP , TIMEWINDOW ) Analyzes the spectrogram associated with a specified PPG element ( 'ppg_heart_lp_whole' or 'ppg_pylorus_lp_whole' ) within session S . It focuses on time windows relative to inhibition bout onset and offset times . This function calls ` mlt . spectrogramInhibBoutAnalysis ` twice : 1. For Onsets : It analyzes windows calculated relative to INHIBBOUTONSETS . The window for onset ( i ) starts at onset ( i ) - SKIP - TIMEWINDOW and ends at onset ( i ) - SKIP . 2. For Offsets : It analyzes windows calculated relative to INHIBBOUTOFFSETS . The window for offset ( i ) starts at offset ( i ) + SKIP and ends at offset ( i ) + SKIP + TIMEWINDOW . It returns the aggregated results for the onset and offset analyses in separate structures . Inputs : S - An ndi . session or ndi . dataset object . RECORD_NAME - Character vector or string : 'heart' or 'pylorus' . REFERENCE - Positive integer scalar : The reference number of the element . INHIBBOUTONSETS - Column vector of Matlab datetime objects indicating inhibition bout onset times . INHIBBOUTOFFSETS - Column vector of Matlab datetime objects indicating inhibition bout offset times . Must be the same size as INHIBBOUTONSETS . SKIP - Non - negative double scalar : Time offset in seconds used to define the near edge of the analysis window relative to onset / offset . Allows 0. TIMEWINDOW - Positive double scalar : Duration in seconds of the analysis window . Outputs : ONSETDATA - Structure containing results from analyzing windows before onsets : . specData_matrix - Matrix of time - averaged spectra ( freq x bouts ) . . f - Frequency vector ( column ) . . fwhm_vector - Row vector of FWHM values ( NaN if failed ) . . low_cutoff_vector - Row vector of low cutoffs ( NaN if failed ) . . high_cutoff_vector - Row vector of high cutoffs ( NaN if failed ) . OFFSETDATA - Structure containing results from analyzing windows after offsets : . specData_matrix - Matrix of time - averaged spectra ( freq x bouts ) . . f - Frequency vector ( column ) . . fwhm_vector - Row vector of FWHM values ( NaN if failed ) . . low_cutoff_vector - Row vector of low cutoffs ( NaN if failed ) . . high_cutoff_vector - Row vector of high cutoffs ( NaN if failed ) . Returns empty structures with NaN vectors if the specified element is not found or analysis fails . Requires : - NDI toolbox ( + ndi ) - vhlab - toolbox - matlab ( + vlt ), specifically vlt . signal . fwhm ( used by mlt . spectrogramFWHM ) - NDIcalc - marder - matlab ( + mlt ), specifically mlt . spectrogramFWHM , mlt . readSpectrogramTimeWindow , and this function ( mlt . spectrogramInhibitoryBoutOnsetOffsetAnalysis ) . - Associated helper functions like ` ndi . fun . data . readngrid ` ( if not standard )","title":"mlt.inhibitoryBouts.spectrogramInhibitoryBoutOnsetOffsetAnalysis"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibitoryBoutOnsetOffsetAnalysis.m/#mltinhibitoryboutsspectrograminhibitoryboutonsetoffsetanalysis","text":"MLT . SPECTROGRAMINHIBITORYBOUTONSETOFFSETANALYSIS Analyze spectrogram FWHM around inhibition bout onset / offset times . [ ONSETDATA , OFFSETDATA ] = mlt . spectrogramInhibitoryBoutOnsetOffsetAnalysis ( S , RECORD_NAME , ... REFERENCE , INHIBBOUTONSETS , INHIBBOUTOFFSETS , SKIP , TIMEWINDOW ) Analyzes the spectrogram associated with a specified PPG element ( 'ppg_heart_lp_whole' or 'ppg_pylorus_lp_whole' ) within session S . It focuses on time windows relative to inhibition bout onset and offset times . This function calls ` mlt . spectrogramInhibBoutAnalysis ` twice : 1. For Onsets : It analyzes windows calculated relative to INHIBBOUTONSETS . The window for onset ( i ) starts at onset ( i ) - SKIP - TIMEWINDOW and ends at onset ( i ) - SKIP . 2. For Offsets : It analyzes windows calculated relative to INHIBBOUTOFFSETS . The window for offset ( i ) starts at offset ( i ) + SKIP and ends at offset ( i ) + SKIP + TIMEWINDOW . It returns the aggregated results for the onset and offset analyses in separate structures . Inputs : S - An ndi . session or ndi . dataset object . RECORD_NAME - Character vector or string : 'heart' or 'pylorus' . REFERENCE - Positive integer scalar : The reference number of the element . INHIBBOUTONSETS - Column vector of Matlab datetime objects indicating inhibition bout onset times . INHIBBOUTOFFSETS - Column vector of Matlab datetime objects indicating inhibition bout offset times . Must be the same size as INHIBBOUTONSETS . SKIP - Non - negative double scalar : Time offset in seconds used to define the near edge of the analysis window relative to onset / offset . Allows 0. TIMEWINDOW - Positive double scalar : Duration in seconds of the analysis window . Outputs : ONSETDATA - Structure containing results from analyzing windows before onsets : . specData_matrix - Matrix of time - averaged spectra ( freq x bouts ) . . f - Frequency vector ( column ) . . fwhm_vector - Row vector of FWHM values ( NaN if failed ) . . low_cutoff_vector - Row vector of low cutoffs ( NaN if failed ) . . high_cutoff_vector - Row vector of high cutoffs ( NaN if failed ) . OFFSETDATA - Structure containing results from analyzing windows after offsets : . specData_matrix - Matrix of time - averaged spectra ( freq x bouts ) . . f - Frequency vector ( column ) . . fwhm_vector - Row vector of FWHM values ( NaN if failed ) . . low_cutoff_vector - Row vector of low cutoffs ( NaN if failed ) . . high_cutoff_vector - Row vector of high cutoffs ( NaN if failed ) . Returns empty structures with NaN vectors if the specified element is not found or analysis fails . Requires : - NDI toolbox ( + ndi ) - vhlab - toolbox - matlab ( + vlt ), specifically vlt . signal . fwhm ( used by mlt . spectrogramFWHM ) - NDIcalc - marder - matlab ( + mlt ), specifically mlt . spectrogramFWHM , mlt . readSpectrogramTimeWindow , and this function ( mlt . spectrogramInhibitoryBoutOnsetOffsetAnalysis ) . - Associated helper functions like ` ndi . fun . data . readngrid ` ( if not standard )","title":"mlt.inhibitoryBouts.spectrogramInhibitoryBoutOnsetOffsetAnalysis"},{"location":"reference/%2Bmlt/%2Bjacquerie/kathleenTime1.m/","text":"mlt.jacquerie.kathleenTime1 \u00b6 kathleenTime1 defines datetime intervals and returns them in a structure. The structure array contains the interval and a temperature field . Syntax : timeData = kathleenTime1 () timeData = kathleenTime1 ( intervalWidthSeconds ) Description : timeData = kathleenTime1 () returns datetime intervals with a default width of 180 seconds ( 3 minutes ). timeData = kathleenTime1 ( intervalWidthSeconds ) returns datetime intervals with a specified width in seconds . Example : % Get time intervals for a 5-minute (300 second) window myData = kathleenTime1 ( 300 ); See also: kathleenTime2","title":"mlt.jacquerie.kathleenTime1"},{"location":"reference/%2Bmlt/%2Bjacquerie/kathleenTime1.m/#mltjacqueriekathleentime1","text":"kathleenTime1 defines datetime intervals and returns them in a structure. The structure array contains the interval and a temperature field . Syntax : timeData = kathleenTime1 () timeData = kathleenTime1 ( intervalWidthSeconds ) Description : timeData = kathleenTime1 () returns datetime intervals with a default width of 180 seconds ( 3 minutes ). timeData = kathleenTime1 ( intervalWidthSeconds ) returns datetime intervals with a specified width in seconds . Example : % Get time intervals for a 5-minute (300 second) window myData = kathleenTime1 ( 300 ); See also: kathleenTime2","title":"mlt.jacquerie.kathleenTime1"},{"location":"reference/%2Bmlt/%2Bjacquerie/kathleenTime2.m/","text":"mlt.jacquerie.kathleenTime2 \u00b6 kathleenTime2 defines datetime intervals and returns them in a structure. The structure array contains the interval and a temperature field . Syntax : timeData = kathleenTime2 () timeData = kathleenTime2 ( intervalWidthSeconds ) Description : timeData = kathleenTime2 () returns datetime intervals with a default width of 180 seconds ( 3 minutes ). timeData = kathleenTime2 ( intervalWidthSeconds ) returns datetime intervals with a specified width in seconds . Example : % Get time intervals for a 1-minute (60 second) window myData = kathleenTime2 ( 60 ); See also: kathleenTime1","title":"mlt.jacquerie.kathleenTime2"},{"location":"reference/%2Bmlt/%2Bjacquerie/kathleenTime2.m/#mltjacqueriekathleentime2","text":"kathleenTime2 defines datetime intervals and returns them in a structure. The structure array contains the interval and a temperature field . Syntax : timeData = kathleenTime2 () timeData = kathleenTime2 ( intervalWidthSeconds ) Description : timeData = kathleenTime2 () returns datetime intervals with a default width of 180 seconds ( 3 minutes ). timeData = kathleenTime2 ( intervalWidthSeconds ) returns datetime intervals with a specified width in seconds . Example : % Get time intervals for a 1-minute (60 second) window myData = kathleenTime2 ( 60 ); See also: kathleenTime1","title":"mlt.jacquerie.kathleenTime2"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure1.m/","text":"mlt.jacquerie.makeFigure1 \u00b6 makeFigure1 Generates a figure from session data. makeFigure1(dataPrefix) takes the directory path 'dataPrefix' where session data is stored and creates a figure.","title":"mlt.jacquerie.makeFigure1"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure1.m/#mltjacqueriemakefigure1","text":"makeFigure1 Generates a figure from session data. makeFigure1(dataPrefix) takes the directory path 'dataPrefix' where session data is stored and creates a figure.","title":"mlt.jacquerie.makeFigure1"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure2.m/","text":"mlt.jacquerie.makeFigure2 \u00b6 makeFigure1 Generates a figure from session data. makeFigure1(dataPrefix) takes the directory path 'dataPrefix' where session data is stored and creates a figure.","title":"mlt.jacquerie.makeFigure2"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure2.m/#mltjacqueriemakefigure2","text":"makeFigure1 Generates a figure from session data. makeFigure1(dataPrefix) takes the directory path 'dataPrefix' where session data is stored and creates a figure.","title":"mlt.jacquerie.makeFigure2"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure3.m/","text":"mlt.jacquerie.makeFigure3 \u00b6 makeFigure1 Generates a figure from session data. makeFigure1(dataPrefix) takes the directory path 'dataPrefix' where session data is stored and creates a figure.","title":"mlt.jacquerie.makeFigure3"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure3.m/#mltjacqueriemakefigure3","text":"makeFigure1 Generates a figure from session data. makeFigure1(dataPrefix) takes the directory path 'dataPrefix' where session data is stored and creates a figure.","title":"mlt.jacquerie.makeFigure3"},{"location":"reference/%2Bmlt/%2Bndi/getElement.m/","text":"mlt.ndi.getElement \u00b6 GETELEMENT Finds a unique NDI element based on subject and record type . ELEM = mlt . ndi . getElement ( S , subject_name , record_type , [ element_label ] ) Searches the NDI session S to find a single , unique ndi . element object that corresponds to the given subject and record type . It performs a database query to find element documents that match all criteria . This function will raise an error if zero or more than one element matches the search criteria . Inputs : S - An ndi . session or ndi . dataset object . subject_name - The name of the subject ( e . g ., 'SubjectA' ). record_type - The type of record ( 'heart' , 'gastric' , or 'pylorus' ). element_label - ( Optional ) A further label to identify the element . Defaults to 'lp_whole' . Outputs : elem - The single matching ndi . element object .","title":"mlt.ndi.getElement"},{"location":"reference/%2Bmlt/%2Bndi/getElement.m/#mltndigetelement","text":"GETELEMENT Finds a unique NDI element based on subject and record type . ELEM = mlt . ndi . getElement ( S , subject_name , record_type , [ element_label ] ) Searches the NDI session S to find a single , unique ndi . element object that corresponds to the given subject and record type . It performs a database query to find element documents that match all criteria . This function will raise an error if zero or more than one element matches the search criteria . Inputs : S - An ndi . session or ndi . dataset object . subject_name - The name of the subject ( e . g ., 'SubjectA' ). record_type - The type of record ( 'heart' , 'gastric' , or 'pylorus' ). element_label - ( Optional ) A further label to identify the element . Defaults to 'lp_whole' . Outputs : elem - The single matching ndi . element object .","title":"mlt.ndi.getElement"},{"location":"reference/%2Bmlt/%2Bplot/HMMStateDwellTimes.m/","text":"mlt.plot.HMMStateDwellTimes \u00b6 HMMSTATEDWELLTIMES Plots dwell time histograms for Hidden Markov Model (HMM) states. FIG_HANDLE = mlt . plot . HMMStateDwellTimes ( DwellStats ) Creates a figure with up to a 2 x2 subplot layout , showing the dwell time distribution for each HMM state on a logarithmic time axis . This function is designed to work directly with the output structure from the mlt . hmm . StateDwellTimes function . Inputs : DwellStats - A structure array output from mlt . hmm . StateDwellTimes . It must contain the fields \"state\" , \"histBinTimes\" , and \"histBinCount\" . Outputs : fig_handle - A handle to the created figure . Example : % First, run the HMM analysis pipeline and calculate dwell times [ states , timestamps ] = mlt . hmm . Analysis ( beat_times ); DwellStats = mlt . hmm . StateDwellTimes ( states , timestamps ); % Now, generate the plot with a single command fig_handle = mlt . plot . HMMStateDwellTimes ( DwellStats ); See also mlt.hmm.Analysis, mlt.hmm.StateDwellTimes","title":"mlt.plot.HMMStateDwellTimes"},{"location":"reference/%2Bmlt/%2Bplot/HMMStateDwellTimes.m/#mltplothmmstatedwelltimes","text":"HMMSTATEDWELLTIMES Plots dwell time histograms for Hidden Markov Model (HMM) states. FIG_HANDLE = mlt . plot . HMMStateDwellTimes ( DwellStats ) Creates a figure with up to a 2 x2 subplot layout , showing the dwell time distribution for each HMM state on a logarithmic time axis . This function is designed to work directly with the output structure from the mlt . hmm . StateDwellTimes function . Inputs : DwellStats - A structure array output from mlt . hmm . StateDwellTimes . It must contain the fields \"state\" , \"histBinTimes\" , and \"histBinCount\" . Outputs : fig_handle - A handle to the created figure . Example : % First, run the HMM analysis pipeline and calculate dwell times [ states , timestamps ] = mlt . hmm . Analysis ( beat_times ); DwellStats = mlt . hmm . StateDwellTimes ( states , timestamps ); % Now, generate the plot with a single command fig_handle = mlt . plot . HMMStateDwellTimes ( DwellStats ); See also mlt.hmm.Analysis, mlt.hmm.StateDwellTimes","title":"mlt.plot.HMMStateDwellTimes"},{"location":"reference/%2Bmlt/%2Bplot/HMMStates.m/","text":"mlt.plot.HMMStates \u00b6 HMMSTATES Plots HMM states and beat rates on a dual - y - axis plot . AX = mlt . plot . HMMStates ( states , timestamps , rates ) Creates a plot that visualizes the output of an HMM analysis . It plots the continuous beat rate signal on the left y - axis and the corresponding discrete HMM state sequence on the right y - axis . The y - axes are scaled relative to each other for intuitive comparison : - The value '1' on the right ( State ) axis aligns with '0' on the left ( Rate ) axis . - The highest state number on the right axis aligns with the maximum value of the plotted rate data on the left axis . Inputs : states - A vector of integer HMM state assignments . timestamps - A vector of time values ( numeric or datetime ) corresponding to the states and rates . rates - A vector of beat rates ( Hz ) corresponding to the timestamps . Optional Name - Value Pair Arguments : Linewidth ( 1 , 1 ) double = 1.5 Line width for both the rate and state plots . RateColor ( 1 , 3 ) double = [ 0 0.4470 0.7410 ] ( MATLAB blue ) Color for the beat rate plot . StateColor ( 1 , 3 ) double = [ 0.8500 0.3250 0.0980 ] ( MATLAB orange ) Color for the HMM state plot . Outputs : ax - A struct containing the handles to the two axes ( ax . RateAxis and ax . StateAxis ) . Example : % First , run the main analysis pipeline to get the required inputs L = load ( 'ppg_ppg_heart_lp_whole_1_beats.mat' ); beat_times = [ L . beats . onset ]; [ states , timestamps , rates , ~ ] = mlt . hmm . Analysis ( beat_times ); % Now , generate the specialized plot ax = mlt . plot . HMMStates ( states , timestamps , rates ); See also mlt . hmm . Analysis , yyaxis","title":"mlt.plot.HMMStates"},{"location":"reference/%2Bmlt/%2Bplot/HMMStates.m/#mltplothmmstates","text":"HMMSTATES Plots HMM states and beat rates on a dual - y - axis plot . AX = mlt . plot . HMMStates ( states , timestamps , rates ) Creates a plot that visualizes the output of an HMM analysis . It plots the continuous beat rate signal on the left y - axis and the corresponding discrete HMM state sequence on the right y - axis . The y - axes are scaled relative to each other for intuitive comparison : - The value '1' on the right ( State ) axis aligns with '0' on the left ( Rate ) axis . - The highest state number on the right axis aligns with the maximum value of the plotted rate data on the left axis . Inputs : states - A vector of integer HMM state assignments . timestamps - A vector of time values ( numeric or datetime ) corresponding to the states and rates . rates - A vector of beat rates ( Hz ) corresponding to the timestamps . Optional Name - Value Pair Arguments : Linewidth ( 1 , 1 ) double = 1.5 Line width for both the rate and state plots . RateColor ( 1 , 3 ) double = [ 0 0.4470 0.7410 ] ( MATLAB blue ) Color for the beat rate plot . StateColor ( 1 , 3 ) double = [ 0.8500 0.3250 0.0980 ] ( MATLAB orange ) Color for the HMM state plot . Outputs : ax - A struct containing the handles to the two axes ( ax . RateAxis and ax . StateAxis ) . Example : % First , run the main analysis pipeline to get the required inputs L = load ( 'ppg_ppg_heart_lp_whole_1_beats.mat' ); beat_times = [ L . beats . onset ]; [ states , timestamps , rates , ~ ] = mlt . hmm . Analysis ( beat_times ); % Now , generate the specialized plot ax = mlt . plot . HMMStates ( states , timestamps , rates ); See also mlt . hmm . Analysis , yyaxis","title":"mlt.plot.HMMStates"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeat.m/","text":"mlt.plot.HeartBeat \u00b6 HEARTBEAT - Plot PPG signal and derived heart beat data in a new figure . AX = mlt . plot . HeartBeat ( BEATS , D , T ) Plots heart beat statistics derived from a photoplethysmogram ( PPG ) . It generates a new figure with three stacked and linked subplots : 1 ) The PPG signal with beat onsets / offsets marked . 2 ) The instantaneous beat frequency over time . 3 ) The duty cycle of each beat over time . Inputs : beats - A structure array containing heartbeat information . Each element must have the following fields : . onset ( double | datetime ) Time of the heartbeat onset . . offset ( double | datetime ) Time of the heartbeat offset . . valid ( logical ) True if the beat is valid . . instant_freq ( double ) Instantaneous frequency ( Hz ) . . duty_cycle ( double ) Duty cycle of the heartbeat . d - A column vector of the PPG signal data . t - A column vector of time values for the PPG data . This can be numeric ( in seconds ) or a datetime vector . Note : If numeric , the x - axis of the plot will be converted to hours . Optional Name - Value Pairs : Linewidth ( 1 , 1 ) double = 1 Specifies the line width for the frequency and duty cycle plots . Outputs : ax - A 3 x1 vector of axes handles for the three subplots ( PPG , beat frequency , duty cycle ) . Example 1 : Basic usage with numeric time vector % Assuming 'beats' , 'd' , and 't' ( in seconds ) are defined : ax = mlt . plot . HeartBeat ( beats , d , t ); Example 2 : Specifying a custom linewidth ax = mlt . plot . HeartBeat ( beats , d , t , 'Linewidth' , 2 ); See also PLOT , SUBPLOT , LINKAXES .","title":"mlt.plot.HeartBeat"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeat.m/#mltplotheartbeat","text":"HEARTBEAT - Plot PPG signal and derived heart beat data in a new figure . AX = mlt . plot . HeartBeat ( BEATS , D , T ) Plots heart beat statistics derived from a photoplethysmogram ( PPG ) . It generates a new figure with three stacked and linked subplots : 1 ) The PPG signal with beat onsets / offsets marked . 2 ) The instantaneous beat frequency over time . 3 ) The duty cycle of each beat over time . Inputs : beats - A structure array containing heartbeat information . Each element must have the following fields : . onset ( double | datetime ) Time of the heartbeat onset . . offset ( double | datetime ) Time of the heartbeat offset . . valid ( logical ) True if the beat is valid . . instant_freq ( double ) Instantaneous frequency ( Hz ) . . duty_cycle ( double ) Duty cycle of the heartbeat . d - A column vector of the PPG signal data . t - A column vector of time values for the PPG data . This can be numeric ( in seconds ) or a datetime vector . Note : If numeric , the x - axis of the plot will be converted to hours . Optional Name - Value Pairs : Linewidth ( 1 , 1 ) double = 1 Specifies the line width for the frequency and duty cycle plots . Outputs : ax - A 3 x1 vector of axes handles for the three subplots ( PPG , beat frequency , duty cycle ) . Example 1 : Basic usage with numeric time vector % Assuming 'beats' , 'd' , and 't' ( in seconds ) are defined : ax = mlt . plot . HeartBeat ( beats , d , t ); Example 2 : Specifying a custom linewidth ax = mlt . plot . HeartBeat ( beats , d , t , 'Linewidth' , 2 ); See also PLOT , SUBPLOT , LINKAXES .","title":"mlt.plot.HeartBeat"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromDocs.m/","text":"mlt.plot.HeartBeatsFromDocs \u00b6 MLT . PLOT . HEARTBEATSFROMDOCS - Plots beat statistics overlaid on the raw PPG signal . AX = mlt . plot . HeartBeatsFromDocs ( S ) This function visualizes pre - calculated heart beat statistics for each subject and record type in an NDI session . It overlays the statistics on top of the ** raw , unnormalized ** PPG signal . It uses helper functions to find the relevant 'ppg_beats' documents and raw signal data . A separate figure is generated for each unique element found . Inputs : S - An ndi . session or ndi . dataset object containing the PPG data . Optional Name - Value Pairs : Linewidth ( 1 , 1 ) double = 1 ; The line width for the plotted lines . Outputs : AX - A column vector of axes handles from all generated plots . Example : ax = mlt . plot . HeartBeatsFromDocs ( mySession , 'Linewidth' , 1.5 ); See also mlt . plot . HeartBeat , mlt . doc . getHeartBeats , mlt . ppg . getRawData","title":"mlt.plot.HeartBeatsFromDocs"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromDocs.m/#mltplotheartbeatsfromdocs","text":"MLT . PLOT . HEARTBEATSFROMDOCS - Plots beat statistics overlaid on the raw PPG signal . AX = mlt . plot . HeartBeatsFromDocs ( S ) This function visualizes pre - calculated heart beat statistics for each subject and record type in an NDI session . It overlays the statistics on top of the ** raw , unnormalized ** PPG signal . It uses helper functions to find the relevant 'ppg_beats' documents and raw signal data . A separate figure is generated for each unique element found . Inputs : S - An ndi . session or ndi . dataset object containing the PPG data . Optional Name - Value Pairs : Linewidth ( 1 , 1 ) double = 1 ; The line width for the plotted lines . Outputs : AX - A column vector of axes handles from all generated plots . Example : ax = mlt . plot . HeartBeatsFromDocs ( mySession , 'Linewidth' , 1.5 ); See also mlt . plot . HeartBeat , mlt . doc . getHeartBeats , mlt . ppg . getRawData","title":"mlt.plot.HeartBeatsFromDocs"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromFiles.m/","text":"mlt.plot.HeartBeatsFromFiles \u00b6 HEARTBEATSFROMFILES - Plots beat statistics overlaid on the raw PPG signal . AX = mlt . plot . HeartBeatsFromFiles ( S ) This function visualizes pre - calculated heart beat statistics by overlaying them on top of the ** raw , unnormalized ** PPG signal . It loads data from pre - processed MAT - files found within the NDI session path . These files contain beat statistics ( e . g . , onset , frequency ) that were derived from a ** normalized ** version of the data ( using a rolling z - score ), as well as the original raw PPG signal for the plot background . The MAT - files are assumed to follow the naming convention : 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat' ... where AREA is the recording site ( e . g . , 'heart' , 'pylorus' ) and NUMBER is the element 's reference number. Inputs : S - An ndi . session or ndi . dataset object containing the PPG data . Optional Name - Value Pairs : Linewidth ( 1 , 1 ) double = 1 ; The line width for the plotted lines . Outputs : AX - A column vector of axes handles . Each set of 3 axes handles ( for the 3 subplots in a figure ) is concatenated vertically . Example 1 : Basic usage % Assuming 'mySession' is an ndi . session object ax = mlt . plot . HeartBeatsFromFiles ( mySession ); Example 2 : Specifying a custom line width ax = mlt . plot . HeartBeatsFromFiles ( mySession , 'Linewidth' , 2 ); See also mlt . plot . HeartBeat , ndi . session , ndi . dataset","title":"mlt.plot.HeartBeatsFromFiles"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromFiles.m/#mltplotheartbeatsfromfiles","text":"HEARTBEATSFROMFILES - Plots beat statistics overlaid on the raw PPG signal . AX = mlt . plot . HeartBeatsFromFiles ( S ) This function visualizes pre - calculated heart beat statistics by overlaying them on top of the ** raw , unnormalized ** PPG signal . It loads data from pre - processed MAT - files found within the NDI session path . These files contain beat statistics ( e . g . , onset , frequency ) that were derived from a ** normalized ** version of the data ( using a rolling z - score ), as well as the original raw PPG signal for the plot background . The MAT - files are assumed to follow the naming convention : 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat' ... where AREA is the recording site ( e . g . , 'heart' , 'pylorus' ) and NUMBER is the element 's reference number. Inputs : S - An ndi . session or ndi . dataset object containing the PPG data . Optional Name - Value Pairs : Linewidth ( 1 , 1 ) double = 1 ; The line width for the plotted lines . Outputs : AX - A column vector of axes handles . Each set of 3 axes handles ( for the 3 subplots in a figure ) is concatenated vertically . Example 1 : Basic usage % Assuming 'mySession' is an ndi . session object ax = mlt . plot . HeartBeatsFromFiles ( mySession ); Example 2 : Specifying a custom line width ax = mlt . plot . HeartBeatsFromFiles ( mySession , 'Linewidth' , 2 ); See also mlt . plot . HeartBeat , ndi . session , ndi . dataset","title":"mlt.plot.HeartBeatsFromFiles"},{"location":"reference/%2Bmlt/%2Bplot/Spectrogram.m/","text":"mlt.plot.Spectrogram \u00b6 MLT . PLOT . SPECTROGRAM Plots a spectrogram . mlt . plot . Spectrogram ( SPEC , F , TS , Name , Value , ... ) plots a spectrogram in the current axes . Plots the spectrogram , applying dB / linear conversions as specified . Plots time in hours if TS is in seconds , or uses datetime values directly . Input Arguments : SPEC : Spectrogram data ( matrix ) . F : Frequency vector . TS : Time vector ( double in seconds or datetime ) . Name / Value Pairs : convertDBtoLinear : Logical , convert dB to linear ( default true ) . convertLinearToDB : Logical , convert linear to dB ( default false ) . shading : Shading style ( 'faceted' , 'flat' , or 'interp' , default 'flat' ) . drawLabels : Logical , whether to draw axis labels ( default true ) . colorbar : Logical , whether to draw a colorbar ( default false ) . maxColorPercentile : The percentile of data to use as the maximum value for the color scale . ( default 99 ) . colormapName : Name of the colormap to use ( default 'parula' ) .","title":"mlt.plot.Spectrogram"},{"location":"reference/%2Bmlt/%2Bplot/Spectrogram.m/#mltplotspectrogram","text":"MLT . PLOT . SPECTROGRAM Plots a spectrogram . mlt . plot . Spectrogram ( SPEC , F , TS , Name , Value , ... ) plots a spectrogram in the current axes . Plots the spectrogram , applying dB / linear conversions as specified . Plots time in hours if TS is in seconds , or uses datetime values directly . Input Arguments : SPEC : Spectrogram data ( matrix ) . F : Frequency vector . TS : Time vector ( double in seconds or datetime ) . Name / Value Pairs : convertDBtoLinear : Logical , convert dB to linear ( default true ) . convertLinearToDB : Logical , convert linear to dB ( default false ) . shading : Shading style ( 'faceted' , 'flat' , or 'interp' , default 'flat' ) . drawLabels : Logical , whether to draw axis labels ( default true ) . colorbar : Logical , whether to draw a colorbar ( default false ) . maxColorPercentile : The percentile of data to use as the maximum value for the color scale . ( default 99 ) . colormapName : Name of the colormap to use ( default 'parula' ) .","title":"mlt.plot.Spectrogram"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsBeatsOverlayFromFiles.m/","text":"mlt.plot.SpectrogramsBeatsOverlayFromFiles \u00b6 MLT . PLOT . SPECTROGRAMSBEATSOVERLAYFROMFILES - Plots spectrograms with a heart beat frequency overlay . AX = mlt . plot . SpectrogramsBeatsOverlayFromFiles ( S ) This function visualizes the relationship between instantaneous heart beat frequency and the spectral content of a PPG signal . For each PPG probe in the NDI session , it plots a spectrogram and overlays the beat frequency trace on top . The function loads data from two separate , pre - calculated MAT - files for each probe . It searches for these files in the NDI session 's path using the following naming conventions : 1. Spectrogram File : 'ppg_ppg_AREA_lp_whole_NUMBER.mat' ( Must contain 'spec' , 'f' , and 'ts' variables ) 2. Beats File : 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat' ( Must contain a 'beats' struct ) Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the spectrogram data to use as the maximum value for the color scale ( 0 - 100 ) . colormapName ( 1 ,:) char = 'parula' The name of the colormap to use ( e . g . , 'jet' , 'hot' ) . numSubplots ( 1 , 1 ) double = 10 The number of vertical subplots to prepare in the figure . Outputs : ax - A column vector of axes handles for the generated subplots . Example : % Assuming 'mySession' is an ndi . session object ax = mlt . plot . SpectrogramsBeatsOverlayFromFiles ( mySession ); See also mlt . plot . Spectrogram , mlt . plot . HeartBeatFromFiles","title":"mlt.plot.SpectrogramsBeatsOverlayFromFiles"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsBeatsOverlayFromFiles.m/#mltplotspectrogramsbeatsoverlayfromfiles","text":"MLT . PLOT . SPECTROGRAMSBEATSOVERLAYFROMFILES - Plots spectrograms with a heart beat frequency overlay . AX = mlt . plot . SpectrogramsBeatsOverlayFromFiles ( S ) This function visualizes the relationship between instantaneous heart beat frequency and the spectral content of a PPG signal . For each PPG probe in the NDI session , it plots a spectrogram and overlays the beat frequency trace on top . The function loads data from two separate , pre - calculated MAT - files for each probe . It searches for these files in the NDI session 's path using the following naming conventions : 1. Spectrogram File : 'ppg_ppg_AREA_lp_whole_NUMBER.mat' ( Must contain 'spec' , 'f' , and 'ts' variables ) 2. Beats File : 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat' ( Must contain a 'beats' struct ) Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the spectrogram data to use as the maximum value for the color scale ( 0 - 100 ) . colormapName ( 1 ,:) char = 'parula' The name of the colormap to use ( e . g . , 'jet' , 'hot' ) . numSubplots ( 1 , 1 ) double = 10 The number of vertical subplots to prepare in the figure . Outputs : ax - A column vector of axes handles for the generated subplots . Example : % Assuming 'mySession' is an ndi . session object ax = mlt . plot . SpectrogramsBeatsOverlayFromFiles ( mySession ); See also mlt . plot . Spectrogram , mlt . plot . HeartBeatFromFiles","title":"mlt.plot.SpectrogramsBeatsOverlayFromFiles"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromDocs.m/","text":"mlt.plot.SpectrogramsFromDocs \u00b6 SPECTROGRAMSFROMDOCS - Plot spectrograms from NDI document data for each subject . AX = mlt . plot . SpectrogramsFromDocs ( S , ... ) Plots all available spectrograms from all subjects and record types ( 'heart' , 'pylorus' , 'gastric' ) into a single figure with multiple subplots . The function first loops through all subjects and record types to find all available spectrograms and determine the total number of subplots needed . It then creates a single figure and plots each spectrogram in a separate subplot . Finally , it links the axes of all subplots . Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the data to use as the maximum value for the color scale , clipping extreme values . Must be between 0 and 100. colormapName ( 1 ,:) char = 'parula' The name of the colormap to use ( e . g ., 'jet' , 'hot' , 'gray' ). Outputs : ax - A column vector of all created axes handles . Example : % Plot all spectrograms with a colorbar and a 'hot' colormap ax = mlt . plot . SpectrogramsFromDocs ( mySession , 'colorbar' , true , 'colormapName' , 'hot' ); See also: mlt.plot.Spectrogram, mlt.doc.getSpectrogramData, mlt.ndi.getElement","title":"mlt.plot.SpectrogramsFromDocs"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromDocs.m/#mltplotspectrogramsfromdocs","text":"SPECTROGRAMSFROMDOCS - Plot spectrograms from NDI document data for each subject . AX = mlt . plot . SpectrogramsFromDocs ( S , ... ) Plots all available spectrograms from all subjects and record types ( 'heart' , 'pylorus' , 'gastric' ) into a single figure with multiple subplots . The function first loops through all subjects and record types to find all available spectrograms and determine the total number of subplots needed . It then creates a single figure and plots each spectrogram in a separate subplot . Finally , it links the axes of all subplots . Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the data to use as the maximum value for the color scale , clipping extreme values . Must be between 0 and 100. colormapName ( 1 ,:) char = 'parula' The name of the colormap to use ( e . g ., 'jet' , 'hot' , 'gray' ). Outputs : ax - A column vector of all created axes handles . Example : % Plot all spectrograms with a colorbar and a 'hot' colormap ax = mlt . plot . SpectrogramsFromDocs ( mySession , 'colorbar' , true , 'colormapName' , 'hot' ); See also: mlt.plot.Spectrogram, mlt.doc.getSpectrogramData, mlt.ndi.getElement","title":"mlt.plot.SpectrogramsFromDocs"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromFiles.m/","text":"mlt.plot.SpectrogramsFromFiles \u00b6 SPECTROGRAMSFROMFILES - Plot spectrograms for PPG elements from pre - calculated files . AX = mlt . plot . SpectrogramsFromFiles ( S ) Plots spectrograms for all 'ppg' probes found within an ndi . session or ndi . dataset object S . The spectrograms for all probes are plotted as subplots within a single figure . This function searches the NDI session 's path for pre-calculated MAT-files that contain spectrogram data . These files are assumed to be named according to the convention : 'ppg_ppg_AREA_lp_whole_NUMBER.mat' ... where AREA is the recording site ( e . g . , 'heart' , 'pylorus' ) and NUMBER is the element 's reference number. Each file must contain the variables : 'spec' ( the spectrogram data ), 'f' ( frequency vector ), and 'ts' ( time vector ) . Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the data to use as the maximum value for the color scale , clipping extreme values . Must be between 0 and 100. colormapName ( 1 ,:) char = 'parula' The name of the colormap to use ( e . g . , 'jet' , 'hot' , 'gray' ) . numSubplots ( 1 , 1 ) double = 10 The number of vertical subplots to prepare in the figure . Outputs : ax - A column vector of axes handles for the generated subplots . Example 1 : Basic usage % Assuming 'mySession' is an ndi . session object ax = mlt . plot . SpectrogramsFromFiles ( mySession ); Example 2 : Plot with color bars and a different colormap ax = mlt . plot . SpectrogramsFromFiles ( mySession , 'colorbar' , true , 'colormapName' , 'hot' ); See also mlt . plot . gracePlotSpectrogram , imagesc , colormap","title":"mlt.plot.SpectrogramsFromFiles"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromFiles.m/#mltplotspectrogramsfromfiles","text":"SPECTROGRAMSFROMFILES - Plot spectrograms for PPG elements from pre - calculated files . AX = mlt . plot . SpectrogramsFromFiles ( S ) Plots spectrograms for all 'ppg' probes found within an ndi . session or ndi . dataset object S . The spectrograms for all probes are plotted as subplots within a single figure . This function searches the NDI session 's path for pre-calculated MAT-files that contain spectrogram data . These files are assumed to be named according to the convention : 'ppg_ppg_AREA_lp_whole_NUMBER.mat' ... where AREA is the recording site ( e . g . , 'heart' , 'pylorus' ) and NUMBER is the element 's reference number. Each file must contain the variables : 'spec' ( the spectrogram data ), 'f' ( frequency vector ), and 'ts' ( time vector ) . Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the data to use as the maximum value for the color scale , clipping extreme values . Must be between 0 and 100. colormapName ( 1 ,:) char = 'parula' The name of the colormap to use ( e . g . , 'jet' , 'hot' , 'gray' ) . numSubplots ( 1 , 1 ) double = 10 The number of vertical subplots to prepare in the figure . Outputs : ax - A column vector of axes handles for the generated subplots . Example 1 : Basic usage % Assuming 'mySession' is an ndi . session object ax = mlt . plot . SpectrogramsFromFiles ( mySession ); Example 2 : Plot with color bars and a different colormap ax = mlt . plot . SpectrogramsFromFiles ( mySession , 'colorbar' , true , 'colormapName' , 'hot' ); See also mlt . plot . gracePlotSpectrogram , imagesc , colormap","title":"mlt.plot.SpectrogramsFromFiles"},{"location":"reference/%2Bmlt/%2Bplot/Traces.m/","text":"mlt.plot.Traces \u00b6 MLT . PLOT . TRACES - Plot heart beat and spectrogram data traces for specific time intervals . MLT . PLOT . TRACES ( DATA , TIME_INTERVALS , Name , Value ) Plots spectrogram , raw data , instantaneous firing rate , and amplitude for specified time intervals . The function searches through an array of data structures to find the appropriate record that contains the requested time interval . The upper 40 % of the window is the spectrogram . The lower 60 % of the window has several axes with line plots : - Raw data ( from mlt . ppg . getRawData ) - Instantaneous firing rate ( from heart beats data ) - Amplitude ( from heart beats data ) - A blank plot for temperature ( for future use ) Inputs : DATA - An array of data structures returned by mlt . doc . getHeartBeatAndSpectrogram . TIME_INTERVALS - An Nx2 matrix of datetime objects , where each row represents a [ t0 , t1 ] interval to be plotted . Name - Value Pairs : 'TitleInterpreter' - The interpreter for the plot titles ( 'none' , 'tex' , 'latex' ) . Default is 'none' . 'timePrePostWindow' - The time in seconds to extend the data window before and after the specified interval . Default is 180 seconds .","title":"mlt.plot.Traces"},{"location":"reference/%2Bmlt/%2Bplot/Traces.m/#mltplottraces","text":"MLT . PLOT . TRACES - Plot heart beat and spectrogram data traces for specific time intervals . MLT . PLOT . TRACES ( DATA , TIME_INTERVALS , Name , Value ) Plots spectrogram , raw data , instantaneous firing rate , and amplitude for specified time intervals . The function searches through an array of data structures to find the appropriate record that contains the requested time interval . The upper 40 % of the window is the spectrogram . The lower 60 % of the window has several axes with line plots : - Raw data ( from mlt . ppg . getRawData ) - Instantaneous firing rate ( from heart beats data ) - Amplitude ( from heart beats data ) - A blank plot for temperature ( for future use ) Inputs : DATA - An array of data structures returned by mlt . doc . getHeartBeatAndSpectrogram . TIME_INTERVALS - An Nx2 matrix of datetime objects , where each row represents a [ t0 , t1 ] interval to be plotted . Name - Value Pairs : 'TitleInterpreter' - The interpreter for the plot titles ( 'none' , 'tex' , 'latex' ) . Default is 'none' . 'timePrePostWindow' - The time in seconds to extend the data window before and after the specified interval . Default is 180 seconds .","title":"mlt.plot.Traces"},{"location":"reference/%2Bmlt/%2Bplot/gracePlotAll.m/","text":"mlt.plot.gracePlotAll \u00b6 GRACEPLOTALL - Plot all summary data for an NDI session / dataset . mlt . plot . gracePlotAll ( S ) Generates a comprehensive set of plots summarizing photoplethysmogram ( PPG ) data from an ndi . session or ndi . dataset object S . It creates three separate figures : 1 . Spectrograms of the PPG data . 2 . Heartbeat statistics plots ( raw PPG , frequency , duty cycle ). 3 . Spectrograms with overlaid heartbeat frequency . Inputs : S - An ndi . session or ndi . dataset object . Optional Name-Value Pairs : colorbar ( 1 , 1 ) logical = false Whether to display colorbars for the spectrogram plots . colormapName ( 1 ,:) char = 'parula' The colormap to use for the spectrogram plots . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of spectrogram data to use as the maximum value for the color scale ( for contrast enhancement ). Linewidth ( 1 , 1 ) double = 1 The line width for the heartbeat statistics plots . Details : This function calls three other functions to generate the plots : 1 . mlt . plot . SpectrogramsFromFiles 2 . mlt . plot . HeartBeatsFromFiles 3 . mlt . plot . SpectrogramBeatsOverlayFromFiles The function then links the x-axes across all generated figures , ensuring that zooming and panning are synchronized . Example 1 : Basic Usage mlt . plot . gracePlotAll ( mySession ); Example 2 : Name-value pair inputs mlt . plot . gracePlotAll ( mySession , 'colorbar' , true , ... 'colormapName' , 'hot' , 'Linewidth' , 1 . 5 ); See also mlt . plot . SpectrogramsFromFiles , mlt . plot . HeartBeatsFromFiles , mlt . plot . SpectrogramBeatsOverlayFromFiles , linkaxes","title":"mlt.plot.gracePlotAll"},{"location":"reference/%2Bmlt/%2Bplot/gracePlotAll.m/#mltplotgraceplotall","text":"GRACEPLOTALL - Plot all summary data for an NDI session / dataset . mlt . plot . gracePlotAll ( S ) Generates a comprehensive set of plots summarizing photoplethysmogram ( PPG ) data from an ndi . session or ndi . dataset object S . It creates three separate figures : 1 . Spectrograms of the PPG data . 2 . Heartbeat statistics plots ( raw PPG , frequency , duty cycle ). 3 . Spectrograms with overlaid heartbeat frequency . Inputs : S - An ndi . session or ndi . dataset object . Optional Name-Value Pairs : colorbar ( 1 , 1 ) logical = false Whether to display colorbars for the spectrogram plots . colormapName ( 1 ,:) char = 'parula' The colormap to use for the spectrogram plots . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of spectrogram data to use as the maximum value for the color scale ( for contrast enhancement ). Linewidth ( 1 , 1 ) double = 1 The line width for the heartbeat statistics plots . Details : This function calls three other functions to generate the plots : 1 . mlt . plot . SpectrogramsFromFiles 2 . mlt . plot . HeartBeatsFromFiles 3 . mlt . plot . SpectrogramBeatsOverlayFromFiles The function then links the x-axes across all generated figures , ensuring that zooming and panning are synchronized . Example 1 : Basic Usage mlt . plot . gracePlotAll ( mySession ); Example 2 : Name-value pair inputs mlt . plot . gracePlotAll ( mySession , 'colorbar' , true , ... 'colormapName' , 'hot' , 'Linewidth' , 1 . 5 ); See also mlt . plot . SpectrogramsFromFiles , mlt . plot . HeartBeatsFromFiles , mlt . plot . SpectrogramBeatsOverlayFromFiles , linkaxes","title":"mlt.plot.gracePlotAll"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutONOFF.m/","text":"mlt.plot.plotInhibitoryBoutONOFF \u00b6 MLT . PLOT . PLOTINHIBITORYBOUTONOFF Plots binned beat rates with bout events . ax = mlt . plotInhibitoryBoutONOFF ( bouts ) creates a plot of the binned beat rate over time and overlays vertical lines indicating the onset ( RED ) and offset ( BLUE ) of inhibitory bouts . The function uses the binned rate data stored within the 'bouts' structure , which should be generated by mlt . inhibitoryBouts . findInhibitoryBouts . SYNTAX : ax = mlt . plot . plotInhibitoryBoutONOFF ( bouts ) INPUTS : bouts - The output structure from mlt . inhibitoryBouts . findInhibitoryBouts . It must contain the fields : . beatRate . beatRateTimes . inhibitoryBoutOnset . inhibitoryBoutOffset OUTPUTS : ax - The handle to the axes of the generated plot . EXAMPLE : % 1. Create synthetic beat data beat_times = [ ( 0 : 0.4 : 10 ), ( 10.5 : 1 : 20 ), ( 20.4 : 0.4 : 30 ) ] ' ; % 2. Find the inhibitory bouts (which now includes rate data) bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ); % 3. Plot the results directly from the bouts structure figure ; ax = mlt . plot . plotInhibitoryBoutONOFF ( bouts ); title ( 'Inhibitory Bout Detection' );","title":"mlt.plot.plotInhibitoryBoutONOFF"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutONOFF.m/#mltplotplotinhibitoryboutonoff","text":"MLT . PLOT . PLOTINHIBITORYBOUTONOFF Plots binned beat rates with bout events . ax = mlt . plotInhibitoryBoutONOFF ( bouts ) creates a plot of the binned beat rate over time and overlays vertical lines indicating the onset ( RED ) and offset ( BLUE ) of inhibitory bouts . The function uses the binned rate data stored within the 'bouts' structure , which should be generated by mlt . inhibitoryBouts . findInhibitoryBouts . SYNTAX : ax = mlt . plot . plotInhibitoryBoutONOFF ( bouts ) INPUTS : bouts - The output structure from mlt . inhibitoryBouts . findInhibitoryBouts . It must contain the fields : . beatRate . beatRateTimes . inhibitoryBoutOnset . inhibitoryBoutOffset OUTPUTS : ax - The handle to the axes of the generated plot . EXAMPLE : % 1. Create synthetic beat data beat_times = [ ( 0 : 0.4 : 10 ), ( 10.5 : 1 : 20 ), ( 20.4 : 0.4 : 30 ) ] ' ; % 2. Find the inhibitory bouts (which now includes rate data) bouts = mlt . inhibitoryBouts . findInhibitoryBouts ( beat_times ); % 3. Plot the results directly from the bouts structure figure ; ax = mlt . plot . plotInhibitoryBoutONOFF ( bouts ); title ( 'Inhibitory Bout Detection' );","title":"mlt.plot.plotInhibitoryBoutONOFF"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutOnsetOffset.m/","text":"mlt.plot.plotInhibitoryBoutOnsetOffset \u00b6 MLT . PLOT . PLOTINHIBITORYBOUTONSETOFFSET Plot spectrogram analysis results around onset / offset . AX = mlt . plot . plotInhibitoryBoutOnsetOffset ( ONSETDATA , OFFSETDATA , Name , Value , ... ) Creates a 3 - panel figure summarizing the spectrogram analysis results obtained from ` mlt . spectrogram . spectrogramInhibitoryBoutOnsetOffsetAnalysis ` . Inputs : ONSETDATA - Structure containing results from analyzing windows before onsets : . specData_matrix - Matrix of time - averaged spectra ( freq x bouts ) . . f - Frequency vector ( column ) . . fwhm_vector - Row vector of FWHM values . . low_cutoff_vector - Row vector of low cutoffs . . high_cutoff_vector - Row vector of high cutoffs . OFFSETDATA - Structure containing results from analyzing windows after offsets ( same fields as ONSETDATA ) . Optional Name / Value Pair Arguments : CapSize - ( Default : 15 ) Numeric scalar specifying the size of the error bar caps in points for the FWHM plot . Outputs : AX - A 3 x1 vector of axes handles for the three subplots created . Figure Panels : 1. Top Panel : Plots the absolute value of individual time - averaged spectra ( gray lines ) and the mean absolute spectrum ( black line ) for the OnsetData vs . frequency . Title : 'Prior to onset' . Y - axis : 'Power' . X - axis : 'Frequency (Hz)' . 2. Middle Panel : Plots the absolute value of individual time - averaged spectra ( gray lines ) and the mean absolute spectrum ( black line ) for the OffsetData vs . frequency . Title : 'After offset' . Y - axis : 'Power' . X - axis : 'Frequency (Hz)' . 3. Bottom Panel : Bar graph comparing a modified FWHM measure ( high_cutoff - max ( 0 , low_cutoff )) between OnsetData and OffsetData . Individual data points are overlaid with jitter . Error bars show SEM ( plotted thicker , brought to front , cap size adjustable ) . Title displays the p - value from a paired t - test between the groups . Y - axis : 'FWHM (Hz)' . X - axis labels : 'Onset' , 'Offset' . Requires : - NDI toolbox ( + ndi ) - vhlab - toolbox - matlab ( + vlt ), specifically vlt . signal . fwhm ( used by mlt . spectrogram . spectrogramFWHM ) - NDIcalc - marder - matlab ( + mlt ), specifically mlt . spectrogram . spectrogramFWHM , mlt . spectrogram . readSpectrogramTimeWindow , and this function ( mlt . plot . plotInhibitoryBoutOnsetOffset ) . - Associated helper functions like ` ndi . fun . data . readngrid ` ( if not standard )","title":"mlt.plot.plotInhibitoryBoutOnsetOffset"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutOnsetOffset.m/#mltplotplotinhibitoryboutonsetoffset","text":"MLT . PLOT . PLOTINHIBITORYBOUTONSETOFFSET Plot spectrogram analysis results around onset / offset . AX = mlt . plot . plotInhibitoryBoutOnsetOffset ( ONSETDATA , OFFSETDATA , Name , Value , ... ) Creates a 3 - panel figure summarizing the spectrogram analysis results obtained from ` mlt . spectrogram . spectrogramInhibitoryBoutOnsetOffsetAnalysis ` . Inputs : ONSETDATA - Structure containing results from analyzing windows before onsets : . specData_matrix - Matrix of time - averaged spectra ( freq x bouts ) . . f - Frequency vector ( column ) . . fwhm_vector - Row vector of FWHM values . . low_cutoff_vector - Row vector of low cutoffs . . high_cutoff_vector - Row vector of high cutoffs . OFFSETDATA - Structure containing results from analyzing windows after offsets ( same fields as ONSETDATA ) . Optional Name / Value Pair Arguments : CapSize - ( Default : 15 ) Numeric scalar specifying the size of the error bar caps in points for the FWHM plot . Outputs : AX - A 3 x1 vector of axes handles for the three subplots created . Figure Panels : 1. Top Panel : Plots the absolute value of individual time - averaged spectra ( gray lines ) and the mean absolute spectrum ( black line ) for the OnsetData vs . frequency . Title : 'Prior to onset' . Y - axis : 'Power' . X - axis : 'Frequency (Hz)' . 2. Middle Panel : Plots the absolute value of individual time - averaged spectra ( gray lines ) and the mean absolute spectrum ( black line ) for the OffsetData vs . frequency . Title : 'After offset' . Y - axis : 'Power' . X - axis : 'Frequency (Hz)' . 3. Bottom Panel : Bar graph comparing a modified FWHM measure ( high_cutoff - max ( 0 , low_cutoff )) between OnsetData and OffsetData . Individual data points are overlaid with jitter . Error bars show SEM ( plotted thicker , brought to front , cap size adjustable ) . Title displays the p - value from a paired t - test between the groups . Y - axis : 'FWHM (Hz)' . X - axis labels : 'Onset' , 'Offset' . Requires : - NDI toolbox ( + ndi ) - vhlab - toolbox - matlab ( + vlt ), specifically vlt . signal . fwhm ( used by mlt . spectrogram . spectrogramFWHM ) - NDIcalc - marder - matlab ( + mlt ), specifically mlt . spectrogram . spectrogramFWHM , mlt . spectrogram . readSpectrogramTimeWindow , and this function ( mlt . plot . plotInhibitoryBoutOnsetOffset ) . - Associated helper functions like ` ndi . fun . data . readngrid ` ( if not standard )","title":"mlt.plot.plotInhibitoryBoutOnsetOffset"},{"location":"reference/%2Bmlt/%2Bplot/subjectTrace.m/","text":"mlt.plot.subjectTrace \u00b6 SUBJECTTRACE Plots a detailed summary trace for a single subject and record . [ AX , DATA ] = mlt . plot . subjectTrace ( S , subject_name , record_type , ... ) Generates a comprehensive multi - panel plot for a single recording from a specific subject . It loads the raw data , pre - calculated spectrogram , and heart beat data and visualizes them together . The layout consists of : - Panel 1 ( Top , 25 % ): Spectrogram . - Panel 2 : Raw data trace . - Panel 3 : Normalized ( z - scored ) data trace . - Panels 4 - 6 : Beat instantaneous frequency , amplitude , and duty cycle . All plot axes are linked horizontally for synchronized zooming and panning . Inputs : S - An ndi . session or ndi . dataset object . subject_name - The name of the subject ( e . g . , 'SubjectA' ) . record_type - The type of record ( 'heart' , 'gastric' , or 'pylorus' ) . Optional Name - Value Pair Arguments : data ( 1 , 1 ) struct = struct () A pre - fetched data structure from mlt . doc . getHeartBeatAndSpectrogram . If provided , the function will not re - load the data . zscoreWindowTime ( 1 , 1 ) double = 3600 The time window in seconds for the moving z - score calculation on the raw data . showBeats ( 1 , 1 ) logical = false If true , overlays beat onset ( blue circles ) and offset ( red 'x' ) markers on the raw and normalized data plots . markBeats ( 1 , 1 ) logical = false If true , displays buttons to interactively mark bad and missing beats . Instructions : - Bad : Click near detected beats to mark them as bad ( gray 'X' ) . - Missing : Click to add new , missing beats ( green '+' ) . - Save : Saves the curated beat list to a . mat file . A dialog will appear with instructions . Press Enter after you are done clicking . Linewidth ( 1 , 1 ) double = 1.5 Line width for the time - series plots . colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the data to use for the color scale maximum . colormapName ( 1 ,:) char = 'parula' The name of the colormap to use . Outputs : ax - A struct containing the handles to the subplot axes . data - The data structure ( either passed in or loaded ) . Example : % Interactively mark beats [ ax , data ] = mlt . plot . subjectTrace ( mySession , 'SubjectA' , 'heart' , 'markBeats' , true ); See also mlt . doc . getHeartBeatAndSpectrogram , mlt . ppg . getRawData , mlt . util . movzscore","title":"mlt.plot.subjectTrace"},{"location":"reference/%2Bmlt/%2Bplot/subjectTrace.m/#mltplotsubjecttrace","text":"SUBJECTTRACE Plots a detailed summary trace for a single subject and record . [ AX , DATA ] = mlt . plot . subjectTrace ( S , subject_name , record_type , ... ) Generates a comprehensive multi - panel plot for a single recording from a specific subject . It loads the raw data , pre - calculated spectrogram , and heart beat data and visualizes them together . The layout consists of : - Panel 1 ( Top , 25 % ): Spectrogram . - Panel 2 : Raw data trace . - Panel 3 : Normalized ( z - scored ) data trace . - Panels 4 - 6 : Beat instantaneous frequency , amplitude , and duty cycle . All plot axes are linked horizontally for synchronized zooming and panning . Inputs : S - An ndi . session or ndi . dataset object . subject_name - The name of the subject ( e . g . , 'SubjectA' ) . record_type - The type of record ( 'heart' , 'gastric' , or 'pylorus' ) . Optional Name - Value Pair Arguments : data ( 1 , 1 ) struct = struct () A pre - fetched data structure from mlt . doc . getHeartBeatAndSpectrogram . If provided , the function will not re - load the data . zscoreWindowTime ( 1 , 1 ) double = 3600 The time window in seconds for the moving z - score calculation on the raw data . showBeats ( 1 , 1 ) logical = false If true , overlays beat onset ( blue circles ) and offset ( red 'x' ) markers on the raw and normalized data plots . markBeats ( 1 , 1 ) logical = false If true , displays buttons to interactively mark bad and missing beats . Instructions : - Bad : Click near detected beats to mark them as bad ( gray 'X' ) . - Missing : Click to add new , missing beats ( green '+' ) . - Save : Saves the curated beat list to a . mat file . A dialog will appear with instructions . Press Enter after you are done clicking . Linewidth ( 1 , 1 ) double = 1.5 Line width for the time - series plots . colorbar ( 1 , 1 ) logical = false Set to true to display a color bar for each spectrogram . maxColorPercentile ( 1 , 1 ) double = 99 The percentile of the data to use for the color scale maximum . colormapName ( 1 ,:) char = 'parula' The name of the colormap to use . Outputs : ax - A struct containing the handles to the subplot axes . data - The data structure ( either passed in or loaded ) . Example : % Interactively mark beats [ ax , data ] = mlt . plot . subjectTrace ( mySession , 'SubjectA' , 'heart' , 'markBeats' , true ); See also mlt . doc . getHeartBeatAndSpectrogram , mlt . ppg . getRawData , mlt . util . movzscore","title":"mlt.plot.subjectTrace"},{"location":"reference/%2Bmlt/%2Bppg/downsample.m/","text":"mlt.ppg.downsample \u00b6 DOWNSAMPLE - downsample PPG data for Marder experiments DOWNSAMPLE ( S ) Downsample all ppg probes for an ndi . session or ndi . dataset S . Downsamples probes of type 'ppg' by adding '_lp' to their name . After downsampling , an element with a single epoch of the ppg record is made by adding '_lp_whole' to the element name . This element is returned in ELEM_OUT_O .","title":"mlt.ppg.downsample"},{"location":"reference/%2Bmlt/%2Bppg/downsample.m/#mltppgdownsample","text":"DOWNSAMPLE - downsample PPG data for Marder experiments DOWNSAMPLE ( S ) Downsample all ppg probes for an ndi . session or ndi . dataset S . Downsamples probes of type 'ppg' by adding '_lp' to their name . After downsampling , an element with a single epoch of the ppg record is made by adding '_lp_whole' to the element name . This element is returned in ELEM_OUT_O .","title":"mlt.ppg.downsample"},{"location":"reference/%2Bmlt/%2Bppg/getRawData.m/","text":"mlt.ppg.getRawData \u00b6 MLT . PPG . GETRAWDATA Retrieves the raw time series data for a unique PPG element . [ D , T ] = mlt . ppg . getRawData ( S , SUBJECT_NAME , RECORD_TYPE , [ ELEMENT_LABEL ] ) This function finds a unique NDI element for a given subject and record type and returns its entire raw time series data . It uses `mlt.ndi.getElement` to perform the search . The function also handles time conversion . If the element 's epoch is associated with a global experiment clock, the output time vector ' T ' will be a `datetime` vector. Otherwise, it will be a numeric vector in seconds from the start of the recording. Inputs: S - An ndi.session or ndi.dataset object. SUBJECT_NAME - The name of the subject (e.g., ' SubjectA '). RECORD_TYPE - The type of record (' heart ', ' gastric ', or ' pylorus '). ELEMENT_LABEL - (Optional) A further label to identify the element. Defaults to ' lp_whole '. Outputs: D - The raw data vector (unnormalized). T - The time vector (`datetime` or numeric seconds). Example: % Get the raw heart PPG data for SubjectA [data, time] = mlt.ppg.getRawData(mySession, ' SubjectA ', ' heart '); % Plot the raw data figure; plot(time, data); title(' Raw PPG Signal for SubjectA '); xlabel(' Time '); See also: mlt.ndi.getElement, ndi.element.readtimeseries","title":"mlt.ppg.getRawData"},{"location":"reference/%2Bmlt/%2Bppg/getRawData.m/#mltppggetrawdata","text":"MLT . PPG . GETRAWDATA Retrieves the raw time series data for a unique PPG element . [ D , T ] = mlt . ppg . getRawData ( S , SUBJECT_NAME , RECORD_TYPE , [ ELEMENT_LABEL ] ) This function finds a unique NDI element for a given subject and record type and returns its entire raw time series data . It uses `mlt.ndi.getElement` to perform the search . The function also handles time conversion . If the element 's epoch is associated with a global experiment clock, the output time vector ' T ' will be a `datetime` vector. Otherwise, it will be a numeric vector in seconds from the start of the recording. Inputs: S - An ndi.session or ndi.dataset object. SUBJECT_NAME - The name of the subject (e.g., ' SubjectA '). RECORD_TYPE - The type of record (' heart ', ' gastric ', or ' pylorus '). ELEMENT_LABEL - (Optional) A further label to identify the element. Defaults to ' lp_whole '. Outputs: D - The raw data vector (unnormalized). T - The time vector (`datetime` or numeric seconds). Example: % Get the raw heart PPG data for SubjectA [data, time] = mlt.ppg.getRawData(mySession, ' SubjectA ', ' heart '); % Plot the raw data figure; plot(time, data); title(' Raw PPG Signal for SubjectA '); xlabel(' Time '); See also: mlt.ndi.getElement, ndi.element.readtimeseries","title":"mlt.ppg.getRawData"},{"location":"reference/%2Bmlt/%2Bspectrogram/FWHM.m/","text":"mlt.spectrogram.FWHM \u00b6 FWHM Calculates time - averaged spectrogram and its Full Width at Half Maximum . [ specData_avg , f , fwhm_val , low_cutoff , high_cutoff ] = ... mlt . spectrogram . FWHM ( e , t0 , t1 ) Calculates the time - averaged power spectrum and its full width at half maximum ( FWHM ) for a given ndi . element 'e' within a specified time window [ t0 , t1 ] . This function first retrieves the spectrogram data for the specified window and then performs the FWHM calculation on the time - averaged result . Inputs : e - An ndi . element object that has associated 'spectrogram' documents . t0 - A datetime object representing the start of the analysis window . t1 - A datetime object representing the end of the analysis window . Outputs : specData_avg - A column vector of the power spectrum averaged over time . Returns empty if no data is found in the window . f - The corresponding frequency vector ( column vector ) . fwhm_val - The full width at half maximum ( FWHM ) of the spectrum ( Hz ) . Returns NaN if FWHM cannot be calculated . low_cutoff - The lower frequency cutoff at half maximum height ( Hz ) . high_cutoff - The upper frequency cutoff at half maximum height ( Hz ) . Example : % Assuming 'my_element' is a valid ndi . element with spectrograms t_start = datetime ( '2025-09-05 10:00:00' ); t_end = datetime ( '2025-09-05 10:05:00' ); [ spec_avg , f , fwhm ] = mlt . spectrogram . FWHM ( my_element , t_start , t_end ); % Plot the time - averaged spectrum and its FWHM if ~ isempty ( spec_avg ) figure ; plot ( f , spec_avg ); title ([ 'FWHM: ' num2str ( fwhm , ' %.2f ' ) ' Hz' ]); xlabel ( 'Frequency (Hz)' ); ylabel ( 'Average Power' ); grid on ; end See also mlt . spectrogram . readTimeWindow , vlt . signal . fwhm","title":"mlt.spectrogram.FWHM"},{"location":"reference/%2Bmlt/%2Bspectrogram/FWHM.m/#mltspectrogramfwhm","text":"FWHM Calculates time - averaged spectrogram and its Full Width at Half Maximum . [ specData_avg , f , fwhm_val , low_cutoff , high_cutoff ] = ... mlt . spectrogram . FWHM ( e , t0 , t1 ) Calculates the time - averaged power spectrum and its full width at half maximum ( FWHM ) for a given ndi . element 'e' within a specified time window [ t0 , t1 ] . This function first retrieves the spectrogram data for the specified window and then performs the FWHM calculation on the time - averaged result . Inputs : e - An ndi . element object that has associated 'spectrogram' documents . t0 - A datetime object representing the start of the analysis window . t1 - A datetime object representing the end of the analysis window . Outputs : specData_avg - A column vector of the power spectrum averaged over time . Returns empty if no data is found in the window . f - The corresponding frequency vector ( column vector ) . fwhm_val - The full width at half maximum ( FWHM ) of the spectrum ( Hz ) . Returns NaN if FWHM cannot be calculated . low_cutoff - The lower frequency cutoff at half maximum height ( Hz ) . high_cutoff - The upper frequency cutoff at half maximum height ( Hz ) . Example : % Assuming 'my_element' is a valid ndi . element with spectrograms t_start = datetime ( '2025-09-05 10:00:00' ); t_end = datetime ( '2025-09-05 10:05:00' ); [ spec_avg , f , fwhm ] = mlt . spectrogram . FWHM ( my_element , t_start , t_end ); % Plot the time - averaged spectrum and its FWHM if ~ isempty ( spec_avg ) figure ; plot ( f , spec_avg ); title ([ 'FWHM: ' num2str ( fwhm , ' %.2f ' ) ' Hz' ]); xlabel ( 'Frequency (Hz)' ); ylabel ( 'Average Power' ); grid on ; end See also mlt . spectrogram . readTimeWindow , vlt . signal . fwhm","title":"mlt.spectrogram.FWHM"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForDocs.m/","text":"mlt.spectrogram.calculateForDocs \u00b6 CALCULATEFORDOCS - Calculate and save PPG spectrograms as NDI documents . mlt . spectrogram . calculateForDocs ( S ) This is a high - level wrapper function that automates the process of calculating spectrograms for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls the core processing function , mlt . wholeDaySpectrogramDoc , to perform the spectrogram calculation and save the results as a 'spectrogram' NDI document . Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . spectrogram . calculateForDocs ( mySession ); See also mlt.wholeDaySpectrogramDoc, ndi.session","title":"mlt.spectrogram.calculateForDocs"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForDocs.m/#mltspectrogramcalculatefordocs","text":"CALCULATEFORDOCS - Calculate and save PPG spectrograms as NDI documents . mlt . spectrogram . calculateForDocs ( S ) This is a high - level wrapper function that automates the process of calculating spectrograms for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls the core processing function , mlt . wholeDaySpectrogramDoc , to perform the spectrogram calculation and save the results as a 'spectrogram' NDI document . Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . spectrogram . calculateForDocs ( mySession ); See also mlt.wholeDaySpectrogramDoc, ndi.session","title":"mlt.spectrogram.calculateForDocs"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForFiles.m/","text":"mlt.spectrogram.calculateForFiles \u00b6 CALCULATEFORFILES - Calculate and save PPG spectrograms as . mat files . mlt . spectrogram . calculateForFiles ( S ) This is a high - level wrapper function that automates the process of calculating spectrograms for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls a core processing function to perform the spectrogram calculation and saves the results to a standalone . mat file in the session ' s path . The output files are named according to the convention : 'ppg_ELEMENT-NAME_REFERENCE.mat' Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . spectrogram . calculateForFiles ( mySession ); See also mlt.wholeDaySpectrogram, ndi.session","title":"mlt.spectrogram.calculateForFiles"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForFiles.m/#mltspectrogramcalculateforfiles","text":"CALCULATEFORFILES - Calculate and save PPG spectrograms as . mat files . mlt . spectrogram . calculateForFiles ( S ) This is a high - level wrapper function that automates the process of calculating spectrograms for all PPG ( photoplethysmogram ) probes within a given NDI session or dataset . For each 'ppg' probe found , the function first identifies its corresponding low - pass filtered data element ( e . g ., 'ppg_heart_lp_whole' ). It then calls a core processing function to perform the spectrogram calculation and saves the results to a standalone . mat file in the session ' s path . The output files are named according to the convention : 'ppg_ELEMENT-NAME_REFERENCE.mat' Inputs : S - An ndi . session or ndi . dataset object . Example : % Assuming 'mySession' is a valid ndi.session object with PPG data mlt . spectrogram . calculateForFiles ( mySession ); See also mlt.wholeDaySpectrogram, ndi.session","title":"mlt.spectrogram.calculateForFiles"},{"location":"reference/%2Bmlt/%2Bspectrogram/readTimeWindow.m/","text":"mlt.spectrogram.readTimeWindow \u00b6 READTIMEWINDOW Read the first matching spectrogram data within a time window. [ spectrogram_data , f , t_datetime , spectrogram_doc ] = ... mlt . spectrogram . readTimeWindow ( e , t0 , t1 ) Searches an NDI session for 'spectrogram' documents associated with a given ndi . element 'e' . It finds the first document that temporally overlaps with the window [ t0 , t1 ], reads the spectrogram data , and returns only the portion of the data that falls within the window . Inputs : e - An ndi . element object . The session is retrieved from e . session . t0 - A datetime object representing the start of the window . t1 - A datetime object representing the end of the window . Outputs : spectrogram_data - The portion of the spectrogram data ( numeric matrix , typically [ frequency x time ]) that falls within the [ t0 , t1 ] window . Returns [] if no match is found . f - The frequency vector ( column vector ) for the data . t_datetime - A datetime vector for the time axis of the returned data . spectrogram_doc - The ndi . document object from which the data was extracted . Logic : 1. Finds all 'spectrogram' documents that depend on the element 'e' . 2. For each document , it checks if the document ' s epoch overlaps with [ t0 , t1 ]. 3. For the first overlapping document , it reads the full ngrid data . 4. It converts the data ' s local timestamps to the session ' s global time clock . 5. It filters the data and timestamps to the requested [ t0 , t1 ] window . 6. It returns the filtered data and exits . If no match is found , it returns empty . Example : % Assuming 'my_element' is a valid ndi.element with spectrograms t_start = datetime ( '2025-09-05 10:00:00' ); t_end = datetime ( '2025-09-05 10:05:00' ); [ spec , freq , time ] = mlt . spectrogram . readTimeWindow ( my_element , t_start , t_end ); if ~ isempty ( spec ) imagesc ( time , freq , spec ); set ( gca , 'YDir' , 'normal' ); end See also mlt . spectrogram . FWHM , ndi . session . database_search , ndi . time . syncgraph . time_convert","title":"mlt.spectrogram.readTimeWindow"},{"location":"reference/%2Bmlt/%2Bspectrogram/readTimeWindow.m/#mltspectrogramreadtimewindow","text":"READTIMEWINDOW Read the first matching spectrogram data within a time window. [ spectrogram_data , f , t_datetime , spectrogram_doc ] = ... mlt . spectrogram . readTimeWindow ( e , t0 , t1 ) Searches an NDI session for 'spectrogram' documents associated with a given ndi . element 'e' . It finds the first document that temporally overlaps with the window [ t0 , t1 ], reads the spectrogram data , and returns only the portion of the data that falls within the window . Inputs : e - An ndi . element object . The session is retrieved from e . session . t0 - A datetime object representing the start of the window . t1 - A datetime object representing the end of the window . Outputs : spectrogram_data - The portion of the spectrogram data ( numeric matrix , typically [ frequency x time ]) that falls within the [ t0 , t1 ] window . Returns [] if no match is found . f - The frequency vector ( column vector ) for the data . t_datetime - A datetime vector for the time axis of the returned data . spectrogram_doc - The ndi . document object from which the data was extracted . Logic : 1. Finds all 'spectrogram' documents that depend on the element 'e' . 2. For each document , it checks if the document ' s epoch overlaps with [ t0 , t1 ]. 3. For the first overlapping document , it reads the full ngrid data . 4. It converts the data ' s local timestamps to the session ' s global time clock . 5. It filters the data and timestamps to the requested [ t0 , t1 ] window . 6. It returns the filtered data and exits . If no match is found , it returns empty . Example : % Assuming 'my_element' is a valid ndi.element with spectrograms t_start = datetime ( '2025-09-05 10:00:00' ); t_end = datetime ( '2025-09-05 10:05:00' ); [ spec , freq , time ] = mlt . spectrogram . readTimeWindow ( my_element , t_start , t_end ); if ~ isempty ( spec ) imagesc ( time , freq , spec ); set ( gca , 'YDir' , 'normal' ); end See also mlt . spectrogram . FWHM , ndi . session . database_search , ndi . time . syncgraph . time_convert","title":"mlt.spectrogram.readTimeWindow"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogram.m/","text":"mlt.spectrogram.wholeDaySpectrogram \u00b6 WHOLEDAYSPECTROGRAM Computes a spectrogram for a complete NDI element recording . [ SPEC , F , TS ] = mlt . spectrogram . wholeDaySpectrogram ( S , Name , Value , ... ) Calculates a spectrogram for the entire duration of a specified ndi . element . The function has two primary modes of operation based on the time clocks available for the element 's first epoch. 1. ** Global Clock Mode ** : If an 'exp_global_time' clock is found , the function reads the entire time series at once . It then applies a Z - score normalization ( either moving or global ) to the signal before computing the spectrogram with ` mlt . util . computeSpectrogram ` . 2. ** Epoch - by - Epoch Mode ** : If no global clock is found , the function iterates through each epoch of the element individually . It computes a spectrogram for each epoch using ` mlt . util . makeSpectrogram ` , optionally downsamples the result , and concatenates the pieces to form a single , continuous output . Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : e_name ( 'ppg_heart_lp' ) The name of the ndi . element to analyze . e_reference ( 1 ) The reference number of the ndi . element . f ( 0.1 : 0.1 : 10 ) A vector of frequencies ( Hz ) to analyze in the spectrogram . windowTime ( 10 ) The duration of the sliding window ( in seconds ) used for the spectrogram calculation . downSample ( 2 ) ( Epoch - by - Epoch Mode Only ) The factor by which to downsample the time dimension of the spectrogram for each epoch . For example , a value of 2 keeps every other time point . zscoreWindowTime ( 3600 ) ( Global Clock Mode Only ) The duration of the moving window ( in seconds ) for z - score normalization . If set to 0 , a global z - score is applied across the entire signal . Outputs : spec - The computed spectrogram data matrix ([ frequency x time ]) . f - The frequency vector ( Hz ) corresponding to the rows of 'spec' . ts - The time vector corresponding to the columns of 'spec' . The units are datenum in Global Clock Mode and seconds from the start in Epoch - by - Epoch Mode . Example : % Calculate a spectrogram for a specific element [ spec , f , ts ] = mlt . spectrogram . wholeDaySpectrogram ( mySession , ... 'e_name' , 'ppg_pylorus_lp_whole' , 'e_reference' , 1 ); % Plot the result figure ; imagesc ( ts , f , spec ); set ( gca , 'YDir' , 'normal' ); xlabel ( 'Time' ); ylabel ( 'Frequency (Hz)' ); See also mlt . util . computeSpectrogram , mlt . util . makeSpectrogram , mlt . util . movzscore , ndi . element","title":"mlt.spectrogram.wholeDaySpectrogram"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogram.m/#mltspectrogramwholedayspectrogram","text":"WHOLEDAYSPECTROGRAM Computes a spectrogram for a complete NDI element recording . [ SPEC , F , TS ] = mlt . spectrogram . wholeDaySpectrogram ( S , Name , Value , ... ) Calculates a spectrogram for the entire duration of a specified ndi . element . The function has two primary modes of operation based on the time clocks available for the element 's first epoch. 1. ** Global Clock Mode ** : If an 'exp_global_time' clock is found , the function reads the entire time series at once . It then applies a Z - score normalization ( either moving or global ) to the signal before computing the spectrogram with ` mlt . util . computeSpectrogram ` . 2. ** Epoch - by - Epoch Mode ** : If no global clock is found , the function iterates through each epoch of the element individually . It computes a spectrogram for each epoch using ` mlt . util . makeSpectrogram ` , optionally downsamples the result , and concatenates the pieces to form a single , continuous output . Inputs : S - An ndi . session or ndi . dataset object . Optional Name - Value Pairs : e_name ( 'ppg_heart_lp' ) The name of the ndi . element to analyze . e_reference ( 1 ) The reference number of the ndi . element . f ( 0.1 : 0.1 : 10 ) A vector of frequencies ( Hz ) to analyze in the spectrogram . windowTime ( 10 ) The duration of the sliding window ( in seconds ) used for the spectrogram calculation . downSample ( 2 ) ( Epoch - by - Epoch Mode Only ) The factor by which to downsample the time dimension of the spectrogram for each epoch . For example , a value of 2 keeps every other time point . zscoreWindowTime ( 3600 ) ( Global Clock Mode Only ) The duration of the moving window ( in seconds ) for z - score normalization . If set to 0 , a global z - score is applied across the entire signal . Outputs : spec - The computed spectrogram data matrix ([ frequency x time ]) . f - The frequency vector ( Hz ) corresponding to the rows of 'spec' . ts - The time vector corresponding to the columns of 'spec' . The units are datenum in Global Clock Mode and seconds from the start in Epoch - by - Epoch Mode . Example : % Calculate a spectrogram for a specific element [ spec , f , ts ] = mlt . spectrogram . wholeDaySpectrogram ( mySession , ... 'e_name' , 'ppg_pylorus_lp_whole' , 'e_reference' , 1 ); % Plot the result figure ; imagesc ( ts , f , spec ); set ( gca , 'YDir' , 'normal' ); xlabel ( 'Time' ); ylabel ( 'Frequency (Hz)' ); See also mlt . util . computeSpectrogram , mlt . util . makeSpectrogram , mlt . util . movzscore , ndi . element","title":"mlt.spectrogram.wholeDaySpectrogram"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogramDoc.m/","text":"mlt.spectrogram.wholeDaySpectrogramDoc \u00b6 WHOLEDAYSPECTROGRAMDOC Computes and saves a spectrogram as an NDI document . [ DOC ] = mlt . spectrogram . wholeDaySpectrogramDoc ( S , Name , Value , ...) Calculates a spectrogram for the entire duration of a specified ndi . element and saves the result as an NDI document in the session 's database. This function is a key step in pre-processing data for later analysis. The function has two primary modes of operation based on the time clocks available for the element' s first epoch : 1. ** Continuous Mode ** : If a 'dev_local_time' clock is found , the function reads the entire time series for that epoch at once . It then applies a Z - score normalization before computing the spectrogram . 2. ** Epoch - by - Epoch Mode ** : If no local clock is found , the function iterates through each epoch of the element individually , computes a spectrogram for each , and concatenates the results . After calculation , the function creates an 'spectrogram' type NDI document , writes the spectrogram data to a binary . ngrid file , links the file to the document , and adds the document to the database . ** Note : ** If a spectrogram document for this element 's first epoch already exists, it will be removed and replaced. Inputs: S - An ndi.session or ndi.dataset object. Optional Name-Value Pairs: e_name (' ppg_heart_lp_whole ') The name of the ndi.element to analyze. e_reference (1) The reference number of the ndi.element. f (0.1:0.1:10) A vector of frequencies (Hz) to analyze in the spectrogram. windowTime (10) The duration of the sliding window (in seconds) for the calculation. downSample (2) (Epoch-by-Epoch Mode Only) The factor by which to downsample the time dimension of the spectrogram. zscoreWindowTime (3600) (Continuous Mode Only) The duration of the moving window (in seconds) for z-score normalization. If set to 0, a global z-score is applied across the entire signal. Outputs: doc - The ndi.document object that was created and added to the database. Example: % Calculate a spectrogram and save it as a document for a specific element doc = mlt.spectrogram.wholeDaySpectrogramDoc(mySession, ... ' e_name ', ' ppg_pylorus_lp_whole ', ' e_reference ' , 1 ); See also mlt . spectrogram . wholeDaySpectrogram , ndi . document , ndi . session . database_add","title":"mlt.spectrogram.wholeDaySpectrogramDoc"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogramDoc.m/#mltspectrogramwholedayspectrogramdoc","text":"WHOLEDAYSPECTROGRAMDOC Computes and saves a spectrogram as an NDI document . [ DOC ] = mlt . spectrogram . wholeDaySpectrogramDoc ( S , Name , Value , ...) Calculates a spectrogram for the entire duration of a specified ndi . element and saves the result as an NDI document in the session 's database. This function is a key step in pre-processing data for later analysis. The function has two primary modes of operation based on the time clocks available for the element' s first epoch : 1. ** Continuous Mode ** : If a 'dev_local_time' clock is found , the function reads the entire time series for that epoch at once . It then applies a Z - score normalization before computing the spectrogram . 2. ** Epoch - by - Epoch Mode ** : If no local clock is found , the function iterates through each epoch of the element individually , computes a spectrogram for each , and concatenates the results . After calculation , the function creates an 'spectrogram' type NDI document , writes the spectrogram data to a binary . ngrid file , links the file to the document , and adds the document to the database . ** Note : ** If a spectrogram document for this element 's first epoch already exists, it will be removed and replaced. Inputs: S - An ndi.session or ndi.dataset object. Optional Name-Value Pairs: e_name (' ppg_heart_lp_whole ') The name of the ndi.element to analyze. e_reference (1) The reference number of the ndi.element. f (0.1:0.1:10) A vector of frequencies (Hz) to analyze in the spectrogram. windowTime (10) The duration of the sliding window (in seconds) for the calculation. downSample (2) (Epoch-by-Epoch Mode Only) The factor by which to downsample the time dimension of the spectrogram. zscoreWindowTime (3600) (Continuous Mode Only) The duration of the moving window (in seconds) for z-score normalization. If set to 0, a global z-score is applied across the entire signal. Outputs: doc - The ndi.document object that was created and added to the database. Example: % Calculate a spectrogram and save it as a document for a specific element doc = mlt.spectrogram.wholeDaySpectrogramDoc(mySession, ... ' e_name ', ' ppg_pylorus_lp_whole ', ' e_reference ' , 1 ); See also mlt . spectrogram . wholeDaySpectrogram , ndi . document , ndi . session . database_add","title":"mlt.spectrogram.wholeDaySpectrogramDoc"},{"location":"reference/%2Bmlt/%2Butil/computeChunkedSpectrogram.m/","text":"mlt.util.computeChunkedSpectrogram \u00b6 COMPUTECHUNKEDSPECTROGRAM Calculates a spectrogram for discontinuously sampled data . [ spectrogram_data , f , t_s ] = computeChunkedSpectrogram ( data , t , ... ) This function is designed to compute a spectrogram for time - series data that may contain gaps or discontinuities in its sampling . It works by identifying large jumps in the time vector , splitting the data into continuous chunks , computing a spectrogram for each chunk , and then concatenating the results . This preserves the temporal integrity of the recording , and the output time vector 't_s' will reflect the original gaps . Inputs : data - A numeric column vector of time - series data . t - A numeric or datetime column vector of timestamps for the data . Optional Name - Value Pair Arguments : frequencies ( 1 ,:) double = 0.1 : 0.1 : 10 A vector of frequencies ( Hz ) to evaluate in the spectrogram . windowSizeTime ( 1 , 1 ) double = 10 The duration of the sliding window in seconds . useDecibels ( 1 , 1 ) logical = true If true , converts the output power spectrogram to decibels ( 10 * log10 ( P )) . timeIsDatenum ( 1 , 1 ) logical = false If true , the input time vector 't' is treated as MATLAB datenum values . gapThresholdFactor ( 1 , 1 ) double = 2 A factor that is multiplied by the median sample interval to determine the time difference that constitutes a gap . Any jump in time greater than this threshold will split the data . Outputs : spectrogram_data - The concatenated spectrogram data matrix ([ frequency x time ]) . f - The frequency vector ( Hz ) corresponding to the rows . t_s - The concatenated time vector for the columns . Its type ( numeric or datetime ) matches the input time vector 't' and it will contain the same time gaps . See also spectrogram , diff , median","title":"mlt.util.computeChunkedSpectrogram"},{"location":"reference/%2Bmlt/%2Butil/computeChunkedSpectrogram.m/#mltutilcomputechunkedspectrogram","text":"COMPUTECHUNKEDSPECTROGRAM Calculates a spectrogram for discontinuously sampled data . [ spectrogram_data , f , t_s ] = computeChunkedSpectrogram ( data , t , ... ) This function is designed to compute a spectrogram for time - series data that may contain gaps or discontinuities in its sampling . It works by identifying large jumps in the time vector , splitting the data into continuous chunks , computing a spectrogram for each chunk , and then concatenating the results . This preserves the temporal integrity of the recording , and the output time vector 't_s' will reflect the original gaps . Inputs : data - A numeric column vector of time - series data . t - A numeric or datetime column vector of timestamps for the data . Optional Name - Value Pair Arguments : frequencies ( 1 ,:) double = 0.1 : 0.1 : 10 A vector of frequencies ( Hz ) to evaluate in the spectrogram . windowSizeTime ( 1 , 1 ) double = 10 The duration of the sliding window in seconds . useDecibels ( 1 , 1 ) logical = true If true , converts the output power spectrogram to decibels ( 10 * log10 ( P )) . timeIsDatenum ( 1 , 1 ) logical = false If true , the input time vector 't' is treated as MATLAB datenum values . gapThresholdFactor ( 1 , 1 ) double = 2 A factor that is multiplied by the median sample interval to determine the time difference that constitutes a gap . Any jump in time greater than this threshold will split the data . Outputs : spectrogram_data - The concatenated spectrogram data matrix ([ frequency x time ]) . f - The frequency vector ( Hz ) corresponding to the rows . t_s - The concatenated time vector for the columns . Its type ( numeric or datetime ) matches the input time vector 't' and it will contain the same time gaps . See also spectrogram , diff , median","title":"mlt.util.computeChunkedSpectrogram"},{"location":"reference/%2Bmlt/%2Butil/computeSpectrogram.m/","text":"mlt.util.computeSpectrogram \u00b6 COMPUTESPECTROGRAM Calculates a spectrogram with specific toolbox defaults . [ spectrogram_data , f , t_s ] = mlt . util . computeSpectrogram ( data , t , ...) This is the core spectrogram calculation engine for the toolbox . It serves as a wrapper around MATLAB 's built-in `spectrogram` function, providing convenient handling of time vectors (including datetime and datenum) and conversion of the output power to decibels. Inputs: data - A numeric column vector of time-series data. t - A numeric or datetime column vector of timestamps for the data. Optional Name-Value Pair Arguments: frequencies (1,:) double = 0.1:0.1:10 A vector of frequencies (Hz) to evaluate in the spectrogram. windowSizeTime (1,1) double = 10 The duration of the sliding window in seconds. useDecibels (1,1) logical = true If true, converts the output power spectrogram to decibels (10*log10(P)). timeIsDatenum (1,1) logical = false If true, the input time vector ' t ' is treated as MATLAB datenum values instead of seconds. Outputs: spectrogram_data - The computed spectrogram data matrix ([frequency x time]). f - The frequency vector (Hz) corresponding to the rows. t_s - The time vector for the columns. Its type (numeric or datetime) matches the input time vector ' t '. Example: % Create a sample signal: 2 Hz sine wave for 60 seconds fs = 100; % 100 Hz sampling rate t = (0:1/fs:60-1/fs)' ; data = sin ( 2 * pi * 2 * t ) + 0.5 * randn ( size ( t )); freqs_of_interest = 0 : 0.5 : 10 ; [ spec , f , ts ] = mlt . util . computeSpectrogram ( data , t , ... 'frequencies' , freqs_of_interest , 'windowSizeTime' , 5 ); See also spectrogram , datetime , log10","title":"mlt.util.computeSpectrogram"},{"location":"reference/%2Bmlt/%2Butil/computeSpectrogram.m/#mltutilcomputespectrogram","text":"COMPUTESPECTROGRAM Calculates a spectrogram with specific toolbox defaults . [ spectrogram_data , f , t_s ] = mlt . util . computeSpectrogram ( data , t , ...) This is the core spectrogram calculation engine for the toolbox . It serves as a wrapper around MATLAB 's built-in `spectrogram` function, providing convenient handling of time vectors (including datetime and datenum) and conversion of the output power to decibels. Inputs: data - A numeric column vector of time-series data. t - A numeric or datetime column vector of timestamps for the data. Optional Name-Value Pair Arguments: frequencies (1,:) double = 0.1:0.1:10 A vector of frequencies (Hz) to evaluate in the spectrogram. windowSizeTime (1,1) double = 10 The duration of the sliding window in seconds. useDecibels (1,1) logical = true If true, converts the output power spectrogram to decibels (10*log10(P)). timeIsDatenum (1,1) logical = false If true, the input time vector ' t ' is treated as MATLAB datenum values instead of seconds. Outputs: spectrogram_data - The computed spectrogram data matrix ([frequency x time]). f - The frequency vector (Hz) corresponding to the rows. t_s - The time vector for the columns. Its type (numeric or datetime) matches the input time vector ' t '. Example: % Create a sample signal: 2 Hz sine wave for 60 seconds fs = 100; % 100 Hz sampling rate t = (0:1/fs:60-1/fs)' ; data = sin ( 2 * pi * 2 * t ) + 0.5 * randn ( size ( t )); freqs_of_interest = 0 : 0.5 : 10 ; [ spec , f , ts ] = mlt . util . computeSpectrogram ( data , t , ... 'frequencies' , freqs_of_interest , 'windowSizeTime' , 5 ); See also spectrogram , datetime , log10","title":"mlt.util.computeSpectrogram"},{"location":"reference/%2Bmlt/%2Butil/makeSpectrogram.m/","text":"mlt.util.makeSpectrogram \u00b6 MAKESPECTROGRAM Computes a spectrogram for a single NDI element epoch. [ spectrogram_data , f , t_s ] = mlt . util . makeSpectrogram ( ndi_element_obj , ... epoch_id , frequencies , windowSizeTime ) This function serves as a convenient wrapper to compute a spectrogram for the entire time series of a single , specified epoch from an NDI element . It reads the data , normalizes it with a global z - score , and then calls the core ` mlt . util . spectrogram ` function to perform the calculation . Inputs : ndi_element_obj - An ndi . element object . epoch_id - The character vector or string ID for the epoch to be analyzed . frequencies - A vector of frequencies ( Hz ) to be used in the spectrogram calculation . windowSizeTime - The desired window size in seconds . Outputs : spectrogram_data - The spectrogram data matrix ([ frequency x time ]). f - The frequency vector ( Hz ) used in the calculation . t_s - The time vector ( seconds ) for the spectrogram output . Example : % Assume 'my_element' is a valid ndi.element and 'epoch001' is an % ID from its epoch table. freqs = 0.1 : 0.1 : 10 ; % 0.1 to 10 Hz win_sec = 10 ; % 10-second window [ spec , f , t ] = mlt . util . makeSpectrogram ( my_element , 'epoch001' , freqs , win_sec ); See also mlt.util.spectrogram, ndi.element.readtimeseries, zscore","title":"mlt.util.makeSpectrogram"},{"location":"reference/%2Bmlt/%2Butil/makeSpectrogram.m/#mltutilmakespectrogram","text":"MAKESPECTROGRAM Computes a spectrogram for a single NDI element epoch. [ spectrogram_data , f , t_s ] = mlt . util . makeSpectrogram ( ndi_element_obj , ... epoch_id , frequencies , windowSizeTime ) This function serves as a convenient wrapper to compute a spectrogram for the entire time series of a single , specified epoch from an NDI element . It reads the data , normalizes it with a global z - score , and then calls the core ` mlt . util . spectrogram ` function to perform the calculation . Inputs : ndi_element_obj - An ndi . element object . epoch_id - The character vector or string ID for the epoch to be analyzed . frequencies - A vector of frequencies ( Hz ) to be used in the spectrogram calculation . windowSizeTime - The desired window size in seconds . Outputs : spectrogram_data - The spectrogram data matrix ([ frequency x time ]). f - The frequency vector ( Hz ) used in the calculation . t_s - The time vector ( seconds ) for the spectrogram output . Example : % Assume 'my_element' is a valid ndi.element and 'epoch001' is an % ID from its epoch table. freqs = 0.1 : 0.1 : 10 ; % 0.1 to 10 Hz win_sec = 10 ; % 10-second window [ spec , f , t ] = mlt . util . makeSpectrogram ( my_element , 'epoch001' , freqs , win_sec ); See also mlt.util.spectrogram, ndi.element.readtimeseries, zscore","title":"mlt.util.makeSpectrogram"},{"location":"reference/%2Bmlt/%2Butil/movzscore.m/","text":"mlt.util.movzscore \u00b6 MOVZSCORE - Moving z - score calculation . Computes the moving z - score of the input data X using a sliding window . The z - score is calculated for each element by centering and scaling the element with the mean and standard deviation of its k neighbors . Syntax : Z = MOVZSCORE ( X , k ) Calculates the moving z - score using a window of length k . Z = MOVZSCORE ( X , [ kb kf ]) Calculates the moving z - score using a directional window , where kb is the number of elements before and kf is the number of elements after the current element . Z = MOVZSCORE (..., Options ) Specifies additional options using name - value pairs . Input Arguments : X - Input data . Vector , matrix , multidimensional array , table , or timetable . k - Window length . Numeric or duration scalar . [ kb kf ] - Directional window length . Numeric or duration row vector containing two elements . kb : Number of elements before the current element . kf : Number of elements after the current element . Options - Optional parameters specified as name - value pairs . ' Weight ' - Weight indicator for standard deviation . 0 ( default ) : Normalization by N -1. 1 : Normalization by N . ' Dimension ' - Dimension to operate along . Positive integer scalar . ' NaNFlag ' - Missing value handling . ' includemissing ' ( default ) or ' includenan ' : Include NaN / missing values . ' omitmissing ' or ' omitnan ' : Exclude NaN / missing values . ' Endpoints ' - Method to treat leading and trailing windows . ' shrink ' ( default ) : Window shrinks at edges . ' discard ' : Discard edge values ( not supported for tables ). ' fill ' : Fill edge values with NaN . Numeric or logical scalar : Fill edge values with scalar . ' SamplePoints ' - Sample points for computation . Vector . ' DataVariables ' - Table or timetable variables to operate on . Table variable name , scalar , vector , cell array , pattern , function handle , or table vartype subscript . Default : Numeric variables . ' ReplaceValues ' - Replace original values with z - scores . true ( default ) or 1 : Replace original values . false or 0 : Append z - scores as new variables . Output Arguments : Z - Moving z - score . Same type and size as X , or table / timetable with appended z - score variables depending on the ' ReplaceValues ' option . Example : x = randn ( 100 , 1 ); z = movzscore ( x , 10 ); % Moving z - score with window length 10. x = table ( randn ( 10 , 2 ), randn ( 10 , 2 ), ' VariableNames ' , { 'A' , 'B' , 'C' , 'D' }); z = movzscore ( x , 3 , ' DataVariables ' , { 'A' , 'C' }, ' ReplaceValues ' , false ); See also : MOVMEAN , MOVSTD . Notes : - When ' Endpoints ' is ' discard ' and X is a table , ' Endpoints ' is automatically set to ' fill ' with a warning . - If ' DataVariables ' is not specified for tables , numeric variables are used by default . Error Handling : - ' MOVZSCORE : endpointsDiscardTabular ' : When ' Endpoints ' is ' discard ' and X is a table . - ' MOVZSCORE : defaultDataVariables ' : When DataVariables is not specified for tables . - ' MOVZSCORE : invalidDataVariables ' : When DataVariables is an unsupported datatype .","title":"mlt.util.movzscore"},{"location":"reference/%2Bmlt/%2Butil/movzscore.m/#mltutilmovzscore","text":"MOVZSCORE - Moving z - score calculation . Computes the moving z - score of the input data X using a sliding window . The z - score is calculated for each element by centering and scaling the element with the mean and standard deviation of its k neighbors . Syntax : Z = MOVZSCORE ( X , k ) Calculates the moving z - score using a window of length k . Z = MOVZSCORE ( X , [ kb kf ]) Calculates the moving z - score using a directional window , where kb is the number of elements before and kf is the number of elements after the current element . Z = MOVZSCORE (..., Options ) Specifies additional options using name - value pairs . Input Arguments : X - Input data . Vector , matrix , multidimensional array , table , or timetable . k - Window length . Numeric or duration scalar . [ kb kf ] - Directional window length . Numeric or duration row vector containing two elements . kb : Number of elements before the current element . kf : Number of elements after the current element . Options - Optional parameters specified as name - value pairs . ' Weight ' - Weight indicator for standard deviation . 0 ( default ) : Normalization by N -1. 1 : Normalization by N . ' Dimension ' - Dimension to operate along . Positive integer scalar . ' NaNFlag ' - Missing value handling . ' includemissing ' ( default ) or ' includenan ' : Include NaN / missing values . ' omitmissing ' or ' omitnan ' : Exclude NaN / missing values . ' Endpoints ' - Method to treat leading and trailing windows . ' shrink ' ( default ) : Window shrinks at edges . ' discard ' : Discard edge values ( not supported for tables ). ' fill ' : Fill edge values with NaN . Numeric or logical scalar : Fill edge values with scalar . ' SamplePoints ' - Sample points for computation . Vector . ' DataVariables ' - Table or timetable variables to operate on . Table variable name , scalar , vector , cell array , pattern , function handle , or table vartype subscript . Default : Numeric variables . ' ReplaceValues ' - Replace original values with z - scores . true ( default ) or 1 : Replace original values . false or 0 : Append z - scores as new variables . Output Arguments : Z - Moving z - score . Same type and size as X , or table / timetable with appended z - score variables depending on the ' ReplaceValues ' option . Example : x = randn ( 100 , 1 ); z = movzscore ( x , 10 ); % Moving z - score with window length 10. x = table ( randn ( 10 , 2 ), randn ( 10 , 2 ), ' VariableNames ' , { 'A' , 'B' , 'C' , 'D' }); z = movzscore ( x , 3 , ' DataVariables ' , { 'A' , 'C' }, ' ReplaceValues ' , false ); See also : MOVMEAN , MOVSTD . Notes : - When ' Endpoints ' is ' discard ' and X is a table , ' Endpoints ' is automatically set to ' fill ' with a warning . - If ' DataVariables ' is not specified for tables , numeric variables are used by default . Error Handling : - ' MOVZSCORE : endpointsDiscardTabular ' : When ' Endpoints ' is ' discard ' and X is a table . - ' MOVZSCORE : defaultDataVariables ' : When DataVariables is not specified for tables . - ' MOVZSCORE : invalidDataVariables ' : When DataVariables is an unsupported datatype .","title":"mlt.util.movzscore"},{"location":"reference/%2Bmlt/%2Butil/mscohere.m/","text":"mlt.util.mscohere \u00b6 MLT . MSCOHERE Computes magnitude - squared coherence with convenient defaults . [ cxy , f ] = mlt . util . mscohere ( X , Y , dt ) computes the magnitude - squared coherence estimate between time series X and Y . It is a wrapper for the built - in MATLAB `mscohere` function from the Signal Processing Toolbox , tailored for ease of use with specific defaults . SYNTAX : [ cxy , f ] = mlt . util . mscohere ( X , Y , dt ) [ cxy , f ] = mlt . util . mscohere ( X , Y , dt , Name , Value , ...) INPUTS : X - First time series , specified as a column vector . Y - Second time series , specified as a column vector . Must be the same length as X . dt - The time step ( sampling interval ) of the time series , in seconds . The sampling frequency is calculated as 1 / dt . OPTIONAL NAME - VALUE PAIR INPUTS : 'window_length' - Length of the windowing function . The frequency resolution is determined by Fs / window_length . Default : 256 'n_overlap' - Number of samples by which consecutive windows overlap . A 50 % overlap is generally a good choice . Default : 128 'n_fft' - Number of points for the Fast Fourier Transform . Note : This function specifies the exact frequencies to compute via 'freq_vector' , so 'n_fft' is not passed to the underlying MATLAB function . It is retained here as a parameter for documentation and potential future use . Default : 256 'freq_vector' - A column vector of frequencies ( in Hz ) at which to compute the coherence . This provides direct control over the output frequency range . Default : ( 0 : 0.1 : 10 ) ' OUTPUTS: cxy - The magnitude-squared coherence, returned as a column vector. Values range from 0 to 1. f - The vector of frequencies (in Hz) corresponding to the coherence estimates in cxy. EXAMPLE: % Create two signals with a common component at 5 Hz Fs = 200; % Sampling frequency dt = 1/Fs; % Time step t = (0:dt:10-dt)' ; % Time vector ( 10 seconds ) common_signal = 0.5 * sin ( 2 * pi * 5 * t ); noise1 = 0.8 * randn ( size ( t )); noise2 = 0.8 * randn ( size ( t )); x = common_signal + noise1 ; y = common_signal + noise2 ; % Compute coherence using the function 's defaults (0-10 Hz) [cxy, f] = mlt.util.mscohere(x, y, dt); % Plot the results figure; plot(f, cxy, ' LineWidth ', 1.5); grid on; title(' Coherence between two noisy signals '); xlabel(' Frequency ( Hz ) '); ylabel(' Magnitude - Squared Coherence '); ylim([0 1.05]);","title":"mlt.util.mscohere"},{"location":"reference/%2Bmlt/%2Butil/mscohere.m/#mltutilmscohere","text":"MLT . MSCOHERE Computes magnitude - squared coherence with convenient defaults . [ cxy , f ] = mlt . util . mscohere ( X , Y , dt ) computes the magnitude - squared coherence estimate between time series X and Y . It is a wrapper for the built - in MATLAB `mscohere` function from the Signal Processing Toolbox , tailored for ease of use with specific defaults . SYNTAX : [ cxy , f ] = mlt . util . mscohere ( X , Y , dt ) [ cxy , f ] = mlt . util . mscohere ( X , Y , dt , Name , Value , ...) INPUTS : X - First time series , specified as a column vector . Y - Second time series , specified as a column vector . Must be the same length as X . dt - The time step ( sampling interval ) of the time series , in seconds . The sampling frequency is calculated as 1 / dt . OPTIONAL NAME - VALUE PAIR INPUTS : 'window_length' - Length of the windowing function . The frequency resolution is determined by Fs / window_length . Default : 256 'n_overlap' - Number of samples by which consecutive windows overlap . A 50 % overlap is generally a good choice . Default : 128 'n_fft' - Number of points for the Fast Fourier Transform . Note : This function specifies the exact frequencies to compute via 'freq_vector' , so 'n_fft' is not passed to the underlying MATLAB function . It is retained here as a parameter for documentation and potential future use . Default : 256 'freq_vector' - A column vector of frequencies ( in Hz ) at which to compute the coherence . This provides direct control over the output frequency range . Default : ( 0 : 0.1 : 10 ) ' OUTPUTS: cxy - The magnitude-squared coherence, returned as a column vector. Values range from 0 to 1. f - The vector of frequencies (in Hz) corresponding to the coherence estimates in cxy. EXAMPLE: % Create two signals with a common component at 5 Hz Fs = 200; % Sampling frequency dt = 1/Fs; % Time step t = (0:dt:10-dt)' ; % Time vector ( 10 seconds ) common_signal = 0.5 * sin ( 2 * pi * 5 * t ); noise1 = 0.8 * randn ( size ( t )); noise2 = 0.8 * randn ( size ( t )); x = common_signal + noise1 ; y = common_signal + noise2 ; % Compute coherence using the function 's defaults (0-10 Hz) [cxy, f] = mlt.util.mscohere(x, y, dt); % Plot the results figure; plot(f, cxy, ' LineWidth ', 1.5); grid on; title(' Coherence between two noisy signals '); xlabel(' Frequency ( Hz ) '); ylabel(' Magnitude - Squared Coherence '); ylim([0 1.05]);","title":"mlt.util.mscohere"},{"location":"reference/%2Bmlt/%2Butil/toolboxdir.m/","text":"mlt.util.toolboxdir \u00b6 TOOLBOXDIR - return the full path of the mlt - matlab toolbox P = mlt . util . toolboxdir () Returns the full path to the mlt - matlab toolbox . It is assumed that this function is in the folder [ TOOLBOXDIR ]/+ mlt /+ util /","title":"mlt.util.toolboxdir"},{"location":"reference/%2Bmlt/%2Butil/toolboxdir.m/#mltutiltoolboxdir","text":"TOOLBOXDIR - return the full path of the mlt - matlab toolbox P = mlt . util . toolboxdir () Returns the full path to the mlt - matlab toolbox . It is assumed that this function is in the folder [ TOOLBOXDIR ]/+ mlt /+ util /","title":"mlt.util.toolboxdir"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/abf2probetable.m/","text":"ndi.setup.conv.marder.abf2probetable \u00b6 ABF2PROBETABLE - Populate a probetable table for a Marder ndi session ABF2PROBETABLE ( S ) Reads all ABF files in the NDI session S and creates a putative probetable file . To create a new Marder lab session from a directory , use S = ndi . setup . lab ( 'marderlab' , REF , DIRNAME ) It is necessary to first create a subject1 . txt file with the subject identifier of the first crab . If there are two crabs being recorded , then it is necessary to create a subject2 . txt file . And so on . The usual naming convention : 745 _003_01 @marderlab . brandeis . edu where 745 is the lab notebook , 003 is the experiment number in the lab notebook , and 01 indicates that there is only one prep in this experiment .","title":"ndi.setup.conv.marder.abf2probetable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/abf2probetable.m/#ndisetupconvmarderabf2probetable","text":"ABF2PROBETABLE - Populate a probetable table for a Marder ndi session ABF2PROBETABLE ( S ) Reads all ABF files in the NDI session S and creates a putative probetable file . To create a new Marder lab session from a directory , use S = ndi . setup . lab ( 'marderlab' , REF , DIRNAME ) It is necessary to first create a subject1 . txt file with the subject identifier of the first crab . If there are two crabs being recorded , then it is necessary to create a subject2 . txt file . And so on . The usual naming convention : 745 _003_01 @marderlab . brandeis . edu where 745 is the lab notebook , 003 is the experiment number in the lab notebook , and 01 indicates that there is only one prep in this experiment .","title":"ndi.setup.conv.marder.abf2probetable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/abfepochprobemap.m/","text":"ndi.setup.conv.marder.abfepochprobemap \u00b6 ABFEPOCHPROBEMAP - Create epochprobemap files for a Marder ndi session ABFEPOCHPROBEMAP ( S ) Reads all ABF files in the NDI session S and creates corresponding epochprobemap files . To create a new Marder lab session from a directory , use S = ndi . setup . lab ABFEPOCHPROBEMAP ( S , 'forceIgnore2' , true ) does not interpret a 2 in the channel name as a second prep . It is necessary to first create a subject1 . txt file with the subject identifier of the first crab . If there are two crabs being recorded , then it is necessary to create a subject2 . txt file . And so on . The usual naming convention : 745 _003_01 @marderlab . brandeis . edu where 745 is the lab notebook , 003 is the experiment number in the lab notebook , and 01 indicates that there is only one prep in this experiment .","title":"ndi.setup.conv.marder.abfepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/abfepochprobemap.m/#ndisetupconvmarderabfepochprobemap","text":"ABFEPOCHPROBEMAP - Create epochprobemap files for a Marder ndi session ABFEPOCHPROBEMAP ( S ) Reads all ABF files in the NDI session S and creates corresponding epochprobemap files . To create a new Marder lab session from a directory , use S = ndi . setup . lab ABFEPOCHPROBEMAP ( S , 'forceIgnore2' , true ) does not interpret a 2 in the channel name as a second prep . It is necessary to first create a subject1 . txt file with the subject identifier of the first crab . If there are two crabs being recorded , then it is necessary to create a subject2 . txt file . And so on . The usual naming convention : 745 _003_01 @marderlab . brandeis . edu where 745 is the lab notebook , 003 is the experiment number in the lab notebook , and 01 indicates that there is only one prep in this experiment .","title":"ndi.setup.conv.marder.abfepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/abfprobetable2probemap.m/","text":"ndi.setup.conv.marder.abfprobetable2probemap \u00b6 ABFPROBETABLE2PROBEMAP - Create epochprobemap files for a Marder ndi session ABFPROBETABLE2PROBEMAP ( S ) reads all ABF files within the NDI session directory specified by the ndi . session or ndi . dataset object S and generates corresponding epochprobemap files . This function utilizes the 'probetable.csv' file and any 'subject*.txt' files found in the main session directory to map recorded channels to probes and subjects . ABFPROBETABLE2PROBEMAP ( S , OPTIONS ) allows for customization of the epochprobemap creation process through a structure of name - value pair arguments . Inputs : S ( ndi . session or ndi . dataset ) An ndi . session or ndi . dataset object representing the experimental session containing the ABF data . The function will operate on the directory associated with this object . Options : 'acquisitionDelay' ( duration , default = seconds ( 0 )) A duration specifying the minimum time that must have passed since an ABF file 's creation date for it to be processed. This can be useful to avoid processing files that are still being written. 'overwrite' ( logical , default = false ) A logical flag indicating whether existing epochprobemap files should be overwritten . If true , the function will re - create epochprobemap files even if they already exist . If false , existing files will be skipped . Notes : - The 'probetable.csv' file is expected to have columns that can be used to match channel names ( found in the ABF header ) to probe information . The exact column names used for matching are determined within the NDI . SETUP . CONV . MARDER . CHANNELNAMETABLE2PROBENAME function . - The 'subject*.txt' files are expected to contain a single line with the subject 's local identifier. See also: NDI.SESSION, NDI.DATASET, NDI.EPOCH.EPOCHPROBEMAP_DAQSYSTEM, NDI.SETUP.CONV.MARDER.CHANNELNAMETABLE2PROBENAME, NDR.FORMAT.AXON.READ_ABF_HEADER","title":"ndi.setup.conv.marder.abfprobetable2probemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/abfprobetable2probemap.m/#ndisetupconvmarderabfprobetable2probemap","text":"ABFPROBETABLE2PROBEMAP - Create epochprobemap files for a Marder ndi session ABFPROBETABLE2PROBEMAP ( S ) reads all ABF files within the NDI session directory specified by the ndi . session or ndi . dataset object S and generates corresponding epochprobemap files . This function utilizes the 'probetable.csv' file and any 'subject*.txt' files found in the main session directory to map recorded channels to probes and subjects . ABFPROBETABLE2PROBEMAP ( S , OPTIONS ) allows for customization of the epochprobemap creation process through a structure of name - value pair arguments . Inputs : S ( ndi . session or ndi . dataset ) An ndi . session or ndi . dataset object representing the experimental session containing the ABF data . The function will operate on the directory associated with this object . Options : 'acquisitionDelay' ( duration , default = seconds ( 0 )) A duration specifying the minimum time that must have passed since an ABF file 's creation date for it to be processed. This can be useful to avoid processing files that are still being written. 'overwrite' ( logical , default = false ) A logical flag indicating whether existing epochprobemap files should be overwritten . If true , the function will re - create epochprobemap files even if they already exist . If false , existing files will be skipped . Notes : - The 'probetable.csv' file is expected to have columns that can be used to match channel names ( found in the ABF header ) to probe information . The exact column names used for matching are determined within the NDI . SETUP . CONV . MARDER . CHANNELNAMETABLE2PROBENAME function . - The 'subject*.txt' files are expected to contain a single line with the subject 's local identifier. See also: NDI.SESSION, NDI.DATASET, NDI.EPOCH.EPOCHPROBEMAP_DAQSYSTEM, NDI.SETUP.CONV.MARDER.CHANNELNAMETABLE2PROBENAME, NDR.FORMAT.AXON.READ_ABF_HEADER","title":"ndi.setup.conv.marder.abfprobetable2probemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/channelname2probename.m/","text":"ndi.setup.conv.marder.channelname2probename \u00b6 CHANNELNAME2PROBENAME - convert a Marder channel name to a probe name [ PROBENAME , PROBEREF , SUBJECTNAME ] = CHANNELNAME2PROBENAME ( CHNAME , SUBJECTS ) Given a channel name ( e . g ., 'DGN1_A' , 'lvn' , 'lvn2' ) , returns a probe name and subject name . PROBEREF is always 1 . If there is more than one subject ( usually a maximum of 2 ) , then the program looks for a '1' or '2' in CHNAME . If none is found , then it is assumed there is only 1 subject and 1 is the end of the string . If a 2 is found and there is no second subject , a warning is produced .","title":"ndi.setup.conv.marder.channelname2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/channelname2probename.m/#ndisetupconvmarderchannelname2probename","text":"CHANNELNAME2PROBENAME - convert a Marder channel name to a probe name [ PROBENAME , PROBEREF , SUBJECTNAME ] = CHANNELNAME2PROBENAME ( CHNAME , SUBJECTS ) Given a channel name ( e . g ., 'DGN1_A' , 'lvn' , 'lvn2' ) , returns a probe name and subject name . PROBEREF is always 1 . If there is more than one subject ( usually a maximum of 2 ) , then the program looks for a '1' or '2' in CHNAME . If none is found , then it is assumed there is only 1 subject and 1 is the end of the string . If a 2 is found and there is no second subject , a warning is produced .","title":"ndi.setup.conv.marder.channelname2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/channelnames2daqsystemstrings.m/","text":"ndi.setup.conv.marder.channelnames2daqsystemstrings \u00b6 DAQSYSSTR = CHANNELNAMES2DAQSYSTEMSTRINGS(CHNAMES, DAQNAME, SUBJECTS)","title":"ndi.setup.conv.marder.channelnames2daqsystemstrings"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/channelnames2daqsystemstrings.m/#ndisetupconvmarderchannelnames2daqsystemstrings","text":"DAQSYSSTR = CHANNELNAMES2DAQSYSTEMSTRINGS(CHNAMES, DAQNAME, SUBJECTS)","title":"ndi.setup.conv.marder.channelnames2daqsystemstrings"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/channelnametable2probename.m/","text":"ndi.setup.conv.marder.channelnametable2probename \u00b6 CHANNELNAMETABLE2PROBENAME - convert a Marder channel name to a probe name [ PROBENAME , PROBEREF , PROBETYPE , SUBJECTNAME ] = CHANNELNAMETABLE2PROBENAME ( CHNAME , PROBETABLE ) Given a channel name ( e . g ., ' DGN1_A ',' lvn ',' lvn2 '), returns a probe name and subject name . PROBEREF is always 1. The probe information is assigned according to information in PROBETABLE , a table with columns \"channelName\" , \"probeName\" , \"probeRef\" , \"probeType\" , \"subjectName\" .","title":"ndi.setup.conv.marder.channelnametable2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/channelnametable2probename.m/#ndisetupconvmarderchannelnametable2probename","text":"CHANNELNAMETABLE2PROBENAME - convert a Marder channel name to a probe name [ PROBENAME , PROBEREF , PROBETYPE , SUBJECTNAME ] = CHANNELNAMETABLE2PROBENAME ( CHNAME , PROBETABLE ) Given a channel name ( e . g ., ' DGN1_A ',' lvn ',' lvn2 '), returns a probe name and subject name . PROBEREF is always 1. The probe information is assigned according to information in PROBETABLE , a table with columns \"channelName\" , \"probeName\" , \"probeRef\" , \"probeType\" , \"subjectName\" .","title":"ndi.setup.conv.marder.channelnametable2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/demo.m/","text":"ndi.setup.conv.marder.demo \u00b6 The problem : Find all recording sessions that exhibit variation in a stimulus_parameter called 'Command temperature constant' . Sessions should be from the marderlab ( from subjects that have '@marderlab.brandeis.edu' in the 'local_identifier' field ) . Then , for each subject , plot epochs from probe that is located in the 'lateral ventricular nerve' as a function of command temperature .","title":"ndi.setup.conv.marder.demo"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/demo.m/#ndisetupconvmarderdemo","text":"The problem : Find all recording sessions that exhibit variation in a stimulus_parameter called 'Command temperature constant' . Sessions should be from the marderlab ( from subjects that have '@marderlab.brandeis.edu' in the 'local_identifier' field ) . Then , for each subject , plot epochs from probe that is located in the 'lateral ventricular nerve' as a function of command temperature .","title":"ndi.setup.conv.marder.demo"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/makeVoltageOffsets.m/","text":"ndi.setup.conv.marder.makeVoltageOffsets \u00b6 MAKEVOLTAGEOFFSETS - Make documents from a table of voltage offset values DOCLIST = MAKEVOLTAGEOFFSETS ( S ) Read in a table called \"MEoffset.txt\" that is comma separated value and has columns \"probeName\" , \"offsetV\" , and \"T\" ( for temperature ) . The function then checks to see if the offset data has been added to the database , and , if not adds it . If there is no file , then no action is taken and a warning is given . Any newly created documents are returned in DOCLIST . They will already be added to the database of session S .","title":"ndi.setup.conv.marder.makeVoltageOffsets"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/makeVoltageOffsets.m/#ndisetupconvmardermakevoltageoffsets","text":"MAKEVOLTAGEOFFSETS - Make documents from a table of voltage offset values DOCLIST = MAKEVOLTAGEOFFSETS ( S ) Read in a table called \"MEoffset.txt\" that is comma separated value and has columns \"probeName\" , \"offsetV\" , and \"T\" ( for temperature ) . The function then checks to see if the offset data has been added to the database , and , if not adds it . If there is no file , then no action is taken and a warning is given . Any newly created documents are returned in DOCLIST . They will already be added to the database of session S .","title":"ndi.setup.conv.marder.makeVoltageOffsets"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/makesubjects.m/","text":"ndi.setup.conv.marder.makesubjects \u00b6 MAKESUBJECTS - make text files for subjects MAKESUBJECTS ( S , N ) Make subject * . txt files for N subjects .","title":"ndi.setup.conv.marder.makesubjects"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/makesubjects.m/#ndisetupconvmardermakesubjects","text":"MAKESUBJECTS - make text files for subjects MAKESUBJECTS ( S , N ) Make subject * . txt files for N subjects .","title":"ndi.setup.conv.marder.makesubjects"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/marderbath.m/","text":"ndi.setup.conv.marder.marderbath \u00b6 MARDERBATH - add bath information to a Marder session D = MARDERBATH(S) Create NDI documents of type 'stimulus_bath' based on the mixture table at location [S.path filesep 'bath_table.csv']","title":"ndi.setup.conv.marder.marderbath"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/marderbath.m/#ndisetupconvmardermarderbath","text":"MARDERBATH - add bath information to a Marder session D = MARDERBATH(S) Create NDI documents of type 'stimulus_bath' based on the mixture table at location [S.path filesep 'bath_table.csv']","title":"ndi.setup.conv.marder.marderbath"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/marderprobe2uberon.m/","text":"ndi.setup.conv.marder.marderprobe2uberon \u00b6 D = MARDERPROBE2UBERON(S) Add probe_location information based on Marder probe data.","title":"ndi.setup.conv.marder.marderprobe2uberon"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/marderprobe2uberon.m/#ndisetupconvmardermarderprobe2uberon","text":"D = MARDERPROBE2UBERON(S) Add probe_location information based on Marder probe data.","title":"ndi.setup.conv.marder.marderprobe2uberon"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/mixtureStr2mixtureTable.m/","text":"ndi.setup.conv.marder.mixtureStr2mixtureTable \u00b6 MIXTURESTR2MIXTURETABLE - convert a mixture string to a mixture table T = ndi . setup . conv . marder . MIXTURESTR2MIXTURETABLE ( STR , MIXTURESTRUCT ) Converts a mixture string STR to a table of mixtures . STR is a string of the form \"v1,v2,N*v3\" , etc . It indicates what mixtures , which are fields of the MIXTURESTRUCT , are present here . MIXTURESTRUCT is a structure with fields equal to the possibly mixture type values V . The entries of MIXTURESTRUCT . V are a structure array with the following values : ontologyName : Node name of the compound in an ontology name : The name of the compound ( official name in the ontology ) value : The value of the concentration of the mixture ontologyUnit : The unit of measure , usually 'OM:MolarVolumeUnit' unitName : The name of the unit , usually 'Molar' Example : str = 'normal_saline' ; marderFolder = fullfile ( ndi . common . PathConstants . RootFolder , '+ndi' , '+setup' , '+conv' , '+marder' ); mixtureStruct = jsondecode ( fileread ( fullfile ( marderFolder , \"marder_mixtures.json\" ))); t = ndi . setup . conv . marder . mixtureStr2mixtureTable ( str , mixtureStruct ) % a table of entries","title":"ndi.setup.conv.marder.mixtureStr2mixtureTable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/mixtureStr2mixtureTable.m/#ndisetupconvmardermixturestr2mixturetable","text":"MIXTURESTR2MIXTURETABLE - convert a mixture string to a mixture table T = ndi . setup . conv . marder . MIXTURESTR2MIXTURETABLE ( STR , MIXTURESTRUCT ) Converts a mixture string STR to a table of mixtures . STR is a string of the form \"v1,v2,N*v3\" , etc . It indicates what mixtures , which are fields of the MIXTURESTRUCT , are present here . MIXTURESTRUCT is a structure with fields equal to the possibly mixture type values V . The entries of MIXTURESTRUCT . V are a structure array with the following values : ontologyName : Node name of the compound in an ontology name : The name of the compound ( official name in the ontology ) value : The value of the concentration of the mixture ontologyUnit : The unit of measure , usually 'OM:MolarVolumeUnit' unitName : The name of the unit , usually 'Molar' Example : str = 'normal_saline' ; marderFolder = fullfile ( ndi . common . PathConstants . RootFolder , '+ndi' , '+setup' , '+conv' , '+marder' ); mixtureStruct = jsondecode ( fileread ( fullfile ( marderFolder , \"marder_mixtures.json\" ))); t = ndi . setup . conv . marder . mixtureStr2mixtureTable ( str , mixtureStruct ) % a table of entries","title":"ndi.setup.conv.marder.mixtureStr2mixtureTable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/plot_epoch.m/","text":"ndi.setup.conv.marder.plot_epoch \u00b6 PLOT_EPOCH - plot an epoch","title":"ndi.setup.conv.marder.plot_epoch"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/plot_epoch.m/#ndisetupconvmarderplot_epoch","text":"PLOT_EPOCH - plot an epoch","title":"ndi.setup.conv.marder.plot_epoch"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/postsetup.m/","text":"ndi.setup.conv.marder.postsetup \u00b6 POSTSETUP - does all post - setup operations for Marder lab data POSTSETUP ( S ) 1 ) Generates epochprobemaps for ABF data 2 ) Checks that the probes are available in S 3 ) Generates the metadata with ndi . setup . conv . marder . pretemptable ( S )","title":"ndi.setup.conv.marder.postsetup"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/postsetup.m/#ndisetupconvmarderpostsetup","text":"POSTSETUP - does all post - setup operations for Marder lab data POSTSETUP ( S ) 1 ) Generates epochprobemaps for ABF data 2 ) Checks that the probes are available in S 3 ) Generates the metadata with ndi . setup . conv . marder . pretemptable ( S )","title":"ndi.setup.conv.marder.postsetup"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/postsetup2.m/","text":"ndi.setup.conv.marder.postsetup2 \u00b6 POSTSETUP - does all post - setup operations for Marder lab data POSTSETUP ( S ) 1 ) Generates epochprobemaps for ABF data 2 ) Checks that the probes are available in S 3 ) Generates the metadata with ndi . setup . conv . marder . bath . preptemptable ( S )","title":"ndi.setup.conv.marder.postsetup2"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/postsetup2.m/#ndisetupconvmarderpostsetup2","text":"POSTSETUP - does all post - setup operations for Marder lab data POSTSETUP ( S ) 1 ) Generates epochprobemaps for ABF data 2 ) Checks that the probes are available in S 3 ) Generates the metadata with ndi . setup . conv . marder . bath . preptemptable ( S )","title":"ndi.setup.conv.marder.postsetup2"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/preptemp.m/","text":"ndi.setup.conv.marder.preptemp \u00b6 PREPTEMP - identify temperature parameters for a temperature record OUT = PREPTEMP ( T , D , TEMP_TABLE , ... ) Identify the temperature of a Marder lab record . The timestamps of the record are provided in T , and the data in degrees C are provided in D . The program attempts to identify which of several command temperatures in TEMP_TABLE are employed in the record . The record is categorized as 'constant' or 'change' if the record exhibits a change greater than 'change_threshold' . OUT is a structure with fields : 'type' : takes the value 'constant or ' change ' 'temp' : that contains the values in TEMP_TABLE that most closely match the record . In the case of a 'constant' record , 'temp' will have one value ; in the case of a 'change' record , it will have two values ( the beginning and end values ) . 'raw' : the raw temperature values before they are translated to table entries . 'range' : the observed temperature range The function takes name / value pairs that modify its default behavior : |----------------------------|--------------------------------------| | Parameter ( default ) | Description | |----------------------------|--------------------------------------| | change_threshold ( 3 ) | Threshold at which to describe the | | | record as a 'change' . | | beginning_time ( 2 ) | Time in seconds that constitutes the | | | beginning of the record . | | ending_time ( 2 ) | Time in seconds from the end of the | | | record that constitutes the ending | | | time to be averaged . | | filter ( ones ( 5 , 1 ) / 5 ) | A convolution filter to smooth data | | interactive ( false ) | Should we ask the user for input ? | |----------------------------|--------------------------------------|","title":"ndi.setup.conv.marder.preptemp"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/preptemp.m/#ndisetupconvmarderpreptemp","text":"PREPTEMP - identify temperature parameters for a temperature record OUT = PREPTEMP ( T , D , TEMP_TABLE , ... ) Identify the temperature of a Marder lab record . The timestamps of the record are provided in T , and the data in degrees C are provided in D . The program attempts to identify which of several command temperatures in TEMP_TABLE are employed in the record . The record is categorized as 'constant' or 'change' if the record exhibits a change greater than 'change_threshold' . OUT is a structure with fields : 'type' : takes the value 'constant or ' change ' 'temp' : that contains the values in TEMP_TABLE that most closely match the record . In the case of a 'constant' record , 'temp' will have one value ; in the case of a 'change' record , it will have two values ( the beginning and end values ) . 'raw' : the raw temperature values before they are translated to table entries . 'range' : the observed temperature range The function takes name / value pairs that modify its default behavior : |----------------------------|--------------------------------------| | Parameter ( default ) | Description | |----------------------------|--------------------------------------| | change_threshold ( 3 ) | Threshold at which to describe the | | | record as a 'change' . | | beginning_time ( 2 ) | Time in seconds that constitutes the | | | beginning of the record . | | ending_time ( 2 ) | Time in seconds from the end of the | | | record that constitutes the ending | | | time to be averaged . | | filter ( ones ( 5 , 1 ) / 5 ) | A convolution filter to smooth data | | interactive ( false ) | Should we ask the user for input ? | |----------------------------|--------------------------------------|","title":"ndi.setup.conv.marder.preptemp"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/preptemptable.m/","text":"ndi.setup.conv.marder.preptemptable \u00b6 PREPTEMPTABLE - write a prep temperature table to the session directory PREPTEMPTABLE(S) Write a temperature table to the session directory.","title":"ndi.setup.conv.marder.preptemptable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/preptemptable.m/#ndisetupconvmarderpreptemptable","text":"PREPTEMPTABLE - write a prep temperature table to the session directory PREPTEMPTABLE(S) Write a temperature table to the session directory.","title":"ndi.setup.conv.marder.preptemptable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/presetup.m/","text":"ndi.setup.conv.marder.presetup \u00b6 PRESETUP - set up the Marder lab directory based on the directory name S = PRESETUP ( DIRNAME , N , Name , Value , ... ) Sets up a Marderlab directory for import using NDI methods . Inputs : DIRNAME - The full path to the directory to be set up . Must be a valid folder . N - An integer identifier ( e . g . , experiment number ), must be >= 1. Optional Name - Value Pair Arguments : makeSubjects ( logical ) - If true , creates subject entries based on N . Defaults to false . makeProbeTable ( logical ) - If true , generates the probeTable . csv file from .abf files and opens it for editing . Defaults to true . Outputs : S - The NDI session object for the created / configured directory . Example : % Basic setup , creates probe table by default S = presetup ( '/path/to/my/experiment' , 1 ); % Setup without creating probe table S = presetup ( '/path/to/my/experiment' , 2 , 'makeProbeTable' , false ); % Setup and create subject entries S = presetup ( '/path/to/my/experiment' , 3 , 'makeSubjects' , true );","title":"ndi.setup.conv.marder.presetup"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/presetup.m/#ndisetupconvmarderpresetup","text":"PRESETUP - set up the Marder lab directory based on the directory name S = PRESETUP ( DIRNAME , N , Name , Value , ... ) Sets up a Marderlab directory for import using NDI methods . Inputs : DIRNAME - The full path to the directory to be set up . Must be a valid folder . N - An integer identifier ( e . g . , experiment number ), must be >= 1. Optional Name - Value Pair Arguments : makeSubjects ( logical ) - If true , creates subject entries based on N . Defaults to false . makeProbeTable ( logical ) - If true , generates the probeTable . csv file from .abf files and opens it for editing . Defaults to true . Outputs : S - The NDI session object for the created / configured directory . Example : % Basic setup , creates probe table by default S = presetup ( '/path/to/my/experiment' , 1 ); % Setup without creating probe table S = presetup ( '/path/to/my/experiment' , 2 , 'makeProbeTable' , false ); % Setup and create subject entries S = presetup ( '/path/to/my/experiment' , 3 , 'makeSubjects' , true );","title":"ndi.setup.conv.marder.presetup"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/setupInteractive.m/","text":"ndi.setup.conv.marder.setupInteractive \u00b6 SETUPINTERACTIVE - an interactive version of presetup S = SETUPINTERACTIVE ( DIRNAME ) Interactively sets up a Marderlab directory for import using NDI methods . Inputs : DIRNAME - The full path to the directory to be set up . Must be a valid folder . If not provided , the current working directory is used . Outputs : S - The NDI session object for the created / configured directory .","title":"ndi.setup.conv.marder.setupInteractive"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/setupInteractive.m/#ndisetupconvmardersetupinteractive","text":"SETUPINTERACTIVE - an interactive version of presetup S = SETUPINTERACTIVE ( DIRNAME ) Interactively sets up a Marderlab directory for import using NDI methods . Inputs : DIRNAME - The full path to the directory to be set up . Must be a valid folder . If not provided , the current working directory is used . Outputs : S - The NDI session object for the created / configured directory .","title":"ndi.setup.conv.marder.setupInteractive"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/smrepochprobemap.m/","text":"ndi.setup.conv.marder.smrepochprobemap \u00b6 SMREPOCHPROBEMAP - Create epochprobemap files for a Marder SMR directory SMREPOCHPROBEMAP ( DIRNAME ) Reads all SMR files in DIRNAME and creates corresponding epochprobemap files .","title":"ndi.setup.conv.marder.smrepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/smrepochprobemap.m/#ndisetupconvmardersmrepochprobemap","text":"SMREPOCHPROBEMAP - Create epochprobemap files for a Marder SMR directory SMREPOCHPROBEMAP ( DIRNAME ) Reads all SMR files in DIRNAME and creates corresponding epochprobemap files .","title":"ndi.setup.conv.marder.smrepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/temptable2stimulusparameters.m/","text":"ndi.setup.conv.marder.temptable2stimulusparameters \u00b6 TEMPTABLE2STIMULUSPARAMETERS - Create stimulusparameter documents for temperature for a Marder ndi session TEMPTABLE2STIMULUSPARAMETERS ( S )","title":"ndi.setup.conv.marder.temptable2stimulusparameters"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/temptable2stimulusparameters.m/#ndisetupconvmardertemptable2stimulusparameters","text":"TEMPTABLE2STIMULUSPARAMETERS - Create stimulusparameter documents for temperature for a Marder ndi session TEMPTABLE2STIMULUSPARAMETERS ( S )","title":"ndi.setup.conv.marder.temptable2stimulusparameters"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/marderbath.m/","text":"ndi.setup.conv.marder.bath.marderbath \u00b6 MARDERBATH - Create NDI documents for bath stimulation information . D = MARDERBATH ( S ) Creates NDI documents of type 'stimulus_bath' for a Marder Lab session . This function reads a 'bath_table.csv' file from the session directory , which specifies the chemical mixtures applied to the bath and the epochs during which they were active . It uses helper JSON files ( 'marder_mixtures.json' and 'marder_bathtargets.json' ) to look up detailed information about the mixtures and their target locations . The function generates a 'stimulus_bath' document for each epoch and stimulus combination defined in the bath table , linking them to the appropriate stimulus elements and anatomical locations ( via UBERON ontology ). INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : d : ( cell array of ndi . document ) A cell array of the newly created 'stimulus_bath' documents . Note : These documents are NOT automatically added to the database . REQUIRED FILES : - [ session_path ]/ bath_table . csv : A table defining bath applications . Columns should include \"firstFile\" , \"lastFile\" , \"bathTargets\" , \"mixtures\" . - [ toolbox_path ]/+ ndi /+ setup /+ conv /+ marder /+ bath / marder_mixtures . json : Defines the composition of chemical mixtures . - [ toolbox_path ]/+ ndi /+ setup /+ conv /+ marder /+ bath / marder_bathtargets . json : Maps target names to UBERON ontology identifiers . EXAMPLE : % Assuming S is a valid NDI session object and bath_table . csv exists bath_docs = ndi . setup . conv . marder . bath . marderbath ( S ); S . database_add ( bath_docs ); % Add the new documents to the database See also : ndi . setup . conv . marder . bath . mixtureStr2mixtureTable , ndi . database . fun . uberon_ontology_lookup","title":"ndi.setup.conv.marder.bath.marderbath"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/marderbath.m/#ndisetupconvmarderbathmarderbath","text":"MARDERBATH - Create NDI documents for bath stimulation information . D = MARDERBATH ( S ) Creates NDI documents of type 'stimulus_bath' for a Marder Lab session . This function reads a 'bath_table.csv' file from the session directory , which specifies the chemical mixtures applied to the bath and the epochs during which they were active . It uses helper JSON files ( 'marder_mixtures.json' and 'marder_bathtargets.json' ) to look up detailed information about the mixtures and their target locations . The function generates a 'stimulus_bath' document for each epoch and stimulus combination defined in the bath table , linking them to the appropriate stimulus elements and anatomical locations ( via UBERON ontology ). INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : d : ( cell array of ndi . document ) A cell array of the newly created 'stimulus_bath' documents . Note : These documents are NOT automatically added to the database . REQUIRED FILES : - [ session_path ]/ bath_table . csv : A table defining bath applications . Columns should include \"firstFile\" , \"lastFile\" , \"bathTargets\" , \"mixtures\" . - [ toolbox_path ]/+ ndi /+ setup /+ conv /+ marder /+ bath / marder_mixtures . json : Defines the composition of chemical mixtures . - [ toolbox_path ]/+ ndi /+ setup /+ conv /+ marder /+ bath / marder_bathtargets . json : Maps target names to UBERON ontology identifiers . EXAMPLE : % Assuming S is a valid NDI session object and bath_table . csv exists bath_docs = ndi . setup . conv . marder . bath . marderbath ( S ); S . database_add ( bath_docs ); % Add the new documents to the database See also : ndi . setup . conv . marder . bath . mixtureStr2mixtureTable , ndi . database . fun . uberon_ontology_lookup","title":"ndi.setup.conv.marder.bath.marderbath"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/mixtureStr2mixtureTable.m/","text":"ndi.setup.conv.marder.bath.mixtureStr2mixtureTable \u00b6 MIXTURESTR2MIXTURETABLE - Convert a mixture string to a detailed mixture table . T = MIXTURESTR2MIXTURETABLE ( STR , MIXTURESTRUCT ) Converts a compact mixture string into a detailed table of chemical components and their concentrations . The function parses the string , looks up component definitions in a provided structure , and calculates final concentrations . INPUTS : str : ( string ) A comma - separated string describing the mixture . Each element can be a mixture name ( e . g ., 'normal_saline' ) or a mixture name with a multiplier ( e . g ., '2*picrotoxin' ). mixtureStruct : ( struct ) A structure where each field is a mixture name ( e . g ., 'normal_saline' ). The value of each field is a structure array defining the components of that mixture , with the following fields : - ontologyName : The ontology identifier for the compound ( e . g ., 'CHEBI:28997' ). - name : The common name of the compound ( e . g ., 'picrotoxin' ). - value : The base concentration of the compound . - ontologyUnit : The ontology identifier for the unit ( e . g ., 'OM:MolarVolumeUnit' ). - unitName : The common name of the unit ( e . g ., 'Molar' ). OUTPUTS : t : ( table ) A table listing all components from the resolved mixture string , with columns : \"ontologyName\" , \"name\" , \"value\" ( final calculated concentration ), \"ontologyUnit\" , and \"unitName\" . EXAMPLE : str = 'normal_saline,2*picrotoxin' ; marderFolder = fullfile ( fileparts ( mfilename ( 'fullpath' ))); mixtureStruct = jsondecode ( fileread ( fullfile ( marderFolder , \"marder_mixtures.json\" ))); t = ndi . setup . conv . marder . bath . mixtureStr2mixtureTable ( str , mixtureStruct ); % t will be a table containing all components of normal_saline and % picrotoxin at twice its base concentration. See also : jsondecode , readtable","title":"ndi.setup.conv.marder.bath.mixtureStr2mixtureTable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/mixtureStr2mixtureTable.m/#ndisetupconvmarderbathmixturestr2mixturetable","text":"MIXTURESTR2MIXTURETABLE - Convert a mixture string to a detailed mixture table . T = MIXTURESTR2MIXTURETABLE ( STR , MIXTURESTRUCT ) Converts a compact mixture string into a detailed table of chemical components and their concentrations . The function parses the string , looks up component definitions in a provided structure , and calculates final concentrations . INPUTS : str : ( string ) A comma - separated string describing the mixture . Each element can be a mixture name ( e . g ., 'normal_saline' ) or a mixture name with a multiplier ( e . g ., '2*picrotoxin' ). mixtureStruct : ( struct ) A structure where each field is a mixture name ( e . g ., 'normal_saline' ). The value of each field is a structure array defining the components of that mixture , with the following fields : - ontologyName : The ontology identifier for the compound ( e . g ., 'CHEBI:28997' ). - name : The common name of the compound ( e . g ., 'picrotoxin' ). - value : The base concentration of the compound . - ontologyUnit : The ontology identifier for the unit ( e . g ., 'OM:MolarVolumeUnit' ). - unitName : The common name of the unit ( e . g ., 'Molar' ). OUTPUTS : t : ( table ) A table listing all components from the resolved mixture string , with columns : \"ontologyName\" , \"name\" , \"value\" ( final calculated concentration ), \"ontologyUnit\" , and \"unitName\" . EXAMPLE : str = 'normal_saline,2*picrotoxin' ; marderFolder = fullfile ( fileparts ( mfilename ( 'fullpath' ))); mixtureStruct = jsondecode ( fileread ( fullfile ( marderFolder , \"marder_mixtures.json\" ))); t = ndi . setup . conv . marder . bath . mixtureStr2mixtureTable ( str , mixtureStruct ); % t will be a table containing all components of normal_saline and % picrotoxin at twice its base concentration. See also : jsondecode , readtable","title":"ndi.setup.conv.marder.bath.mixtureStr2mixtureTable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/preptemp.m/","text":"ndi.setup.conv.marder.bath.preptemp \u00b6 PREPTEMP - Identify temperature parameters from a temperature recording . OUT = PREPTEMP ( T , D , TEMP_TABLE , [ OPTIONS ] ) Analyzes a temperature recording to determine if it represents a constant temperature or a temperature change . It matches the observed temperatures to a provided table of command temperatures . INPUTS : t : ( array ) A vector of timestamps for the temperature data . d : ( array ) A vector of temperature data in degrees Celsius . temp_table : ( array ) A vector of possible command temperatures . OPTIONS : ( Optional ) A struct with the following fields : change_threshold : ( double ) The temperature range threshold to classify a recording as a 'change' . Default is 3. beginning_time : ( double ) The duration in seconds at the start of the record to average for the initial temperature . Default is 2. ending_time : ( double ) The duration in seconds at the end of the record to average for the final temperature . Default is 2. filter : ( array ) A convolution filter to smooth the temperature data . Default is ` ones ( 5 , 1 ) / 5 ` . interactive : ( logical ) If true , prompts the user for input . Default is false . OUTPUTS : out : ( struct ) A structure containing the analysis results , with fields : type : ( 'constant' or 'change' ) The classification of the recording . temp : ( array ) The matching command temperature ( s ) from temp_table . One value for 'constant' , two for 'change' ( start and end ). raw : ( array ) The raw ( averaged ) temperature value ( s ). range : ( double ) The observed temperature range in the recording . EXAMPLE : t = 0 : 0.1 : 10 ; d = 10 + 15 * ( t / 10 ); % Ramp from 10 to 25 degrees temp_table = [ 10, 15, 20, 25 ] ; out = ndi . setup . conv . marder . bath . preptemp ( t , d , temp_table ); % out . type will be 'change' % out . temp will be [ 10 25 ] See also : ndi . setup . conv . marder . bath . preptemptable , conv , vlt . data . findclosest","title":"ndi.setup.conv.marder.bath.preptemp"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/preptemp.m/#ndisetupconvmarderbathpreptemp","text":"PREPTEMP - Identify temperature parameters from a temperature recording . OUT = PREPTEMP ( T , D , TEMP_TABLE , [ OPTIONS ] ) Analyzes a temperature recording to determine if it represents a constant temperature or a temperature change . It matches the observed temperatures to a provided table of command temperatures . INPUTS : t : ( array ) A vector of timestamps for the temperature data . d : ( array ) A vector of temperature data in degrees Celsius . temp_table : ( array ) A vector of possible command temperatures . OPTIONS : ( Optional ) A struct with the following fields : change_threshold : ( double ) The temperature range threshold to classify a recording as a 'change' . Default is 3. beginning_time : ( double ) The duration in seconds at the start of the record to average for the initial temperature . Default is 2. ending_time : ( double ) The duration in seconds at the end of the record to average for the final temperature . Default is 2. filter : ( array ) A convolution filter to smooth the temperature data . Default is ` ones ( 5 , 1 ) / 5 ` . interactive : ( logical ) If true , prompts the user for input . Default is false . OUTPUTS : out : ( struct ) A structure containing the analysis results , with fields : type : ( 'constant' or 'change' ) The classification of the recording . temp : ( array ) The matching command temperature ( s ) from temp_table . One value for 'constant' , two for 'change' ( start and end ). raw : ( array ) The raw ( averaged ) temperature value ( s ). range : ( double ) The observed temperature range in the recording . EXAMPLE : t = 0 : 0.1 : 10 ; d = 10 + 15 * ( t / 10 ); % Ramp from 10 to 25 degrees temp_table = [ 10, 15, 20, 25 ] ; out = ndi . setup . conv . marder . bath . preptemp ( t , d , temp_table ); % out . type will be 'change' % out . temp will be [ 10 25 ] See also : ndi . setup . conv . marder . bath . preptemptable , conv , vlt . data . findclosest","title":"ndi.setup.conv.marder.bath.preptemp"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/preptemptable.m/","text":"ndi.setup.conv.marder.bath.preptemptable \u00b6 PREPTEMPTABLE - Create and save a temperature analysis table for an NDI session . PREPTEMPTABLE ( S ) Analyzes temperature data for all 'thermometer' probes in an NDI session . For each epoch of each thermometer probe , it reads the temperature time series and uses ` ndi . setup . conv . marder . bath . preptemp ` to classify the temperature profile as 'constant' or 'change' and identify the command temperatures . The results are compiled into a table and saved as 'temptable.mat' in the session directory . INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : This function does not return any values but writes a 'temptable.mat' file in the session directory . The file contains a single table variable named 'temptable' with the following columns : - probe_id : The ID of the thermometer probe . - epoch_id : The ID of the recording epoch . - type : 'constant' or 'change' . - temp : The identified command temperature ( s ) . - raw : The raw averaged temperature ( s ) . EXAMPLE : % Assuming S is a valid NDI session with thermometer probes and data ndi . setup . conv . marder . bath . preptemptable ( S ); % This will create 'temptable.mat' in the session directory . load ( fullfile ( S . getpath (), 'temptable.mat' )); disp ( temptable ); See also : ndi . setup . conv . marder . bath . preptemp , save , load","title":"ndi.setup.conv.marder.bath.preptemptable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/preptemptable.m/#ndisetupconvmarderbathpreptemptable","text":"PREPTEMPTABLE - Create and save a temperature analysis table for an NDI session . PREPTEMPTABLE ( S ) Analyzes temperature data for all 'thermometer' probes in an NDI session . For each epoch of each thermometer probe , it reads the temperature time series and uses ` ndi . setup . conv . marder . bath . preptemp ` to classify the temperature profile as 'constant' or 'change' and identify the command temperatures . The results are compiled into a table and saved as 'temptable.mat' in the session directory . INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : This function does not return any values but writes a 'temptable.mat' file in the session directory . The file contains a single table variable named 'temptable' with the following columns : - probe_id : The ID of the thermometer probe . - epoch_id : The ID of the recording epoch . - type : 'constant' or 'change' . - temp : The identified command temperature ( s ) . - raw : The raw averaged temperature ( s ) . EXAMPLE : % Assuming S is a valid NDI session with thermometer probes and data ndi . setup . conv . marder . bath . preptemptable ( S ); % This will create 'temptable.mat' in the session directory . load ( fullfile ( S . getpath (), 'temptable.mat' )); disp ( temptable ); See also : ndi . setup . conv . marder . bath . preptemp , save , load","title":"ndi.setup.conv.marder.bath.preptemptable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/temptable2stimulusparameters.m/","text":"ndi.setup.conv.marder.bath.temptable2stimulusparameters \u00b6 TEMPTABLE2STIMULUSPARAMETERS - Create stimulus parameter documents from a temperature table . DOCS = TEMPTABLE2STIMULUSPARAMETERS ( S ) Creates 'stimulus_parameter' NDI documents based on the analysis of temperature data stored in 'temptable.mat' . This function links temperature command values to stimulus epochs . The function loads 'temptable.mat' , which is generated by ` ndi . setup . conv . marder . bath . preptemptable ` . For each epoch of each 'stimulator' probe , it finds the corresponding temperature information and creates NDI documents that describe the temperature stimulus parameters ( e . g . , 'Command temperature constant' , 'Command temperature start' ) . If an epoch does not have a direct temperature measurement , it uses the measurement from the most recent preceding epoch that did . INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : docs : ( cell array of ndi . document ) A cell array of the newly created 'stimulus_parameter' documents . Note : These documents are NOT automatically added to the database . REQUIRED FILES : - [ session_path ] / temptable . mat : A MAT - file containing the 'temptable' variable , generated by ` ndi . setup . conv . marder . bath . preptemptable ` . EXAMPLE : % First , generate the temperature table ndi . setup . conv . marder . bath . preptemptable ( S ); % Then , create the stimulus parameter documents stim_docs = ndi . setup . conv . marder . bath . temptable2stimulusparameters ( S ); S . database_add ( stim_docs ); % Add the new documents to the database See also : ndi . setup . conv . marder . bath . preptemptable , ndi . document","title":"ndi.setup.conv.marder.bath.temptable2stimulusparameters"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/temptable2stimulusparameters.m/#ndisetupconvmarderbathtemptable2stimulusparameters","text":"TEMPTABLE2STIMULUSPARAMETERS - Create stimulus parameter documents from a temperature table . DOCS = TEMPTABLE2STIMULUSPARAMETERS ( S ) Creates 'stimulus_parameter' NDI documents based on the analysis of temperature data stored in 'temptable.mat' . This function links temperature command values to stimulus epochs . The function loads 'temptable.mat' , which is generated by ` ndi . setup . conv . marder . bath . preptemptable ` . For each epoch of each 'stimulator' probe , it finds the corresponding temperature information and creates NDI documents that describe the temperature stimulus parameters ( e . g . , 'Command temperature constant' , 'Command temperature start' ) . If an epoch does not have a direct temperature measurement , it uses the measurement from the most recent preceding epoch that did . INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : docs : ( cell array of ndi . document ) A cell array of the newly created 'stimulus_parameter' documents . Note : These documents are NOT automatically added to the database . REQUIRED FILES : - [ session_path ] / temptable . mat : A MAT - file containing the 'temptable' variable , generated by ` ndi . setup . conv . marder . bath . preptemptable ` . EXAMPLE : % First , generate the temperature table ndi . setup . conv . marder . bath . preptemptable ( S ); % Then , create the stimulus parameter documents stim_docs = ndi . setup . conv . marder . bath . temptable2stimulusparameters ( S ); S . database_add ( stim_docs ); % Add the new documents to the database See also : ndi . setup . conv . marder . bath . preptemptable , ndi . document","title":"ndi.setup.conv.marder.bath.temptable2stimulusparameters"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abf2probetable.m/","text":"ndi.setup.conv.marder.probeMap.abf2probetable \u00b6 ABF2PROBETABLE - Create a probetable from Axon Binary Files ( ABF ). PROBETABLE = ABF2PROBETABLE ( S , [ OPTIONS ]) Creates a Matlab table object ( 'probetable' ) for a Marder Lab NDI session by reading metadata from all Axon Binary Files ( * . abf ) in the session directory . The function identifies channel information , probe types , and subject associations to create a comprehensive probe table . This function assumes that the NDI session ` S ` has been created and that the session path contains the ABF files . It also relies on 'subject*.txt' files to identify the subjects for the experiment . INPUTS : S : An NDI_SESSION object representing the Marder Lab session . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , forces the function to ignore the second character in channel names when mapping to probe information . Default is false . defaultProbeType : ( string ) The default probe type to use when a channel cannot be identified . Can be 'n-trode' or 'ppg' . Default is 'n-trode' . OUTPUTS : PROBETABLE : A Matlab table with the following columns : - channelName : The name of the channel from the ABF file . - probeName : The standardized name of the probe . - probeRef : The reference number for the probe . - probeType : The type of probe ( e . g ., 'sharp-Vm' , 'n-trode' ). - subject : The identifier for the subject associated with the probe . - firstAppears : The name of the ABF file where the channel first appears . EXAMPLE : % Create a new Marder Lab session ref = 'ML001' ; dirname = '/path/to/marder/data' ; S = ndi . setup . lab ( 'marderlab' , ref , dirname ); % Create the probe table probetable = ndi . setup . conv . marder . probeMap . abf2probetable ( S ); % Write the table to a file writetable ( probetable , [ dirname filesep 'probeTable.csv' ]); See also: ndi.setup.lab, ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings","title":"ndi.setup.conv.marder.probeMap.abf2probetable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abf2probetable.m/#ndisetupconvmarderprobemapabf2probetable","text":"ABF2PROBETABLE - Create a probetable from Axon Binary Files ( ABF ). PROBETABLE = ABF2PROBETABLE ( S , [ OPTIONS ]) Creates a Matlab table object ( 'probetable' ) for a Marder Lab NDI session by reading metadata from all Axon Binary Files ( * . abf ) in the session directory . The function identifies channel information , probe types , and subject associations to create a comprehensive probe table . This function assumes that the NDI session ` S ` has been created and that the session path contains the ABF files . It also relies on 'subject*.txt' files to identify the subjects for the experiment . INPUTS : S : An NDI_SESSION object representing the Marder Lab session . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , forces the function to ignore the second character in channel names when mapping to probe information . Default is false . defaultProbeType : ( string ) The default probe type to use when a channel cannot be identified . Can be 'n-trode' or 'ppg' . Default is 'n-trode' . OUTPUTS : PROBETABLE : A Matlab table with the following columns : - channelName : The name of the channel from the ABF file . - probeName : The standardized name of the probe . - probeRef : The reference number for the probe . - probeType : The type of probe ( e . g ., 'sharp-Vm' , 'n-trode' ). - subject : The identifier for the subject associated with the probe . - firstAppears : The name of the ABF file where the channel first appears . EXAMPLE : % Create a new Marder Lab session ref = 'ML001' ; dirname = '/path/to/marder/data' ; S = ndi . setup . lab ( 'marderlab' , ref , dirname ); % Create the probe table probetable = ndi . setup . conv . marder . probeMap . abf2probetable ( S ); % Write the table to a file writetable ( probetable , [ dirname filesep 'probeTable.csv' ]); See also: ndi.setup.lab, ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings","title":"ndi.setup.conv.marder.probeMap.abf2probetable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abfepochprobemap.m/","text":"ndi.setup.conv.marder.probeMap.abfepochprobemap \u00b6 ABFEPOCHPROBEMAP - Create epochprobemap files from Axon Binary Files ( ABF ). ABFEPOCHPROBEMAP ( S , [ OPTIONS ]) Creates '.epochprobemap.txt' files for a Marder Lab NDI session by reading metadata from all Axon Binary Files ( * . abf ) in the session directory . These map files link recording channels to probe information for each epoch . This function assumes that the NDI session ` S ` has been created and that the session path contains the ABF files . It also relies on 'subject*.txt' files to identify the subjects for the experiment and adds them to the NDI database if they do not already exist . INPUTS : S : An NDI_SESSION object representing the Marder Lab session . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , forces the function to ignore the second character in channel names when mapping to probe information , preventing misinterpretation as a second prep . Default is false . OUTPUTS : This function does not return any values but writes a '.epochprobemap.txt' file for each ABF file in the session directory . These files define the relationship between data channels and experimental probes for each recording epoch . EXAMPLE : % Create a new Marder Lab session ref = 'ML001' ; dirname = '/path/to/marder/data' ; S = ndi . setup . lab ( 'marderlab' , ref , dirname ); % Create the epochprobemap files ndi . setup . conv . marder . probeMap . abfepochprobemap ( S ); See also: ndi.setup.lab, ndi.epoch.epochprobemap_daqsystem, ndr.format.axon.read_abf_header","title":"ndi.setup.conv.marder.probeMap.abfepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abfepochprobemap.m/#ndisetupconvmarderprobemapabfepochprobemap","text":"ABFEPOCHPROBEMAP - Create epochprobemap files from Axon Binary Files ( ABF ). ABFEPOCHPROBEMAP ( S , [ OPTIONS ]) Creates '.epochprobemap.txt' files for a Marder Lab NDI session by reading metadata from all Axon Binary Files ( * . abf ) in the session directory . These map files link recording channels to probe information for each epoch . This function assumes that the NDI session ` S ` has been created and that the session path contains the ABF files . It also relies on 'subject*.txt' files to identify the subjects for the experiment and adds them to the NDI database if they do not already exist . INPUTS : S : An NDI_SESSION object representing the Marder Lab session . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , forces the function to ignore the second character in channel names when mapping to probe information , preventing misinterpretation as a second prep . Default is false . OUTPUTS : This function does not return any values but writes a '.epochprobemap.txt' file for each ABF file in the session directory . These files define the relationship between data channels and experimental probes for each recording epoch . EXAMPLE : % Create a new Marder Lab session ref = 'ML001' ; dirname = '/path/to/marder/data' ; S = ndi . setup . lab ( 'marderlab' , ref , dirname ); % Create the epochprobemap files ndi . setup . conv . marder . probeMap . abfepochprobemap ( S ); See also: ndi.setup.lab, ndi.epoch.epochprobemap_daqsystem, ndr.format.axon.read_abf_header","title":"ndi.setup.conv.marder.probeMap.abfepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abfprobetable2probemap.m/","text":"ndi.setup.conv.marder.probeMap.abfprobetable2probemap \u00b6 ABFPROBETABLE2PROBEMAP - Create epochprobemap files from a probe table . ABFPROBETABLE2PROBEMAP ( S , [ OPTIONS ]) Creates '.epochprobemap.txt' files for a Marder Lab NDI session . This function reads all Axon Binary Files ( * . abf ) in the session directory and uses a 'probeTable.csv' file to map recording channels to probes and subjects for each epoch . This function is essential for linking the raw data channels in ABF files to the higher - level probe and subject information managed by NDI . INPUTS : S : ( ndi . session or ndi . dataset ) An NDI session or dataset object . The function operates on the directory associated with this object . OPTIONS : ( Optional ) A struct with the following fields : acquisitionDelay : ( duration ) The minimum time that must have passed since an ABF file ' s creation to be processed . Useful for avoiding incomplete files . Default is ` seconds ( 0 ) ` . overwrite : ( logical ) If true , existing epochprobemap files will be overwritten . If false , they will be skipped . Default is ` false ` . OUTPUTS : This function does not return any values but writes a '.epochprobemap.txt' file for each new or specified ABF file in the session directory . EXAMPLE : % Assuming S is a valid NDI session object % Create epochprobemap files for all new ABF files ndi . setup . conv . marder . probeMap . abfprobetable2probemap ( S ); % Overwrite all existing epochprobemap files ndi . setup . conv . marder . probeMap . abfprobetable2probemap ( S , 'overwrite' , true ); See also: ndi.session, ndi.dataset, ndi.epoch.epochprobemap_daqsystem, ndi . setup . conv . marder . probeMap . channelnametable2probename , ndr . format . axon . read_abf_header","title":"ndi.setup.conv.marder.probeMap.abfprobetable2probemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abfprobetable2probemap.m/#ndisetupconvmarderprobemapabfprobetable2probemap","text":"ABFPROBETABLE2PROBEMAP - Create epochprobemap files from a probe table . ABFPROBETABLE2PROBEMAP ( S , [ OPTIONS ]) Creates '.epochprobemap.txt' files for a Marder Lab NDI session . This function reads all Axon Binary Files ( * . abf ) in the session directory and uses a 'probeTable.csv' file to map recording channels to probes and subjects for each epoch . This function is essential for linking the raw data channels in ABF files to the higher - level probe and subject information managed by NDI . INPUTS : S : ( ndi . session or ndi . dataset ) An NDI session or dataset object . The function operates on the directory associated with this object . OPTIONS : ( Optional ) A struct with the following fields : acquisitionDelay : ( duration ) The minimum time that must have passed since an ABF file ' s creation to be processed . Useful for avoiding incomplete files . Default is ` seconds ( 0 ) ` . overwrite : ( logical ) If true , existing epochprobemap files will be overwritten . If false , they will be skipped . Default is ` false ` . OUTPUTS : This function does not return any values but writes a '.epochprobemap.txt' file for each new or specified ABF file in the session directory . EXAMPLE : % Assuming S is a valid NDI session object % Create epochprobemap files for all new ABF files ndi . setup . conv . marder . probeMap . abfprobetable2probemap ( S ); % Overwrite all existing epochprobemap files ndi . setup . conv . marder . probeMap . abfprobetable2probemap ( S , 'overwrite' , true ); See also: ndi.session, ndi.dataset, ndi.epoch.epochprobemap_daqsystem, ndi . setup . conv . marder . probeMap . channelnametable2probename , ndr . format . axon . read_abf_header","title":"ndi.setup.conv.marder.probeMap.abfprobetable2probemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelname2probename.m/","text":"ndi.setup.conv.marder.probeMap.channelname2probename \u00b6 CHANNELNAME2PROBENAME - Convert a Marder Lab channel name to a standardized probe name . [ PROBENAME, PROBEREF, SUBJECTNAME ] = CHANNELNAME2PROBENAME ( CHNAME , SUBJECTS , [ OPTIONS ] ) Converts a raw channel name from a Marder Lab recording ( e . g ., 'DGN1_A' , 'lvn' , 'lvn2' ) into a standardized probe name , probe reference number , and associated subject name . This function identifies the subject by searching for '1' or '2' in the channel name . If neither is found , it defaults to the first subject . INPUTS : chName : ( string ) The channel name to be converted . subjects : ( cell array of strings ) A list of subject identifiers . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , ignores '2' in the channel name and assigns the channel to the first subject . Default is false . OUTPUTS : probename : ( string ) The standardized probe name ( e . g ., 'dgn_1' , 'lvn_2' ). If no standard name is found , it returns a MATLAB - validated version of the input channel name . proberef : ( double ) The reference number for the probe , always 1. subjectname : ( string ) The identifier of the subject associated with the channel . EXAMPLE : subjects = { 'crab1' , 'crab2' } ; [ p_name, p_ref, s_name ] = ndi . setup . conv . marder . probeMap . channelname2probename ( 'dgn2_A' , subjects ) % p_name = 'dgn_2' % p_ref = 1 % s_name = 'crab2'","title":"ndi.setup.conv.marder.probeMap.channelname2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelname2probename.m/#ndisetupconvmarderprobemapchannelname2probename","text":"CHANNELNAME2PROBENAME - Convert a Marder Lab channel name to a standardized probe name . [ PROBENAME, PROBEREF, SUBJECTNAME ] = CHANNELNAME2PROBENAME ( CHNAME , SUBJECTS , [ OPTIONS ] ) Converts a raw channel name from a Marder Lab recording ( e . g ., 'DGN1_A' , 'lvn' , 'lvn2' ) into a standardized probe name , probe reference number , and associated subject name . This function identifies the subject by searching for '1' or '2' in the channel name . If neither is found , it defaults to the first subject . INPUTS : chName : ( string ) The channel name to be converted . subjects : ( cell array of strings ) A list of subject identifiers . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , ignores '2' in the channel name and assigns the channel to the first subject . Default is false . OUTPUTS : probename : ( string ) The standardized probe name ( e . g ., 'dgn_1' , 'lvn_2' ). If no standard name is found , it returns a MATLAB - validated version of the input channel name . proberef : ( double ) The reference number for the probe , always 1. subjectname : ( string ) The identifier of the subject associated with the channel . EXAMPLE : subjects = { 'crab1' , 'crab2' } ; [ p_name, p_ref, s_name ] = ndi . setup . conv . marder . probeMap . channelname2probename ( 'dgn2_A' , subjects ) % p_name = 'dgn_2' % p_ref = 1 % s_name = 'crab2'","title":"ndi.setup.conv.marder.probeMap.channelname2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelnames2daqsystemstrings.m/","text":"ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings \u00b6 CHANNELNAMES2DAQSYSTEMSTRINGS - Convert channel names to NDI DAQ system strings and probe info . [ NAME, REF, DAQSYSSTR, SUBJECTLIST ] = CHANNELNAMES2DAQSYSTEMSTRINGS ( CHNAMES , DAQNAME , SUBJECTS , [ OPTIONS ] ) This function processes a list of Marder Lab channel names , converts them into standardized probe names , and generates corresponding NDI DAQ system strings . It also assigns subject identifiers to each channel . A special case is handled for 'PhysiTemp' channels : if a temperature channel is found and there are multiple subjects , it is duplicated and assigned to the second subject as well . INPUTS : chNames : ( cell array of strings ) The list of channel names to process . daqname : ( string ) The name of the DAQ system ( e . g ., 'marder_abf' ). subjects : ( cell array of strings ) A list of subject identifiers . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , ignores '2' in channel names , assigning them to the first subject . Default is false . channelnumbers : ( array ) An array of channel numbers to be used for generating DAQ system strings . If empty , it defaults to 1 : numel ( chNames ). OUTPUTS : name : ( cell array of strings ) The standardized probe names . ref : ( array ) The reference numbers for each probe ( always 1 ). daqsysstr : ( ndi . daq . daqsystemstring array ) The generated DAQ system strings . subjectlist : ( cell array of strings ) The subject identifier for each channel . EXAMPLE : chNames = { 'dgn1_A' , 'lvn2_A' , 'PhysiTemp' } ; daqname = 'marder_abf' ; subjects = { 'crab1' , 'crab2' } ; [ n, r, d, s ] = ndi . setup . conv . marder . probeMap . channelnames2daqsystemstrings ( chNames , daqname , subjects ); % This will return probe names , references , DAQ strings , and subjects % for each channel , including a duplicated PhysiTemp for the second crab . See also : ndi . setup . conv . marder . probeMap . channelname2probename , ndi . daq . daqsystemstring","title":"ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelnames2daqsystemstrings.m/#ndisetupconvmarderprobemapchannelnames2daqsystemstrings","text":"CHANNELNAMES2DAQSYSTEMSTRINGS - Convert channel names to NDI DAQ system strings and probe info . [ NAME, REF, DAQSYSSTR, SUBJECTLIST ] = CHANNELNAMES2DAQSYSTEMSTRINGS ( CHNAMES , DAQNAME , SUBJECTS , [ OPTIONS ] ) This function processes a list of Marder Lab channel names , converts them into standardized probe names , and generates corresponding NDI DAQ system strings . It also assigns subject identifiers to each channel . A special case is handled for 'PhysiTemp' channels : if a temperature channel is found and there are multiple subjects , it is duplicated and assigned to the second subject as well . INPUTS : chNames : ( cell array of strings ) The list of channel names to process . daqname : ( string ) The name of the DAQ system ( e . g ., 'marder_abf' ). subjects : ( cell array of strings ) A list of subject identifiers . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , ignores '2' in channel names , assigning them to the first subject . Default is false . channelnumbers : ( array ) An array of channel numbers to be used for generating DAQ system strings . If empty , it defaults to 1 : numel ( chNames ). OUTPUTS : name : ( cell array of strings ) The standardized probe names . ref : ( array ) The reference numbers for each probe ( always 1 ). daqsysstr : ( ndi . daq . daqsystemstring array ) The generated DAQ system strings . subjectlist : ( cell array of strings ) The subject identifier for each channel . EXAMPLE : chNames = { 'dgn1_A' , 'lvn2_A' , 'PhysiTemp' } ; daqname = 'marder_abf' ; subjects = { 'crab1' , 'crab2' } ; [ n, r, d, s ] = ndi . setup . conv . marder . probeMap . channelnames2daqsystemstrings ( chNames , daqname , subjects ); % This will return probe names , references , DAQ strings , and subjects % for each channel , including a duplicated PhysiTemp for the second crab . See also : ndi . setup . conv . marder . probeMap . channelname2probename , ndi . daq . daqsystemstring","title":"ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelnametable2probename.m/","text":"ndi.setup.conv.marder.probeMap.channelnametable2probename \u00b6 CHANNELNAMETABLE2PROBENAME - Retrieve probe information from a probe table using a channel name . [ PROBENAME , PROBEREF , PROBETYPE , SUBJECTNAME ] = CHANNELNAMETABLE2PROBENAME ( CHNAME , PROBETABLE ) Searches a probe table for a given channel name and returns the corresponding probe name , reference , type , and subject name . This function is a key component in mapping raw data channels to the structured probe and subject information defined in a 'probeTable.csv' file . INPUTS : chName : ( string ) The channel name to look up in the probe table . probetable : ( table ) A MATLAB table containing probe information . It must include the columns \"channelName\" , \"probeName\" , \"probeRef\" , \"probeType\" , and \"subject\" . OUTPUTS : probename : ( string ) The name of the probe . proberef : ( double ) The reference number of the probe . probetype : ( string ) The type of the probe ( e . g . , 'n-trode' , 'sharp-Vm' ) . subjectname : ( string ) The identifier of the subject associated with the probe . EXAMPLE : % Assume 'myProbeTable.csv' exists and is loaded into a table called 'pt' pt = readtable ( 'myProbeTable.csv' ); chName = 'dgn_1' ; [ p_name , p_ref , p_type , s_name ] = ndi . setup . conv . marder . probeMap . channelnametable2probename ( chName , pt ); % This will return the probe details for the 'dgn_1' channel . See also : readtable , ndi . setup . conv . marder . probeMap . abf2probetable","title":"ndi.setup.conv.marder.probeMap.channelnametable2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelnametable2probename.m/#ndisetupconvmarderprobemapchannelnametable2probename","text":"CHANNELNAMETABLE2PROBENAME - Retrieve probe information from a probe table using a channel name . [ PROBENAME , PROBEREF , PROBETYPE , SUBJECTNAME ] = CHANNELNAMETABLE2PROBENAME ( CHNAME , PROBETABLE ) Searches a probe table for a given channel name and returns the corresponding probe name , reference , type , and subject name . This function is a key component in mapping raw data channels to the structured probe and subject information defined in a 'probeTable.csv' file . INPUTS : chName : ( string ) The channel name to look up in the probe table . probetable : ( table ) A MATLAB table containing probe information . It must include the columns \"channelName\" , \"probeName\" , \"probeRef\" , \"probeType\" , and \"subject\" . OUTPUTS : probename : ( string ) The name of the probe . proberef : ( double ) The reference number of the probe . probetype : ( string ) The type of the probe ( e . g . , 'n-trode' , 'sharp-Vm' ) . subjectname : ( string ) The identifier of the subject associated with the probe . EXAMPLE : % Assume 'myProbeTable.csv' exists and is loaded into a table called 'pt' pt = readtable ( 'myProbeTable.csv' ); chName = 'dgn_1' ; [ p_name , p_ref , p_type , s_name ] = ndi . setup . conv . marder . probeMap . channelnametable2probename ( chName , pt ); % This will return the probe details for the 'dgn_1' channel . See also : readtable , ndi . setup . conv . marder . probeMap . abf2probetable","title":"ndi.setup.conv.marder.probeMap.channelnametable2probename"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/editProbeTable.m/","text":"ndi.setup.conv.marder.probeMap.editProbeTable \u00b6 An interactive probe table editor for probe tables created by abf2probetable . m This script allows users to edit a probe table through a text - based interface .","title":"ndi.setup.conv.marder.probeMap.editProbeTable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/editProbeTable.m/#ndisetupconvmarderprobemapeditprobetable","text":"An interactive probe table editor for probe tables created by abf2probetable . m This script allows users to edit a probe table through a text - based interface .","title":"ndi.setup.conv.marder.probeMap.editProbeTable"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/freshen.m/","text":"ndi.setup.conv.marder.probeMap.freshen \u00b6 FRESHEN - Updates 'firstAppears' field in an existing probe table PROBETABLEEXISTING = FRESHEN ( PROBETABLEEXISTING , PROBETABLENEW ) Given an existing probe table ( PROBETABLEEXISTING ) and a newly generated one ( PROBETABLENEW ) , this function \"freshens\" the existing table by updating the 'firstAppears' column with the values from the new table . The channels in the tables do not need to be in the same order , but the set of channels must be identical . This function will raise an error if the channel lists of the two tables are not identical .","title":"ndi.setup.conv.marder.probeMap.freshen"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/freshen.m/#ndisetupconvmarderprobemapfreshen","text":"FRESHEN - Updates 'firstAppears' field in an existing probe table PROBETABLEEXISTING = FRESHEN ( PROBETABLEEXISTING , PROBETABLENEW ) Given an existing probe table ( PROBETABLEEXISTING ) and a newly generated one ( PROBETABLENEW ) , this function \"freshens\" the existing table by updating the 'firstAppears' column with the values from the new table . The channels in the tables do not need to be in the same order , but the set of channels must be identical . This function will raise an error if the channel lists of the two tables are not identical .","title":"ndi.setup.conv.marder.probeMap.freshen"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/makeVoltageOffsets.m/","text":"ndi.setup.conv.marder.probeMap.makeVoltageOffsets \u00b6 MAKEVOLTAGEOFFSETS - Create NDI documents from a table of voltage offset values . DOCLIST = MAKEVOLTAGEOFFSETS ( S ) Reads a comma - separated value file named 'MEoffset.txt' from the NDI session ' s directory . This file should contain microelectrode voltage offset data . The function then creates 'electrode_offset_voltage' documents in the NDI database for any new offset values . The 'MEoffset.txt' file must have the following columns : - \"probeName\" : The name of the probe associated with the offset . - \"offsetV\" : The voltage offset value . - \"T\" : The temperature at which the offset was measured . If the file does not exist , the function issues a warning and takes no action . INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : docList : ( cell array of ndi . document ) A cell array of any newly created 'electrode_offset_voltage' documents . These documents are also added to the session ' s database . EXAMPLE : % Create a 'MEoffset.txt' file in the session directory with the columns: % probeName,offsetV,T % dgn_1,0.005,22.5 % Assuming S is a valid NDI session object new_docs = ndi . setup . conv . marder . probeMap . makeVoltageOffsets ( S ); See also: readtable, ndi.document","title":"ndi.setup.conv.marder.probeMap.makeVoltageOffsets"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/makeVoltageOffsets.m/#ndisetupconvmarderprobemapmakevoltageoffsets","text":"MAKEVOLTAGEOFFSETS - Create NDI documents from a table of voltage offset values . DOCLIST = MAKEVOLTAGEOFFSETS ( S ) Reads a comma - separated value file named 'MEoffset.txt' from the NDI session ' s directory . This file should contain microelectrode voltage offset data . The function then creates 'electrode_offset_voltage' documents in the NDI database for any new offset values . The 'MEoffset.txt' file must have the following columns : - \"probeName\" : The name of the probe associated with the offset . - \"offsetV\" : The voltage offset value . - \"T\" : The temperature at which the offset was measured . If the file does not exist , the function issues a warning and takes no action . INPUTS : S : ( ndi . session ) The NDI session object . OUTPUTS : docList : ( cell array of ndi . document ) A cell array of any newly created 'electrode_offset_voltage' documents . These documents are also added to the session ' s database . EXAMPLE : % Create a 'MEoffset.txt' file in the session directory with the columns: % probeName,offsetV,T % dgn_1,0.005,22.5 % Assuming S is a valid NDI session object new_docs = ndi . setup . conv . marder . probeMap . makeVoltageOffsets ( S ); See also: readtable, ndi.document","title":"ndi.setup.conv.marder.probeMap.makeVoltageOffsets"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/marderprobe2uberon.m/","text":"ndi.setup.conv.marder.probeMap.marderprobe2uberon \u00b6 MARDERPROBE2UBERON - Add probe location information based on Marder probe data . D = MARDERPROBE2UBERON ( S ) Creates 'probe_location' NDI documents by mapping probe names in an NDI session to anatomical locations defined in the UBERON ontology . The function retrieves all 'n-trode' , 'sharp-Vm' , 'sharp-Im' , and 'ppg' probes from the session . It then uses a lookup table , 'marderprobe2uberontable.txt' , to find the corresponding UBERON anatomical term for each probe . For each match found , it creates a 'probe_location' document that links the probe 's ID to the UBERON identifier. INPUTS: S: (ndi.session) The NDI session object. OUTPUTS: d: (cell array of ndi.document) A cell array of the newly created ' probe_location ' documents . Note : These documents are NOT automatically added to the database . REQUIRED FILES : - [ toolbox_path ]/+ ndi /+ setup /+ conv /+ marder /+ probeMap / marderprobe2uberontable . txt : A tab - delimited file that maps probe names to UBERON anatomical terms . It must contain \"probe\" and \"name\" columns . EXAMPLE : % Assuming S is a valid NDI session with defined probes location_docs = ndi . setup . conv . marder . probeMap . marderprobe2uberon ( S ); S . database_add ( location_docs ); % Add the new documents to the database See also : ndi . database . fun . uberon_ontology_lookup , readtable","title":"ndi.setup.conv.marder.probeMap.marderprobe2uberon"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/marderprobe2uberon.m/#ndisetupconvmarderprobemapmarderprobe2uberon","text":"MARDERPROBE2UBERON - Add probe location information based on Marder probe data . D = MARDERPROBE2UBERON ( S ) Creates 'probe_location' NDI documents by mapping probe names in an NDI session to anatomical locations defined in the UBERON ontology . The function retrieves all 'n-trode' , 'sharp-Vm' , 'sharp-Im' , and 'ppg' probes from the session . It then uses a lookup table , 'marderprobe2uberontable.txt' , to find the corresponding UBERON anatomical term for each probe . For each match found , it creates a 'probe_location' document that links the probe 's ID to the UBERON identifier. INPUTS: S: (ndi.session) The NDI session object. OUTPUTS: d: (cell array of ndi.document) A cell array of the newly created ' probe_location ' documents . Note : These documents are NOT automatically added to the database . REQUIRED FILES : - [ toolbox_path ]/+ ndi /+ setup /+ conv /+ marder /+ probeMap / marderprobe2uberontable . txt : A tab - delimited file that maps probe names to UBERON anatomical terms . It must contain \"probe\" and \"name\" columns . EXAMPLE : % Assuming S is a valid NDI session with defined probes location_docs = ndi . setup . conv . marder . probeMap . marderprobe2uberon ( S ); S . database_add ( location_docs ); % Add the new documents to the database See also : ndi . database . fun . uberon_ontology_lookup , readtable","title":"ndi.setup.conv.marder.probeMap.marderprobe2uberon"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/smrepochprobemap.m/","text":"ndi.setup.conv.marder.probeMap.smrepochprobemap \u00b6 SMREPOCHPROBEMAP - Create epochprobemap files from Spike2 SMR files . SMREPOCHPROBEMAP ( S , [ OPTIONS ]) Creates '.epochprobemap.txt' files for a Marder Lab NDI session by reading metadata from all Spike2 SMR files ( * . smr ) in the session directory . These map files link recording channels to probe information for each epoch . This function assumes that the NDI session ` S ` has been created and that the session path contains the SMR files . It also relies on 'subject*.txt' files to identify subjects and adds them to the NDI database if they do not already exist . INPUTS : S : ( ndi . session ) An NDI_SESSION object for the Marder Lab session . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , forces the function to ignore '2' in channel names when mapping to probe information , preventing misinterpretation as a second prep . Default is false . OUTPUTS : This function does not return any values but writes a '.epochprobemap.txt' file for each SMR file in the session directory . These files define the relationship between data channels and experimental probes for each recording epoch . EXAMPLE : % Create a new Marder Lab session ref = 'ML002' ; dirname = '/path/to/marder/smr_data' ; S = ndi . setup . lab ( 'marderlab' , ref , dirname ); % Create the epochprobemap files from SMR data ndi . setup . conv . marder . probeMap . smrepochprobemap ( S ); See also: ndi.setup.lab, ndi.epoch.epochprobemap_daqsystem, ndr.format.ced.read_SOMSMR_header","title":"ndi.setup.conv.marder.probeMap.smrepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/smrepochprobemap.m/#ndisetupconvmarderprobemapsmrepochprobemap","text":"SMREPOCHPROBEMAP - Create epochprobemap files from Spike2 SMR files . SMREPOCHPROBEMAP ( S , [ OPTIONS ]) Creates '.epochprobemap.txt' files for a Marder Lab NDI session by reading metadata from all Spike2 SMR files ( * . smr ) in the session directory . These map files link recording channels to probe information for each epoch . This function assumes that the NDI session ` S ` has been created and that the session path contains the SMR files . It also relies on 'subject*.txt' files to identify subjects and adds them to the NDI database if they do not already exist . INPUTS : S : ( ndi . session ) An NDI_SESSION object for the Marder Lab session . OPTIONS : ( Optional ) A struct with the following fields : forceIgnore2 : ( logical ) If true , forces the function to ignore '2' in channel names when mapping to probe information , preventing misinterpretation as a second prep . Default is false . OUTPUTS : This function does not return any values but writes a '.epochprobemap.txt' file for each SMR file in the session directory . These files define the relationship between data channels and experimental probes for each recording epoch . EXAMPLE : % Create a new Marder Lab session ref = 'ML002' ; dirname = '/path/to/marder/smr_data' ; S = ndi . setup . lab ( 'marderlab' , ref , dirname ); % Create the epochprobemap files from SMR data ndi . setup . conv . marder . probeMap . smrepochprobemap ( S ); See also: ndi.setup.lab, ndi.epoch.epochprobemap_daqsystem, ndr.format.ced.read_SOMSMR_header","title":"ndi.setup.conv.marder.probeMap.smrepochprobemap"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/","text":"CLASS ndi.setup.conv.marder.subject.SubjectInformationCreator \u00b6 file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m Superclasses \u00b6 ndi.setup.NDIMaker.SubjectInformationCreator , handle Properties \u00b6 none Methods \u00b6 Method Description SubjectInformationCreator file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m addlistener addlistener Add listener for event. create Generates subject data from a Marder Lab subject string. delete DELETE Delete a handle object. eq == (EQ) Test handle equality. findobj FINDOBJ Find objects matching specified conditions. findprop findprop Find property of MATLAB handle object. ge >= (GE) Greater than or equal relation for handles. gt > (GT) Greater than relation for handles. isvalid ISVALID Test handle validity. le <= (LE) Less than or equal relation for handles. listener listener Add listener for event without binding the listener to the source object. lt < (LT) Less than relation for handles. ne ~= (NE) Not equal relation for handles. notify NOTIFY Notify listeners of event. Methods help \u00b6 SubjectInformationCreator - file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m Documentation for ndi . setup . conv . marder . subject . SubjectInformationCreator / SubjectInformationCreator doc ndi . setup . conv . marder . subject . SubjectInformationCreator addlistener - addlistener Add listener for event. el = addlistener ( hSource , Eventname , callbackFcn ) creates a listener for the event named Eventname . The source of the event is the handle object hSource . If hSource is an array of source handles , the listener responds to the named event on any handle in the array . callbackFcn is a function handle that is invoked when the event is triggered . el = addlistener ( hSource , PropName , Eventname , Callback ) adds a listener for a property event . Eventname must be one of 'PreGet' , 'PostGet' , 'PreSet' , or 'PostSet' . Eventname can be a string scalar or character vector . PropName must be a single property name specified as string scalar or character vector , or a collection of property names specified as a cell array of character vectors or a string array , or as an array of one or more matlab . metadata . Property objects . The properties must belong to the class of hSource . If hSource is scalar , PropName can include dynamic properties . For all forms , addlistener returns an event . listener . To remove a listener , delete the object returned by addlistener . For example , delete ( el ) calls the handle class delete method to remove the listener and delete it from the workspace . addlistener binds the listener 's lifecycle to the object that is the source of the event . Unless you explicitly delete the listener , it is destroyed only when the source object is destroyed . To control the lifecycle of the listener independently from the event source object , use listener or the event . listener constructor to create the listener . See also listener , event . listener , ndi . setup . conv . marder . subject . subjectinformationcreator , matlab . metadata . Property , events Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / addlistener is inherited from superclass handle create - Generates subject data from a Marder Lab subject string. [ SUBJECTIDENTIFIER , STRAIN , SPECIES , BIOLOGICALSEX ] = CREATE ( OBJ , TABLEROW ) This method processes a single row from a table to generate a unique subject identifier and associated species information . The subject ID is read from the 'subject_id' column of the table row . Inputs : obj ( ndi . setup . conv . marder . subject . SubjectInformationCreator ) - The instance of this creator class . tableRow ( table ) - A single row from a MATLAB table . It must contain the column 'subject_id' . Outputs : subjectIdentifier ( char ) - The unique local identifier for the subject . Returns NaN on failure . strain ( NaN ) - Not used for this creator ; returns NaN . species ( openminds . controlledterms . Species ) - The species object . Returns NaN on failure . biologicalSex ( NaN ) - Not used for this creator ; returns NaN . See also : ndi . setup . NDIMaker . SubjectInformationCreator delete - DELETE Delete a handle object. DELETE ( H ) deletes all handle objects in array H . After the delete function call , H is an array of invalid objects . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / ISVALID , CLEAR Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / delete is inherited from superclass handle eq - == (EQ) Test handle equality. Handles are equal if they are handles for the same object . H1 == H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise equality result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = EQ ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / eq is inherited from superclass handle findobj - FINDOBJ Find objects matching specified conditions. The FINDOBJ method of the HANDLE class follows the same syntax as the MATLAB FINDOBJ command , except that the first argument must be an array of handles to objects . HM = FINDOBJ ( H , < conditions > ) searches the handle object array H and returns an array of handle objects matching the specified conditions . Only the public members of the objects of H are considered when evaluating the conditions . See also FINDOBJ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / findobj is inherited from superclass handle findprop - findprop Find property of MATLAB handle object. p = findprop ( H , PropName ) finds and returns the matlab . metadata . Property object associated with property name PropName of scalar handle object H . PropName can be a string scalar or character vector . It can be the name of a property defined by the class of H or a dynamic property added to scalar object H . If no property named PropName exists for object H , an empty matlab . metadata . Property array is returned . See also ndi . setup . conv . marder . subject . subjectinformationcreator , ndi . setup . conv . marder . subject . subjectinformationcreator / findobj , dynamicprops , matlab . metadata . Property Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / findprop is inherited from superclass handle ge - >= (GE) Greater than or equal relation for handles. H1 >= H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise >= result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = GE ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / ge is inherited from superclass handle gt - > (GT) Greater than relation for handles. H1 > H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise > result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = GT ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / gt is inherited from superclass handle isvalid - ISVALID Test handle validity. TF = ISVALID ( H ) performs an element - wise check for validity on the handle elements of H . The result is a logical array of the same dimensions as H , where each element is the element - wise validity result . A handle is invalid if it has been deleted or if it is an element of a handle array and has not yet been initialized . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / DELETE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / isvalid is inherited from superclass handle le - <= (LE) Less than or equal relation for handles. Handles are equal if they are handles for the same object . All comparisons use a number associated with each handle object . Nothing can be assumed about the result of a handle comparison except that the repeated comparison of two handles in the same MATLAB session will yield the same result . The order of handle values is purely arbitrary and has no connection to the state of the handle objects being compared . H1 <= H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise >= result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = LE ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / le is inherited from superclass handle listener - listener Add listener for event without binding the listener to the source object. el = listener ( hSource , Eventname , callbackFcn ) creates a listener for the event named Eventname . The source of the event is the handle object hSource . If hSource is an array of source handles , the listener responds to the named event on any handle in the array . callbackFcn is a function handle that is invoked when the event is triggered . el = listener ( hSource , PropName , Eventname , callback ) adds a listener for a property event . Eventname must be one of 'PreGet' , 'PostGet' , 'PreSet' , or 'PostSet' . Eventname can be a string sclar or character vector . PropName must be either a single property name specified as a string scalar or character vector , or a collection of property names specified as a cell array of character vectors or a string array , or as an array of one ore more matlab . metadata . Property objects . The properties must belong to the class of hSource . If hSource is scalar , PropName can include dynamic properties . For all forms , listener returns an event . listener . To remove a listener , delete the object returned by listener . For example , delete ( el ) calls the handle class delete method to remove the listener and delete it from the workspace . Calling delete ( el ) on the listener object deletes the listener , which means the event no longer causes the callback function to execute . listener does not bind the listener 's lifecycle to the object that is the source of the event . Destroying the source object does not impact the lifecycle of the listener object . A listener created with listener must be destroyed independently of the source object . Calling delete ( el ) explicitly destroys the listener . Redefining or clearing the variable containing the listener can delete the listener if no other references to it exist . To tie the lifecycle of the listener to the lifecycle of the source object , use addlistener . See also addlistener , event . listener , ndi . setup . conv . marder . subject . subjectinformationcreator , matlab . metadata . Property , events Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / listener is inherited from superclass handle lt - < (LT) Less than relation for handles. H1 < H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise < result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = LT ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / lt is inherited from superclass handle ne - ~= (NE) Not equal relation for handles. Handles are equal if they are handles for the same object and are unequal otherwise . H1 ~= H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise equality result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = NE ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / ne is inherited from superclass handle notify - NOTIFY Notify listeners of event. NOTIFY ( H , eventname ) notifies listeners added to the event named eventname for handle object array H that the event is taking place . eventname can be a string scalar or character vector . H is the array of handles to the event source objects , and ' eventname ' must be a character vector . NOTIFY ( H , eventname , ed ) provides a way of encapsulating information about an event which can then be accessed by each registered listener . ed must belong to the EVENT . EVENTDATA class . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / ADDLISTENER , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LISTENER , EVENT . EVENTDATA , EVENTS Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / notify is inherited from superclass handle","title":"ndi.setup.conv.marder.subject.SubjectInformationCreator"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#class-ndisetupconvmardersubjectsubjectinformationcreator","text":"file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m","title":"CLASS ndi.setup.conv.marder.subject.SubjectInformationCreator"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#superclasses","text":"ndi.setup.NDIMaker.SubjectInformationCreator , handle","title":"Superclasses"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#properties","text":"none","title":"Properties"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#methods","text":"Method Description SubjectInformationCreator file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m addlistener addlistener Add listener for event. create Generates subject data from a Marder Lab subject string. delete DELETE Delete a handle object. eq == (EQ) Test handle equality. findobj FINDOBJ Find objects matching specified conditions. findprop findprop Find property of MATLAB handle object. ge >= (GE) Greater than or equal relation for handles. gt > (GT) Greater than relation for handles. isvalid ISVALID Test handle validity. le <= (LE) Less than or equal relation for handles. listener listener Add listener for event without binding the listener to the source object. lt < (LT) Less than relation for handles. ne ~= (NE) Not equal relation for handles. notify NOTIFY Notify listeners of event.","title":"Methods"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#methods-help","text":"SubjectInformationCreator - file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m Documentation for ndi . setup . conv . marder . subject . SubjectInformationCreator / SubjectInformationCreator doc ndi . setup . conv . marder . subject . SubjectInformationCreator addlistener - addlistener Add listener for event. el = addlistener ( hSource , Eventname , callbackFcn ) creates a listener for the event named Eventname . The source of the event is the handle object hSource . If hSource is an array of source handles , the listener responds to the named event on any handle in the array . callbackFcn is a function handle that is invoked when the event is triggered . el = addlistener ( hSource , PropName , Eventname , Callback ) adds a listener for a property event . Eventname must be one of 'PreGet' , 'PostGet' , 'PreSet' , or 'PostSet' . Eventname can be a string scalar or character vector . PropName must be a single property name specified as string scalar or character vector , or a collection of property names specified as a cell array of character vectors or a string array , or as an array of one or more matlab . metadata . Property objects . The properties must belong to the class of hSource . If hSource is scalar , PropName can include dynamic properties . For all forms , addlistener returns an event . listener . To remove a listener , delete the object returned by addlistener . For example , delete ( el ) calls the handle class delete method to remove the listener and delete it from the workspace . addlistener binds the listener 's lifecycle to the object that is the source of the event . Unless you explicitly delete the listener , it is destroyed only when the source object is destroyed . To control the lifecycle of the listener independently from the event source object , use listener or the event . listener constructor to create the listener . See also listener , event . listener , ndi . setup . conv . marder . subject . subjectinformationcreator , matlab . metadata . Property , events Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / addlistener is inherited from superclass handle create - Generates subject data from a Marder Lab subject string. [ SUBJECTIDENTIFIER , STRAIN , SPECIES , BIOLOGICALSEX ] = CREATE ( OBJ , TABLEROW ) This method processes a single row from a table to generate a unique subject identifier and associated species information . The subject ID is read from the 'subject_id' column of the table row . Inputs : obj ( ndi . setup . conv . marder . subject . SubjectInformationCreator ) - The instance of this creator class . tableRow ( table ) - A single row from a MATLAB table . It must contain the column 'subject_id' . Outputs : subjectIdentifier ( char ) - The unique local identifier for the subject . Returns NaN on failure . strain ( NaN ) - Not used for this creator ; returns NaN . species ( openminds . controlledterms . Species ) - The species object . Returns NaN on failure . biologicalSex ( NaN ) - Not used for this creator ; returns NaN . See also : ndi . setup . NDIMaker . SubjectInformationCreator delete - DELETE Delete a handle object. DELETE ( H ) deletes all handle objects in array H . After the delete function call , H is an array of invalid objects . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / ISVALID , CLEAR Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / delete is inherited from superclass handle eq - == (EQ) Test handle equality. Handles are equal if they are handles for the same object . H1 == H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise equality result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = EQ ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / eq is inherited from superclass handle findobj - FINDOBJ Find objects matching specified conditions. The FINDOBJ method of the HANDLE class follows the same syntax as the MATLAB FINDOBJ command , except that the first argument must be an array of handles to objects . HM = FINDOBJ ( H , < conditions > ) searches the handle object array H and returns an array of handle objects matching the specified conditions . Only the public members of the objects of H are considered when evaluating the conditions . See also FINDOBJ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / findobj is inherited from superclass handle findprop - findprop Find property of MATLAB handle object. p = findprop ( H , PropName ) finds and returns the matlab . metadata . Property object associated with property name PropName of scalar handle object H . PropName can be a string scalar or character vector . It can be the name of a property defined by the class of H or a dynamic property added to scalar object H . If no property named PropName exists for object H , an empty matlab . metadata . Property array is returned . See also ndi . setup . conv . marder . subject . subjectinformationcreator , ndi . setup . conv . marder . subject . subjectinformationcreator / findobj , dynamicprops , matlab . metadata . Property Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / findprop is inherited from superclass handle ge - >= (GE) Greater than or equal relation for handles. H1 >= H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise >= result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = GE ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / ge is inherited from superclass handle gt - > (GT) Greater than relation for handles. H1 > H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise > result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = GT ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / gt is inherited from superclass handle isvalid - ISVALID Test handle validity. TF = ISVALID ( H ) performs an element - wise check for validity on the handle elements of H . The result is a logical array of the same dimensions as H , where each element is the element - wise validity result . A handle is invalid if it has been deleted or if it is an element of a handle array and has not yet been initialized . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / DELETE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / isvalid is inherited from superclass handle le - <= (LE) Less than or equal relation for handles. Handles are equal if they are handles for the same object . All comparisons use a number associated with each handle object . Nothing can be assumed about the result of a handle comparison except that the repeated comparison of two handles in the same MATLAB session will yield the same result . The order of handle values is purely arbitrary and has no connection to the state of the handle objects being compared . H1 <= H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise >= result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = LE ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / le is inherited from superclass handle listener - listener Add listener for event without binding the listener to the source object. el = listener ( hSource , Eventname , callbackFcn ) creates a listener for the event named Eventname . The source of the event is the handle object hSource . If hSource is an array of source handles , the listener responds to the named event on any handle in the array . callbackFcn is a function handle that is invoked when the event is triggered . el = listener ( hSource , PropName , Eventname , callback ) adds a listener for a property event . Eventname must be one of 'PreGet' , 'PostGet' , 'PreSet' , or 'PostSet' . Eventname can be a string sclar or character vector . PropName must be either a single property name specified as a string scalar or character vector , or a collection of property names specified as a cell array of character vectors or a string array , or as an array of one ore more matlab . metadata . Property objects . The properties must belong to the class of hSource . If hSource is scalar , PropName can include dynamic properties . For all forms , listener returns an event . listener . To remove a listener , delete the object returned by listener . For example , delete ( el ) calls the handle class delete method to remove the listener and delete it from the workspace . Calling delete ( el ) on the listener object deletes the listener , which means the event no longer causes the callback function to execute . listener does not bind the listener 's lifecycle to the object that is the source of the event . Destroying the source object does not impact the lifecycle of the listener object . A listener created with listener must be destroyed independently of the source object . Calling delete ( el ) explicitly destroys the listener . Redefining or clearing the variable containing the listener can delete the listener if no other references to it exist . To tie the lifecycle of the listener to the lifecycle of the source object , use addlistener . See also addlistener , event . listener , ndi . setup . conv . marder . subject . subjectinformationcreator , matlab . metadata . Property , events Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / listener is inherited from superclass handle lt - < (LT) Less than relation for handles. H1 < H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise < result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = LT ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / NE Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / lt is inherited from superclass handle ne - ~= (NE) Not equal relation for handles. Handles are equal if they are handles for the same object and are unequal otherwise . H1 ~= H2 performs element - wise comparisons between handle arrays H1 and H2 . H1 and H2 must be of the same dimensions unless one is a scalar . The result is a logical array of the same dimensions , where each element is an element - wise equality result . If one of H1 or H2 is scalar , scalar expansion is performed and the result will match the dimensions of the array that is not scalar . TF = NE ( H1 , H2 ) stores the result in a logical array of the same dimensions . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / EQ , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / GT , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LE , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LT Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / ne is inherited from superclass handle notify - NOTIFY Notify listeners of event. NOTIFY ( H , eventname ) notifies listeners added to the event named eventname for handle object array H that the event is taking place . eventname can be a string scalar or character vector . H is the array of handles to the event source objects , and ' eventname ' must be a character vector . NOTIFY ( H , eventname , ed ) provides a way of encapsulating information about an event which can then be accessed by each registered listener . ed must belong to the EVENT . EVENTDATA class . See also NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / ADDLISTENER , NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTINFORMATIONCREATOR / LISTENER , EVENT . EVENTDATA , EVENTS Help for ndi . setup . conv . marder . subject . SubjectInformationCreator / notify is inherited from superclass handle","title":"Methods help"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/makesubjects.m/","text":"ndi.setup.conv.marder.subject.makesubjects \u00b6 MAKESUBJECTS - Create subject text files for an NDI session . MAKESUBJECTS ( S , N ) Creates 'subjectN.txt' files for a specified number of subjects in the NDI session directory . Each file contains a unique subject identifier based on the session directory name and the subject number . These files are used by other setup functions to identify and link data to the correct subjects . INPUTS : S : ( ndi . session ) The NDI session object . N : ( integer ) The number of subjects to create . OUTPUTS : This function does not return any values but writes 'subject1.txt' , 'subject2.txt' , etc ., to the session directory . EXAMPLE : % Assuming S is a valid NDI session object for a directory named 'my_exp' ndi . setup . conv . marder . subject . makesubjects ( S , 2 ); % This will create 'subject1.txt' with content 'my_exp_01@marderlab.brandeis.edu' % and 'subject2.txt' with content 'my_exp_02@marderlab.brandeis.edu'. See also : ndi . setup . conv . marder . probeMap . abf2probetable , ndi . setup . conv . marder . probeMap . abfepochprobemap","title":"ndi.setup.conv.marder.subject.makesubjects"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/makesubjects.m/#ndisetupconvmardersubjectmakesubjects","text":"MAKESUBJECTS - Create subject text files for an NDI session . MAKESUBJECTS ( S , N ) Creates 'subjectN.txt' files for a specified number of subjects in the NDI session directory . Each file contains a unique subject identifier based on the session directory name and the subject number . These files are used by other setup functions to identify and link data to the correct subjects . INPUTS : S : ( ndi . session ) The NDI session object . N : ( integer ) The number of subjects to create . OUTPUTS : This function does not return any values but writes 'subject1.txt' , 'subject2.txt' , etc ., to the session directory . EXAMPLE : % Assuming S is a valid NDI session object for a directory named 'my_exp' ndi . setup . conv . marder . subject . makesubjects ( S , 2 ); % This will create 'subject1.txt' with content 'my_exp_01@marderlab.brandeis.edu' % and 'subject2.txt' with content 'my_exp_02@marderlab.brandeis.edu'. See also : ndi . setup . conv . marder . probeMap . abf2probetable , ndi . setup . conv . marder . probeMap . abfepochprobemap","title":"ndi.setup.conv.marder.subject.makesubjects"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/subjectSetup.m/","text":"ndi.setup.conv.marder.subject.subjectSetup \u00b6 NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTSETUP - An interactive program to set up subject files for Marder lab conversion . NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTSETUP ( [ DIRECTORY ] ) Takes as input a directory ( default : the pwd ) and builds subjectN . txt files to facilitate Marder lab conversion . It asks the user a few questions in a loop . First , it tells the user which directory is being worked on and prints the existing contents of subjectN . txt files ( for N = 1 .. whatever exists ). Then , it asks the user if they want to : a ) Add a crab b ) Add a lobster c ) Exit If they add a crab or lobster , it asks for the preparation number . Then , it creates a text file called subjectM . txt ( where M is N + 1 , or 1 if there are no files ) that has the contents 'gdy_####@marderlab.brandeis.edu' , where #### expresses the preparation number as a 4 digit integer ( e . g ., 0013 ). If the subject is a lobster , then it is 'gdy_lobsterNNN@marderlab.brandeis.edu' , where NNN is a 3 - digit integer .","title":"ndi.setup.conv.marder.subject.subjectSetup"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/subjectSetup.m/#ndisetupconvmardersubjectsubjectsetup","text":"NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTSETUP - An interactive program to set up subject files for Marder lab conversion . NDI . SETUP . CONV . MARDER . SUBJECT . SUBJECTSETUP ( [ DIRECTORY ] ) Takes as input a directory ( default : the pwd ) and builds subjectN . txt files to facilitate Marder lab conversion . It asks the user a few questions in a loop . First , it tells the user which directory is being worked on and prints the existing contents of subjectN . txt files ( for N = 1 .. whatever exists ). Then , it asks the user if they want to : a ) Add a crab b ) Add a lobster c ) Exit If they add a crab or lobster , it asks for the preparation number . Then , it creates a text file called subjectM . txt ( where M is N + 1 , or 1 if there are no files ) that has the contents 'gdy_####@marderlab.brandeis.edu' , where #### expresses the preparation number as a 4 digit integer ( e . g ., 0013 ). If the subject is a lobster , then it is 'gdy_lobsterNNN@marderlab.brandeis.edu' , where NNN is a 3 - digit integer .","title":"ndi.setup.conv.marder.subject.subjectSetup"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/","text":"Tutorial 1 Marder Lab data and NDI \u00b6 1.1 Reading Generic lab data with NDI \u00b6 About NDI \u00b6 The Neuroscience Data Interface is a data interface that sits between data and analysis code. NDI presents scientific data so it is in the form of a database that can be accessed through an Application Programming Interface (API) and database queries. See our documentation for: A short introduction to NDI Key concepts and vocabulary Sessions and datasets \u00b6 In NDI, data is organized into sessions and datasets. A dataset is comprised of a set of sessions. To open an existing session, one simply uses: Code block 1.1.1: \u00b6 S = ndi . session . dir ( path / to / your / session ); Listing subjects in a session \u00b6 We have a handy helper function to list all of the subjects in a session in a table, along with some information about the global treatments of those subjects: Code block 1.1.2: \u00b6 sT = ndi . fun . docTable . subject ( S ) Seeing probes and elements \u00b6 Probes are anything that measures or stimulates a subject, and a session typically has many probe instances. To see the probes for your experiment, you can use Code block 1.1.3: \u00b6 p = S . getprobes () Elements are related to probes but they can also contain derived data. All probes are elements, some elements are probes. We can look at all the elements in our session like this: Code block 1.1.4: \u00b6 e = S . elements () You can examine the elements, which will be in a cell array, as follows: Code block 1.1.5 \u00b6 for i = 1 : numel ( e ) e { i } % display the element's information end Listing the epochs of elements or probes \u00b6 We can get the data for a probe or an element using the epochtable function. Code block 1.1.6 \u00b6 elementNumber = 10 ; % choose an element et = e { elementNumber }. epochtable ; for i = 1 : numel ( et ), et ( i ) % display the epoch table entry end Reading timeseries data from an element during an epoch \u00b6 We can read the timeseries data from an element a few different ways. We can ask for the data in the local time coordinates of the data acquisition device very easily: Code block 1.1.7 \u00b6 epochNumber = 1 ; [ d , t ] = e { elementNumber }. readtimeseries ( epochNumber , - inf , inf ); % read all times available figure ; plot ( t , d ); xlabel ( 'Time(s)' ); ylabel ( 'Signal' );","title":"1.1 Reading Generic lab data with NDI"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#tutorial-1-marder-lab-data-and-ndi","text":"","title":"Tutorial 1 Marder Lab data and NDI"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#11-reading-generic-lab-data-with-ndi","text":"","title":"1.1 Reading Generic lab data with NDI"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#about-ndi","text":"The Neuroscience Data Interface is a data interface that sits between data and analysis code. NDI presents scientific data so it is in the form of a database that can be accessed through an Application Programming Interface (API) and database queries. See our documentation for: A short introduction to NDI Key concepts and vocabulary","title":"About NDI"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#sessions-and-datasets","text":"In NDI, data is organized into sessions and datasets. A dataset is comprised of a set of sessions. To open an existing session, one simply uses:","title":"Sessions and datasets"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-111","text":"S = ndi . session . dir ( path / to / your / session );","title":"Code block 1.1.1:"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#listing-subjects-in-a-session","text":"We have a handy helper function to list all of the subjects in a session in a table, along with some information about the global treatments of those subjects:","title":"Listing subjects in a session"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-112","text":"sT = ndi . fun . docTable . subject ( S )","title":"Code block 1.1.2:"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#seeing-probes-and-elements","text":"Probes are anything that measures or stimulates a subject, and a session typically has many probe instances. To see the probes for your experiment, you can use","title":"Seeing probes and elements"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-113","text":"p = S . getprobes () Elements are related to probes but they can also contain derived data. All probes are elements, some elements are probes. We can look at all the elements in our session like this:","title":"Code block 1.1.3:"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-114","text":"e = S . elements () You can examine the elements, which will be in a cell array, as follows:","title":"Code block 1.1.4:"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-115","text":"for i = 1 : numel ( e ) e { i } % display the element's information end","title":"Code block 1.1.5"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#listing-the-epochs-of-elements-or-probes","text":"We can get the data for a probe or an element using the epochtable function.","title":"Listing the epochs of elements or probes"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-116","text":"elementNumber = 10 ; % choose an element et = e { elementNumber }. epochtable ; for i = 1 : numel ( et ), et ( i ) % display the epoch table entry end","title":"Code block 1.1.6"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#reading-timeseries-data-from-an-element-during-an-epoch","text":"We can read the timeseries data from an element a few different ways. We can ask for the data in the local time coordinates of the data acquisition device very easily:","title":"Reading timeseries data from an element during an epoch"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-117","text":"epochNumber = 1 ; [ d , t ] = e { elementNumber }. readtimeseries ( epochNumber , - inf , inf ); % read all times available figure ; plot ( t , d ); xlabel ( 'Time(s)' ); ylabel ( 'Signal' );","title":"Code block 1.1.7"},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/","text":"Tutorial 1 Marder Lab data and NDI \u00b6 1.2 Updating the software \u00b6 Updating the software \u00b6 Updating the software is a little tricky at the moment. Update DID-matlab : On the Matlab command line, navigate to your USERPATH/tools/DID-matlab directory. Make sure you are inside the directory. Run !git pull Update NDI-matlab : On the Matlab command line, navigate to your USERPATH/tools/NDI-matlab directory. Make sure you are inside the directory. Run !git pull Update vhlab-toolbox-matlab : On the Matlab command line, navigate to your USERPATH/tools/NDI-matlab directory. Make sure you are inside the directory. Run !git pull Update NDIcalc-marder-matlab : On the Matlab command line, navigate to your USERPATH/tools/NDIcalc-marder-matlab directory. Make sure you are inside the directory. Run !git pull","title":"1.2 Updating the software"},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/#tutorial-1-marder-lab-data-and-ndi","text":"","title":"Tutorial 1 Marder Lab data and NDI"},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/#12-updating-the-software","text":"","title":"1.2 Updating the software"},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/#updating-the-software","text":"Updating the software is a little tricky at the moment. Update DID-matlab : On the Matlab command line, navigate to your USERPATH/tools/DID-matlab directory. Make sure you are inside the directory. Run !git pull Update NDI-matlab : On the Matlab command line, navigate to your USERPATH/tools/NDI-matlab directory. Make sure you are inside the directory. Run !git pull Update vhlab-toolbox-matlab : On the Matlab command line, navigate to your USERPATH/tools/NDI-matlab directory. Make sure you are inside the directory. Run !git pull Update NDIcalc-marder-matlab : On the Matlab command line, navigate to your USERPATH/tools/NDIcalc-marder-matlab directory. Make sure you are inside the directory. Run !git pull","title":"Updating the software"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/","text":"Tutorial 1 Marder Lab data and NDI \u00b6 1.3 How we have been organizing things \u00b6 Where are the sessions? \u00b6 For the time being, we have been storing the PPG sessions in zipped folders on a shared Google Drive. Soon (overdue) this can all be in the cloud so it will get much easier. Opening a session \u00b6 Let's use 994_13 as an example. Find the 994_13.zip file on the shared drive, download it, and put it on your disk where you'd like. Code block 1.3.1: \u00b6 myDataPath = '/Users/vanhoosr/data/grace' ; mySessionPath = fullfile ( myDataPath , '994_13' ); S = ndi . session . dir ( mySessionPath ); Now you can list the subjects and look at the probes and epochs as in the generic tutorial . Importing new data into a session \u00b6 The NDI team has been doing this for the moment. We will document this so we can hand it off.","title":"1.3 How we have been organizing things"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#tutorial-1-marder-lab-data-and-ndi","text":"","title":"Tutorial 1 Marder Lab data and NDI"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#13-how-we-have-been-organizing-things","text":"","title":"1.3 How we have been organizing things"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#where-are-the-sessions","text":"For the time being, we have been storing the PPG sessions in zipped folders on a shared Google Drive. Soon (overdue) this can all be in the cloud so it will get much easier.","title":"Where are the sessions?"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#opening-a-session","text":"Let's use 994_13 as an example. Find the 994_13.zip file on the shared drive, download it, and put it on your disk where you'd like.","title":"Opening a session"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#code-block-131","text":"myDataPath = '/Users/vanhoosr/data/grace' ; mySessionPath = fullfile ( myDataPath , '994_13' ); S = ndi . session . dir ( mySessionPath ); Now you can list the subjects and look at the probes and epochs as in the generic tutorial .","title":"Code block 1.3.1:"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#importing-new-data-into-a-session","text":"The NDI team has been doing this for the moment. We will document this so we can hand it off.","title":"Importing new data into a session"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/","text":"Tutorial 1 Marder Lab data and NDI \u00b6 1.4 Plotting Heart Beats and Spectrograms for PPG data \u00b6 1.4.1 Open an example session \u00b6 Let's open an example session. Let's use our 994_13 example from before. Code block 1.4.1: \u00b6 myDataPath = '/Users/vanhoosr/data/grace' ; mySessionPath = fullfile ( myDataPath , '994_13' ); S = ndi . session . dir ( mySessionPath ); Now let's list all of the subjects Code block 1.4.2: \u00b6 sT = ndi . fun . docTable . subject ( S ) For me, this returns: Code block 1.4.3 (output only, don't type in) \u00b6 sT = 4 x2 table SubjectDocumentIdentifier SubjectLocalIdentifier _____________________________________ ___________________________________ { '412693a357d10010_c0c02febe68548fc' } { 'gdy_0013@marderlab.brandeis.edu' } { '412693a357d10565_c0d01f184e858a0a' } { 'gdy_0014@marderlab.brandeis.edu' } { '412693a357d10ace_c0cfda142fb3d8ae' } { 'gdy_0015@marderlab.brandeis.edu' } { '412693a357d10f57_40b3eae7d7d2dc09' } { 'gdy_0016@marderlab.brandeis.edu' } 1.4.2 Plot a summary of a whole PPG session \u00b6 We can plot a summary of the whole session with the following code: Code block 1.4.4: \u00b6 mlt . plot . HeartBeatsFromDocs ( S ) mlt . plot . SpectrogramsFromDocs ( S ) 1.4.3 Get the heart beat data for a subject and sensor location \u00b6 Use the mlt.doc.* functions. You can see the documentation for the heart beat fields by typing help mlt.beats.beatdocs2struct . Code block 1.4.5 \u00b6 [ heartBeatDocs , HeartBeatData ] = mlt . doc . getHeartBeats ( S , 'gdy_0013@marderlab.brandeis.edu' , 'heart' ); HeartBeatData { 1 }, % display the first structure figure ; plot ([ HeartBeatData { 1 }. onset ],[ HeartBeatData { 1 }. instant_freq ], 'k-' ); xlabel ( 'Time (UTC)' ); ylabel ( 'Instantaneous frequency' ) 1.4.4 Get the spectrogram data for a subject and sensor location \u00b6 Code block 1.4.5 \u00b6 [ SpectrogramDocs , SpectrogramData ] = mlt . doc . getSpectograms ( S , 'gdy_0013@marderlab.brandeis.edu' , 'heart' ); SpectrogramData { 1 }, % display the first structure mlt . plot . Spectrogram ( SpectrogramData { 1 }. spec , SpectrogramData { 1 }. f , SpectrogramData { 1 }. ts ); 1.4.5 Get the heart and spectrogram data all together! \u00b6 mySubjectData = mlt . doc . getHeartBeatAndSpectrogram ( S , 'gdy_0013@marderlab.brandeis.edu' , 'heart' ); mlt . plot . Traces ( S , mySubjectData , 1 ) 1.4.6 Notes: \u00b6 The functions that read from local files where we initially stored the heart beat and spectrogram information are not recommended anymore. We will eventually remove them. These were quick and dirty treatments to get started looking at the data: mlt.plot.HeartBeatsFromFiles - Not recommended mlt.plot.SpectrogramsFromFiles - Not recommended SpectrogramsBeatsOverlayFromFiles - Not recommended 1.4.7 A comprehensive subject trace view \u00b6 A single function, mlt.plot.subjectTrace , provides a comprehensive multi-panel plot that is ideal for detailed inspection of a recording. It combines the spectrogram, raw data trace, normalized data trace, and beat metrics into a single, time-linked figure. Viewing a subject trace \u00b6 You can generate a detailed trace for any subject and record type. For example, to view the 'heart' record for subject 'gdy_0014@marderlab.brandeis.edu', you can use the following command. The showBeats option is useful for visually correlating the detected beat onsets and offsets with the raw and normalized data traces. [ ax , data ]= mlt . plot . subjectTrace ( S , 'gdy_0014@marderlab.brandeis.edu' , 'heart' , 'showBeats' , true ) This will produce a 6-panel plot that includes the spectrogram, the raw data, a z-scored normalized version of the raw data, and plots of the instantaneous beat frequency, amplitude, and duty cycle. Interactive beat marking and curation \u00b6 The mlt.plot.subjectTrace function also includes a powerful interactive mode for curating the beat data. This is essential for correcting errors in the automated beat detection process. To activate the interactive mode, set the markBeats option to true : [ ax , data ]= mlt . plot . subjectTrace ( S , 'gdy_0014@marderlab.brandeis.edu' , 'heart' , 'showBeats' , true , 'markBeats' , true ) When this mode is active, three buttons will appear below the normalized data plot: Bad : Click this button to mark detected beats that are incorrect. A dialog will appear instructing you to click on the normalized data plot near the beats you want to remove. Each click will mark the nearest detected beat with a large gray 'X'. Press Enter when you are finished. Missing : Click this button to add beats that the automated detection missed. A dialog will appear instructing you to click on the normalized data plot where a beat should have occurred. Each click will add a new \"missing\" beat, marked with a large green '+'. Press Enter when you are finished. Save : Click this button to save your work. A file dialog will appear, allowing you to save the curated beat list to a .mat file. The saved file will contain a table with all beats and a 'Status' column indicating whether each beat was 'detected', 'marked bad', or 'marked missing'.","title":"1.4 How to plot heart beats and spectrograms"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#tutorial-1-marder-lab-data-and-ndi","text":"","title":"Tutorial 1 Marder Lab data and NDI"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#14-plotting-heart-beats-and-spectrograms-for-ppg-data","text":"","title":"1.4 Plotting Heart Beats and Spectrograms for PPG data"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#141-open-an-example-session","text":"Let's open an example session. Let's use our 994_13 example from before.","title":"1.4.1 Open an example session"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-141","text":"myDataPath = '/Users/vanhoosr/data/grace' ; mySessionPath = fullfile ( myDataPath , '994_13' ); S = ndi . session . dir ( mySessionPath ); Now let's list all of the subjects","title":"Code block 1.4.1:"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-142","text":"sT = ndi . fun . docTable . subject ( S ) For me, this returns:","title":"Code block 1.4.2:"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-143-output-only-dont-type-in","text":"sT = 4 x2 table SubjectDocumentIdentifier SubjectLocalIdentifier _____________________________________ ___________________________________ { '412693a357d10010_c0c02febe68548fc' } { 'gdy_0013@marderlab.brandeis.edu' } { '412693a357d10565_c0d01f184e858a0a' } { 'gdy_0014@marderlab.brandeis.edu' } { '412693a357d10ace_c0cfda142fb3d8ae' } { 'gdy_0015@marderlab.brandeis.edu' } { '412693a357d10f57_40b3eae7d7d2dc09' } { 'gdy_0016@marderlab.brandeis.edu' }","title":"Code block 1.4.3 (output only, don't type in)"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#142-plot-a-summary-of-a-whole-ppg-session","text":"We can plot a summary of the whole session with the following code:","title":"1.4.2 Plot a summary of a whole PPG session"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-144","text":"mlt . plot . HeartBeatsFromDocs ( S ) mlt . plot . SpectrogramsFromDocs ( S )","title":"Code block 1.4.4:"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#143-get-the-heart-beat-data-for-a-subject-and-sensor-location","text":"Use the mlt.doc.* functions. You can see the documentation for the heart beat fields by typing help mlt.beats.beatdocs2struct .","title":"1.4.3 Get the heart beat data for a subject and sensor location"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-145","text":"[ heartBeatDocs , HeartBeatData ] = mlt . doc . getHeartBeats ( S , 'gdy_0013@marderlab.brandeis.edu' , 'heart' ); HeartBeatData { 1 }, % display the first structure figure ; plot ([ HeartBeatData { 1 }. onset ],[ HeartBeatData { 1 }. instant_freq ], 'k-' ); xlabel ( 'Time (UTC)' ); ylabel ( 'Instantaneous frequency' )","title":"Code block 1.4.5"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#144-get-the-spectrogram-data-for-a-subject-and-sensor-location","text":"","title":"1.4.4 Get the spectrogram data for a subject and sensor location"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-145_1","text":"[ SpectrogramDocs , SpectrogramData ] = mlt . doc . getSpectograms ( S , 'gdy_0013@marderlab.brandeis.edu' , 'heart' ); SpectrogramData { 1 }, % display the first structure mlt . plot . Spectrogram ( SpectrogramData { 1 }. spec , SpectrogramData { 1 }. f , SpectrogramData { 1 }. ts );","title":"Code block 1.4.5"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#145-get-the-heart-and-spectrogram-data-all-together","text":"mySubjectData = mlt . doc . getHeartBeatAndSpectrogram ( S , 'gdy_0013@marderlab.brandeis.edu' , 'heart' ); mlt . plot . Traces ( S , mySubjectData , 1 )","title":"1.4.5 Get the heart and spectrogram data all together!"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#146-notes","text":"The functions that read from local files where we initially stored the heart beat and spectrogram information are not recommended anymore. We will eventually remove them. These were quick and dirty treatments to get started looking at the data: mlt.plot.HeartBeatsFromFiles - Not recommended mlt.plot.SpectrogramsFromFiles - Not recommended SpectrogramsBeatsOverlayFromFiles - Not recommended","title":"1.4.6 Notes:"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#147-a-comprehensive-subject-trace-view","text":"A single function, mlt.plot.subjectTrace , provides a comprehensive multi-panel plot that is ideal for detailed inspection of a recording. It combines the spectrogram, raw data trace, normalized data trace, and beat metrics into a single, time-linked figure.","title":"1.4.7 A comprehensive subject trace view"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#viewing-a-subject-trace","text":"You can generate a detailed trace for any subject and record type. For example, to view the 'heart' record for subject 'gdy_0014@marderlab.brandeis.edu', you can use the following command. The showBeats option is useful for visually correlating the detected beat onsets and offsets with the raw and normalized data traces. [ ax , data ]= mlt . plot . subjectTrace ( S , 'gdy_0014@marderlab.brandeis.edu' , 'heart' , 'showBeats' , true ) This will produce a 6-panel plot that includes the spectrogram, the raw data, a z-scored normalized version of the raw data, and plots of the instantaneous beat frequency, amplitude, and duty cycle.","title":"Viewing a subject trace"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#interactive-beat-marking-and-curation","text":"The mlt.plot.subjectTrace function also includes a powerful interactive mode for curating the beat data. This is essential for correcting errors in the automated beat detection process. To activate the interactive mode, set the markBeats option to true : [ ax , data ]= mlt . plot . subjectTrace ( S , 'gdy_0014@marderlab.brandeis.edu' , 'heart' , 'showBeats' , true , 'markBeats' , true ) When this mode is active, three buttons will appear below the normalized data plot: Bad : Click this button to mark detected beats that are incorrect. A dialog will appear instructing you to click on the normalized data plot near the beats you want to remove. Each click will mark the nearest detected beat with a large gray 'X'. Press Enter when you are finished. Missing : Click this button to add beats that the automated detection missed. A dialog will appear instructing you to click on the normalized data plot where a beat should have occurred. Each click will add a new \"missing\" beat, marked with a large green '+'. Press Enter when you are finished. Save : Click this button to save your work. A file dialog will appear, allowing you to save the curated beat list to a .mat file. The saved file will contain a table with all beats and a 'Status' column indicating whether each beat was 'detected', 'marked bad', or 'marked missing'.","title":"Interactive beat marking and curation"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/","text":"Tutorial 1 Marder Lab data and NDI \u00b6 1.5 Importing data from a session \u00b6 Step 1: Files \u00b6 Make sure you have your files. The files should be a set of Axon Instruments ABF files ( EXP_0000.abf , EXP_0001.abf , etc). EXP is usually a string like 972_120 ; the first number ( 972 ) is the lab notebook number and the second number is the page number where the experiment is written ( 120 ). Your directory might look like this: Step 2: Subjects \u00b6 One needs to make subject files. Some of Grace\u2019s recordings have two subjects. One makes a subject file simply by creating a text file called subject1.txt and subject2.txt etc. The text file has a single name. We\u2019ve been naming Grace\u2019s crabs as gdy007@marderlab.brandeis.edu , etc. Step 3: Bath Table \u00b6 The Marder lab experiments often involve manipulations of the drugs in the bath. Further, the drugs provided to different tissues can vary; the experimenters can make vaseline wells and restrict the perfusion of certain drugs to specific tissues. The bath table is a comma separated file: The mixture strings indicate which mixture(s) in USERPATH/tools/NDIc-marder-matlab/+ndi/+setup/+conv/+marder/+bath/marder_mixtures.json and applies them to targets USERPATH/tools/NDIc-marder-matlab/+ndi/+setup/+conv/+marder/+bath/marder_bathtargets.json Step 5: Initial build of ndi.session object \u00b6 Run the initial setup that uses the files and the text files to build an ndi.session object: S = ndi.setup.conv.marder.presetup(pwd,2) Step 6: Probe table \u00b6 Update the probe table ( probeTable.csv , a text file). For Grace\u2019s project the probeName values should be ppg_heart or ppg_pylorus , as appropriate, the probeType is ppg , and the reference set to be 1 for the first crab, 2 for the second crab, etc. The table for one experiment looks like: Step 7: Do the final post-setup \u00b6 Run the command ndi.setup.conv.marder.postsetup(S)","title":"1.5 Importing new data"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#tutorial-1-marder-lab-data-and-ndi","text":"","title":"Tutorial 1 Marder Lab data and NDI"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#15-importing-data-from-a-session","text":"","title":"1.5 Importing data from a session"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-1-files","text":"Make sure you have your files. The files should be a set of Axon Instruments ABF files ( EXP_0000.abf , EXP_0001.abf , etc). EXP is usually a string like 972_120 ; the first number ( 972 ) is the lab notebook number and the second number is the page number where the experiment is written ( 120 ). Your directory might look like this:","title":"Step 1: Files"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-2-subjects","text":"One needs to make subject files. Some of Grace\u2019s recordings have two subjects. One makes a subject file simply by creating a text file called subject1.txt and subject2.txt etc. The text file has a single name. We\u2019ve been naming Grace\u2019s crabs as gdy007@marderlab.brandeis.edu , etc.","title":"Step 2: Subjects"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-3-bath-table","text":"The Marder lab experiments often involve manipulations of the drugs in the bath. Further, the drugs provided to different tissues can vary; the experimenters can make vaseline wells and restrict the perfusion of certain drugs to specific tissues. The bath table is a comma separated file: The mixture strings indicate which mixture(s) in USERPATH/tools/NDIc-marder-matlab/+ndi/+setup/+conv/+marder/+bath/marder_mixtures.json and applies them to targets USERPATH/tools/NDIc-marder-matlab/+ndi/+setup/+conv/+marder/+bath/marder_bathtargets.json","title":"Step 3: Bath Table"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-5-initial-build-of-ndisession-object","text":"Run the initial setup that uses the files and the text files to build an ndi.session object: S = ndi.setup.conv.marder.presetup(pwd,2)","title":"Step 5: Initial build of ndi.session object"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-6-probe-table","text":"Update the probe table ( probeTable.csv , a text file). For Grace\u2019s project the probeName values should be ppg_heart or ppg_pylorus , as appropriate, the probeType is ppg , and the reference set to be 1 for the first crab, 2 for the second crab, etc. The table for one experiment looks like:","title":"Step 6: Probe table"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-7-do-the-final-post-setup","text":"Run the command ndi.setup.conv.marder.postsetup(S)","title":"Step 7: Do the final post-setup"}]}