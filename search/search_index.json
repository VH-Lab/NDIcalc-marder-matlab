{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NDIcalc-marder-matlab","text":""},{"location":"#about","title":"About","text":"<p>This package contains a set of database document types and code for performing analysis of Marder lab data. It requires and depends on the Neuroscience Data Interface, NDI.</p>"},{"location":"#installation","title":"Installation","text":"<p>Check out the NDI Installation Guide.</p>"},{"location":"#help-and-support","title":"Help and Support","text":"<p>Use the issue tracker to submit questions, bugs, and issues.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Anyone with a GitHub account can contribute. Please see the guidelines below!</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>If you have code that you would like to write, do the following.</p> <ol> <li> <p>Press the Fork button in the upper-right corner of the NDIcalc-marder-matlab GitHub repository to make a copy of NDIcalc-marder-matlab in your own GitHub space.</p> </li> <li> <p>Make your changes to NDIcalc-marder-matlab.</p> </li> <li> <p>Commit your changes back to your fork.</p> </li> <li> <p>Finally, issue a Pull Request on GitHub from your fork. The request will be received by the NDI development team for integration.</p> </li> </ol>"},{"location":"installation/","title":"Installation:","text":"<ol> <li>Install NDI</li> </ol> <p>See the NDI Installation Guide and check out its requirements.</p> <ol> <li> <p>In a terminal or DOS shell, use the function <code>cd</code> to navigate to your user account Matlab documents directory. On a Mac, for example, it is <code>/Users/yourusername/Documents/MATLAB/</code>. Then, navigate to the <code>tools</code> directory within.</p> </li> <li> <p>Finally, clone this repository using <code>git clone https://github.com/VH-Lab/NDIcalc-matlab-matlab</code>.</p> </li> </ol>"},{"location":"documents/heart/ppg_beats/","title":"ppg_beats (ndi.document class)","text":""},{"location":"documents/heart/ppg_beats/#class-definition","title":"Class definition","text":"<p>Class name: ppg_beats Short name: ppg_beats Superclasses: base, epochid</p> <p>Definition: $NDICALCDOCUMENTPATH/heart/ppg_beats.json Schema for validation: $NDICALCSCHEMAPATH/heart/ppg_beats.json Property_list_name: <code>ppg_beats</code> Class_version: <code>1</code></p>"},{"location":"documents/heart/ppg_beats/#ppg_beats-fields","title":"ppg_beats fields","text":"<p>Accessed by <code>ppg_beats.field</code> where field is one of the field names below</p> field default_value data type description detection_parameters fields"},{"location":"documents/heart/ppg_beats/#base-fields","title":"base fields","text":"<p>Accessed by <code>base.field</code> where field is one of the field names below</p> field default_value data type description id session_id name datestamp"},{"location":"documents/heart/ppg_beats/#epochid-fields","title":"epochid fields","text":"<p>Accessed by <code>epochid.field</code> where field is one of the field names below</p> field default_value data type description epochid"},{"location":"documents/heart/spectrogram/","title":"spectrogram (ndi.document class)","text":""},{"location":"documents/heart/spectrogram/#class-definition","title":"Class definition","text":"<p>Class name: spectrogram Short name: spectrogram Superclasses: base, ngrid, epochid</p> <p>Definition: $NDICALCDOCUMENTPATH/heart/spectrogram.json Schema for validation: $NDICALCSCHEMAPATH/heart/spectrogram_schema.json Property_list_name: <code>spectrogram</code> Class_version: <code>1</code></p>"},{"location":"documents/heart/spectrogram/#spectrogram-fields","title":"spectrogram fields","text":"<p>Accessed by <code>spectrogram.field</code> where field is one of the field names below</p> field default_value data type description frequency_ngrid_dim timestamp_ngrid_dim decibels"},{"location":"documents/heart/spectrogram/#base-fields","title":"base fields","text":"<p>Accessed by <code>base.field</code> where field is one of the field names below</p> field default_value data type description id session_id name datestamp"},{"location":"documents/heart/spectrogram/#ngrid-fields","title":"ngrid fields","text":"<p>Accessed by <code>ngrid.field</code> where field is one of the field names below</p> field default_value data type description data_size data_type data_dim coordinates"},{"location":"documents/heart/spectrogram/#epochid-fields","title":"epochid fields","text":"<p>Accessed by <code>epochid.field</code> where field is one of the field names below</p> field default_value data type description epochid"},{"location":"reference/%2Bmlt/graceAnalysisAll.m/","title":"mlt.graceAnalysisAll","text":"<pre><code> GRACEANALYSISALL Runs the complete pre-processing and analysis pipeline for a session.\n\n    mlt.graceAnalysisAll(S)\n\n    This is the main, top-level wrapper function that executes the entire\n    pre-processing and analysis pipeline for all PPG (photoplethysmogram)\n    probes in a given NDI session.\n\n    It performs the following steps in order:\n    1.  Downsamples the raw PPG data to create the '_lp_whole' elements.\n    2.  Calculates spectrograms and saves them as .mat files.\n    3.  Calculates spectrograms and saves them as NDI documents.\n    4.  Detects heart beats and saves them as .mat files.\n    5.  Detects heart beats and saves them as NDI documents.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Run the entire analysis pipeline on a session\n        mlt.graceAnalysisAll(mySession);\n\n    See also mlt.ppg.downsampleAll, mlt.spectrogram.calculateForFiles,\n    mlt.spectrogram.calculateForDocs, mlt.beats.calculateForFiles,\n    mlt.beats.calculateForDocs\n</code></pre>"},{"location":"reference/%2Bmlt/gracedemo.m/","title":"mlt.gracedemo","text":"<pre><code>mlt.gracedemo is a script.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBinQuantize.m/","title":"mlt.beats.beatRateBinQuantize","text":"<pre><code> BEATRATEBINQUANTIZE Quantizes continuous rate data into discrete symbols.\n    [discrete_seq, edges] = mlt.beatRateBinQuantize(rates, NumSymbols)\n    converts a vector of continuous rate data into a sequence of integer\n    symbols from 1 to NumSymbols.\n\n    It uses the quantile function to define the bin edges, which helps\n    ensure that each symbol has a similar number of occurrences in the\n    output sequence, even if the input data is highly skewed.\n\n    INPUTS:\n    rates        - A vector of observed continuous rates.\n    NumSymbols   - The number of discrete symbols to quantize the data into.\n\n    OUTPUTS:\n    discrete_seq - A vector the same length as 'rates' containing the\n                   corresponding integer symbol for each rate.\n    edges        - The vector of bin edges used for quantization.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBins.m/","title":"mlt.beats.beatRateBins","text":"<pre><code> BEATRATEBINS Estimates beat rate in regularly spaced time bins.\n    [rates, bin_centers] = mlt.beats.beatRateBins(beat_times) estimates the heart\n    rate from a vector of beat times (beat_times). The function uses a\n    sliding window approach to calculate the rate at regular intervals.\n\n    The input beat_times can be a numeric vector (assumed to be in seconds)\n    or a datetime vector. The output bin_centers will be of the same type.\n\n    This function is part of the mlt (Marder Lab Tools) namespace.\n\n    SYNTAX:\n    [rates, bin_centers] = mlt.beats.beatRateBins(beat_times)\n    [rates, bin_centers] = mlt.beats.beatRateBins(beat_times, 'deltaT', dt, 'W', w)\n\n    INPUTS:\n    beat_times          - A vector of beat times. Can be a numeric vector\n                          (e.g., seconds from the start of a recording) or a\n                          datetime vector. Must be sorted chronologically.\n\n    OPTIONAL NAME-VALUE PAIR ARGUMENTS:\n    'deltaT'            - The time step (in seconds) between the centers of\n                          consecutive bins.\n                          Default: 0.5 seconds.\n    'W'                 - The total width of the sliding window (in seconds)\n                          used to count beats for each bin.\n                          Default: 5 seconds.\n\n    OUTPUTS:\n    rates               - A vector of the calculated beat rates in beats\n                          per second (Hz) for each bin.\n    bin_centers         - A vector of the timestamps for the center of each\n                          bin. The data type will match the input\n                          'beat_times' (double or datetime).\n\n    EXAMPLE:\n        % Generate some noisy, simulated beat data where rate changes\n        true_rate = @(t) 2 + 0.5 * sin(2*pi*t/60); % Rate oscillates over time\n        t_sim = 0:0.01:120; % 120 seconds of simulation time\n        beats = [];\n        next_beat = 0;\n        while next_beat &lt; 120\n            current_rate = true_rate(next_beat);\n            ibi = 1/current_rate * (1 + 0.1*(rand-0.5)); % Add noise to inter-beat interval\n            next_beat = next_beat + ibi;\n            beats(end+1) = next_beat;\n        end\n\n        % 1. Calculate beat rate with default parameters\n        [rates, centers] = mlt.beats.beatRateBins(beats);\n\n        % 2. Calculate with custom window and step size\n        [rates_custom, centers_custom] = mlt.beats.beatRateBins(beats, 'deltaT', 1, 'W', 10);\n\n        % Plot results\n        figure;\n        plot(beats(2:end), 1./diff(beats), '.', 'Color', [0.7 0.7 0.7], 'DisplayName', 'Instantaneous Rate');\n        hold on;\n        plot(centers, rates, 'b-o', 'LineWidth', 1.5, 'DisplayName', 'Binned Rate (W=5, deltaT=0.5)');\n        plot(centers_custom, rates_custom, 'r-s', 'LineWidth', 1.5, 'DisplayName', 'Binned Rate (W=10, deltaT=1)');\n        plot(t_sim, true_rate(t_sim), 'k--', 'LineWidth', 2, 'DisplayName', 'True Rate');\n        hold off;\n        xlabel('Time (s)');\n        ylabel('Beat Rate (Hz)');\n        title('Heart Beat Rate Estimation');\n        legend;\n        grid on;\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatsdoc2struct.m/","title":"mlt.beats.beatsdoc2struct","text":"<pre><code> BEATSDOC2STRUCT Reads PPG beat data from an NDI document into a structure.\n\n    BEATS = BEATSDOC2STRUCT(S, DOC) reads photoplethysmogram (PPG) beat\n    information associated with a specific NDI document DOC within the\n    context of an NDI session or dataset S. It retrieves the beat data\n    from a binary file ('beats.vhsb'), formats it into a table based on\n    metadata in DOC, and returns the result as a structure array.\n\n    Inputs:\n        S       - An NDI session object (`ndi.session`) or NDI dataset\n                  object (`ndi.dataset`).\n        DOC     - An NDI document object (`ndi.document`) that references\n                  the PPG beat data. This document must contain the\n                  property `ppg_beats.fields` (a comma-separated string\n                  of field names).\n\n    Outputs:\n        BEATS   - A structure array where each element represents a single\n                  PPG beat. The fields of the structure include 'onset', \n                  'offset', 'peak_time', etc.\n\n    See also: MLT.DETECTHEARTBEATSIMPROVED, MLT.ADDBEATS2DOC,\n        VLT.FILE.CUSTOM_FILE_FORMATS.VHSB_READ\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatsstruct2doc.m/","title":"mlt.beats.beatsstruct2doc","text":"<pre><code> ADDBEATS2DOC Adds PPG beat data from a structure to an NDI document.\n\n    DOC_OUT = BEATSSTRUCT2DOC(DOC_IN, BEATS) takes photoplethysmogram (PPG)\n    beat information stored in a structure array BEATS and writes it to a\n    binary file ('beats.vhsb'). It then associates this file with the\n    provided NDI document object DOC_IN.\n\n    Inputs:\n        DOC_IN  - An NDI document object (`ndi.document`) to which the beat\n                  data file will be added.\n        BEATS   - A structure array where each element represents a single\n                  PPG beat. The fields of the structure include time\n                  information (i.e. 'onset', 'offset') and other metrics.\n                  Time fields represented as MATLAB `datetime` are \n                  converted to `datenum` format before saving.\n\n    Outputs:\n        DOC_OUT - The updated NDI document object (`ndi.document`) that now\n                  includes a reference to the newly created 'beats.vhsb' file\n                  containing the beat data.\n\n    See also: MLT.DETECTHEARTBEATSIMPROVED, MLT.BEATS.BEATSDOC2STRUCT,\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForDocs.m/","title":"mlt.beats.calculateForDocs","text":"<pre><code> CALCULATEFORDOCS - Calculate and save heart beat data as NDI documents for a session.\n\n    mlt.beats.calculateForDocs(S)\n\n    This is a high-level wrapper function that automates the process of\n    heart beat detection for all PPG (photoplethysmogram) probes within a\n    given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls the core processing function, mlt.beats.wholeDayHeartBeatDoc,\n    to perform the beat detection and save the results as a 'ppg_beats'\n    NDI document.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.beats.calculateForDocs(mySession);\n\n    See also mlt.beats.wholeDayHeartBeatDoc, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForFiles.m/","title":"mlt.beats.calculateForFiles","text":"<pre><code> CALCULATEFORFILES - Calculate and save heart beat data as .mat files for a session.\n\n    mlt.beats.calculateForFiles(S)\n\n    This is a high-level wrapper function that automates the process of\n    heart beat detection for all PPG (photoplethysmogram) probes within a\n    given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls a core processing function to perform the beat detection\n    and save the results to a standalone .mat file in the session's path.\n\n    The output files are named according to the convention:\n    'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat'\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.beats.calculateForFiles(mySession);\n\n    See also mlt.beats.wholeDayHeartBeatFile, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeats.m/","title":"mlt.beats.detectHeartBeats","text":"<pre><code> DETECTHEARTBEATS Detect heartbeats in a pulsatile signal.\n\n    BEATS = DETECTHEARTBEATS(T, D, OPTIONS) detects heartbeats in a \n    pulsatile signal, such as a photoplethysmography (PPG) signal. \n    The function uses a threshold-based approach to identify \n    individual beats and their characteristics.\n\n    Inputs:\n        T: A vector of timestamps corresponding to the signal. Can be either:\n            - Numeric vector in seconds.\n            - Datetime vector.\n        D: A vector of signal values (e.g., PPG signal).\n        OPTIONS: (Optional) A structure specifying detection parameters:\n            THRESHOLD_HIGH: Upper threshold for beat detection (default: 0.75).\n            THRESHOLD_LOW: Lower threshold for beat detection (default: -0.75).\n            REFRACT: Minimum time between consecutive beats (refractory period, default: 0.2).\n            amplitude_high_min: Minimum amplitude above THRESHOLD_HIGH (default: 0).\n            amplitude_low_min: Minimum amplitude below THRESHOLD_LOW (default: 0).\n            amplitude_min: Minimum peak-to-peak amplitude (default: 0).\n            duration_min: Minimum beat duration (default: 0).\n\n    Outputs:\n        BEATS: A structure array where each element represents a detected beat.\n            Fields include:\n                onset: Beat onset time (datetime if T is datetime, double in seconds otherwise).\n                offset: Beat offset time (datetime if T is datetime, double in seconds otherwise).\n                duty_cycle: Ratio of beat duration to the period between beats (double).\n                period: Time between consecutive beats (double in seconds).\n                instant_freq: Instantaneous heart rate (double in beats per second).\n                amplitude: Peak-to-peak amplitude (double).\n                amplitude_high: Amplitude above THRESHOLD_HIGH (double).\n                amplitude_low: Amplitude below THRESHOLD_LOW (double).\n                valid: Boolean indicating if the beat meets validity criteria.\n                up_duration: Duration of the upward slope of the beat (double in seconds).\n\n    Notes:\n    - The input signal D is assumed to be preprocessed and normalized.\n    - The algorithm detects beats by identifying upward and downward \n      crossings of the specified thresholds.\n    - The validity of each beat is assessed based on amplitude and duration criteria.\n    - The function handles edge cases, such as incomplete beats at the end of the signal.\n    - If T is a datetime vector, the output onset and offset times will be datetime values,\n      while durations, period, and instant_freq will be double values in seconds.\n\n    Example:\n        % Load PPG data with time in seconds\n        %%%%[t_sec, d] = load_ppg_data_seconds somehow; \n        beats_sec = detectHeartBeats(t_sec, d);\n\n        % Load PPG data with datetime values\n        %%%%%[t_datetime, d] = load_ppg_data_datetime somehow\n        beats_datetime = detectHeartBeats(t_datetime, d);\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeatsImproved.m/","title":"mlt.beats.detectHeartBeatsImproved","text":"<pre><code> DETECTHEARTBEATSIMPROVED Detect heartbeats in a pulsatile signal.\n\n    BEATS = DETECTHEARTBEATSIMPROVED(T, D, OPTIONS) detects heartbeats in a \n    pulsatile signal, such as a photoplethysmography (PPG) signal. \n    The function uses a threshold-based approach to identify \n    individual beats and their characteristics.\n\n    Inputs:\n        T: A vector of timestamps corresponding to the signal. Can be either:\n            - Numeric vector in seconds.\n            - Datetime vector.\n        D: A vector of signal values (e.g., PPG signal).\n        OPTIONS: (Optional) A structure specifying detection parameters:\n            threshold_high: Upper threshold for beat detection (default: 0.75).\n            threshold_low: Lower threshold for beat detection (default: -0.75).\n            refractory_period: Minimum time between consecutive beats (refractory period, default: 0.2).\n            amplitude_high_min: Minimum amplitude above THRESHOLD_HIGH (default: 0).\n            amplitude_low_min: Minimum amplitude below THRESHOLD_LOW (default: 0).\n            amplitude_min: Minimum peak-to-peak amplitude (default: 0).\n            duration_min: Minimum beat duration (default: 0).\n\n    Outputs:\n        BEATS: A structure array where each element represents a detected beat.\n            Fields include:\n                onset: Beat onset time (datetime if T is datetime, double in seconds otherwise).\n                offset: Beat offset time (datetime if T is datetime, double in seconds otherwise).\n                duty_cycle: Ratio of beat duration to the period between beats (double).\n                period: Time between consecutive beats (double in seconds).\n                instant_freq: Instantaneous heart rate (double in beats per second).\n                amplitude: Peak-to-peak amplitude (double).\n                amplitude_high: Amplitude above THRESHOLD_HIGH (double).\n                amplitude_low: Amplitude below THRESHOLD_LOW (double).\n                valid: Boolean indicating if the beat meets validity criteria.\n                up_duration: Duration of the upward slope of the beat (double in seconds).\n        OPTIONS: A structure specifying the detection parameters used.\n\n    Notes:\n    - The input signal D is assumed to be preprocessed and normalized.\n    - The algorithm detects beats by identifying upward and downward \n      crossings of the specified thresholds.\n    - The validity of each beat is assessed based on amplitude and duration criteria.\n    - The function handles edge cases, such as incomplete beats at the end of the signal.\n    - If T is a datetime vector, the output onset and offset times will be datetime values,\n      while durations, period, and instant_freq will be double values in seconds.\n\n    Example:\n        % Load PPG data with time in seconds\n        %%%%[t_sec, d] = load_ppg_data_seconds somehow; \n        beats_sec = detectHeartBeats(t_sec, d);\n\n        % Load PPG data with datetime values\n        %%%%%[t_datetime, d] = load_ppg_data_datetime somehow\n        beats_datetime = detectHeartBeats(t_datetime, d);\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValues.m/","title":"mlt.beats.getRawBeatValues","text":"<pre><code> GETRAWBEATVALUES Recalculates beat amplitudes using the raw signal.\n\n    beats_out = mlt.beats.getRawBeatValues(beats_in, t_raw, d_raw)\n\n    This function takes a 'beats' structure, whose timing was likely\n    determined from a normalized signal, and adds new amplitude fields\n    calculated from the original, un-normalized (raw) signal. This is useful\n    for recovering the true physiological amplitudes of detected beats.\n\n    Inputs:\n        beats   - A structure array of detected beats, with at least 'onset'\n                  and 'offset' time fields.\n        t_raw   - The time vector (numeric or datetime) of the raw signal.\n        d_raw   - The raw (un-normalized) signal vector.\n\n    Outputs:\n        beats   - The input 'beats' structure with the following new fields\n                  added to each element:\n                  .rawPeak: The maximum signal value during the beat.\n                  .rawTrough: The minimum signal value in the period\n                              preceding the beat onset.\n                  .rawAmplitude: The peak-to-trough amplitude (rawPeak - rawTrough).\n\n    See also mlt.beats.getRawBeatValuesFromDoc, mlt.beats.detectHeartBeatsImproved\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValuesFromDoc.m/","title":"mlt.beats.getRawBeatValuesFromDoc","text":"<pre><code> GETRAWBEATVALUESFROMDOC Loads beat data and adds raw amplitude values.\n\n    beats_out = mlt.beats.getRawBeatValuesFromDoc(S, name, number)\n\n    This is a high-level function that loads a 'ppg_beats' NDI document\n    for a specified element, reads the corresponding raw (un-normalized)\n    time series data, and then calls mlt.beats.getRawBeatValues to add\n    raw amplitude information to the beats structure.\n\n    Inputs:\n        S       - An ndi.session object.\n        name    - The record name ('pylorus', 'heart', or 'gastric').\n        number  - The record number (a positive integer).\n\n    Outputs:\n        beats_with_raw - The 'beats' structure from the document, with the\n                         new raw amplitude fields (.rawPeak, .rawTrough,\n                         .rawAmplitude) added.\n\n    Example:\n        % Get beats with raw amplitudes for the 'pylorus' element, record 1\n        b_raw = mlt.beats.getRawBeatValuesFromDoc(mySession, 'pylorus', 1);\n\n    See also mlt.beats.getRawBeatValues, mlt.beats.beatsdoc2struct\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatDoc.m/","title":"mlt.beats.wholeDayHeartBeatDoc","text":"<pre><code> WHOLEDAYHEARTBEAT Generate heartbeat record for a whole day's recording.\n\n    [BEATS, D, T] = WHOLEDAYHEARTBEAT(S, OPTIONS) computes heart beat \n    analysis for an entire day's worth of data from an ndi.element, \n    typically 'ppg_heart_lp'. The function reads the data from the \n    specified element and performs heart beat detection.\n\n    Inputs:\n        S: An ndi.session or ndi.dataset object containing the data.\n        OPTIONS: A structure containing optional parameters.\n            e_name: The name of the ndi.element to analyze (default: 'ppg_heart_lp').\n            e_reference: The reference number of the ndi.element (default: 1).\n            zscoreWindowTime: The z-score time window in seconds (default: 3600).\n\n    Outputs:\n        DOC: A document containing the saved beats data\n        BEATS: A structure of heart beat data.\n        D: The data stream used for heart beat detection.\n        T: The timestamps corresponding to the data stream.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatFile.m/","title":"mlt.beats.wholeDayHeartBeatFile","text":"<pre><code> WHOLEDAYHEARTBEAT Generate heartbeat record for a whole day's recording.\n\n    [BEATS, D, T] = WHOLEDAYHEARTBEATFILE(S, OPTIONS) computes heart beat \n    analysis for an entire day's worth of data from an ndi.element, \n    typically 'ppg_heart_lp'. The function reads the data from the \n    specified element and performs heart beat detection.\n\n    Inputs:\n        S: An ndi.session or ndi.dataset object containing the data.\n        OPTIONS: A structure containing optional parameters.\n            e_name: The name of the ndi.element to analyze (default: 'ppg_heart_lp').\n            e_reference: The reference number of the ndi.element (default: 1).\n            zscoreWindowTime: The z-score time window in seconds (default: 3600).\n\n    Outputs:\n        BEATS: A vector of heart beat timestamps.\n        D: The data stream used for heart beat detection.\n        T: The timestamps corresponding to the data stream.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeats.m/","title":"mlt.doc.getHeartBeats","text":"<pre><code> MLT.DOC.GETHEARTBEATS Finds heart beat documents for a unique subject element.\n\n    [HEARTBEAT_DOCS, HEARTBEAT_DATA] = mlt.doc.getHeartBeats(S, SUBJECT_NAME, RECORD_TYPE)\n\n    Searches an NDI session for a UNIQUE element that corresponds to a specific\n    subject and recording location (e.g., 'heart') by calling `mlt.ndi.getElement`.\n    It then finds all associated 'ppg_beats' NDI documents for that single element.\n    If zero or more than one element matches the subject/type criteria, this function will error.\n\n    For each document found, it calls `mlt.doc.heartBeatData` to extract the\n    beat structure, performing time conversions to `datetime` objects if a\n    global clock is available for the epoch.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        SUBJECT_NAME    - The name of the subject (e.g., 'SubjectA') as a\n                          character vector or string.\n        RECORD_TYPE     - The type of record to search for. Must be one of\n                          'heart', 'pylorus', or 'gastric'.\n\n    Outputs:\n        HEARTBEAT_DOCS  - A cell array of all matching 'ppg_beats'\n                          `ndi.document` objects for the single found element.\n        HEARTBEAT_DATA  - A cell array of the same size as HEARTBEAT_DOCS,\n                          where each cell contains the corresponding beat data\n                          structure returned by `mlt.doc.heartBeatData`.\n\n    Example:\n        % Find the heart beat records for 'SubjectB', assuming they have only one 'heart' element.\n        [docs, data] = mlt.doc.getHeartBeats(mySession, 'SubjectB', 'heart');\n\n    See also: mlt.ndi.getElement, mlt.doc.heartBeatData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/getSpectrogramData.m/","title":"mlt.doc.getSpectrogramData","text":"<pre><code> MLT.DOC.GETSPECTROGRAMDATA Finds spectrogram documents for a unique subject element.\n\n    [SPECTROGRAM_DOCS, SPECTROGRAM_DATA] = mlt.doc.getSpectrogramData(S, SUBJECT_NAME, RECORD_TYPE)\n\n    Searches an NDI session for a UNIQUE element that corresponds to a specific\n    subject and recording location (e.g., 'heart') by calling `mlt.ndi.getElement`.\n    It then finds all associated 'spectrogram' NDI documents for that single element.\n    If zero or more than one element matches the subject/type criteria, this function will error.\n\n    For each document found, it calls `mlt.doc.spectrogramData` to extract the\n    spectrogram matrix, frequency vector, and time vector, performing time\n    conversions to `datetime` objects if a global clock is available.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        SUBJECT_NAME    - The name of the subject (e.g., 'SubjectA') as a\n                          character vector or string.\n        RECORD_TYPE     - The type of record to search for. Must be one of\n                          'heart', 'pylorus', or 'gastric'.\n\n    Outputs:\n        SPECTROGRAM_DOCS - A cell array of all matching 'spectrogram'\n                           `ndi.document` objects for the single found element.\n        SPECTROGRAM_DATA - A cell array of the same size as SPECTROGRAM_DOCS.\n                           Each cell contains a structure with the fields:\n                           .spec - The spectrogram data matrix\n                           .f    - The frequency vector\n                           .ts   - The time vector (`datetime` or numeric)\n\n    Example:\n        % Find the spectrogram records for 'SubjectB', assuming they have only one 'heart' element.\n        [docs, data] = mlt.doc.getSpectrogramData(mySession, 'SubjectB', 'heart');\n\n    See also: mlt.ndi.getElement, mlt.doc.spectrogramData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/heartBeatData.m/","title":"mlt.doc.heartBeatData","text":"<pre><code> MLT.DOC.HEARTBEATDATA Retrieves heart beat data from an NDI document with datetime conversion.\n\n    BEATS = mlt.doc.heartBeatData(S, PPG_BEATS_DOC)\n\n    This function accesses the beat information stored in a 'ppg_beats' NDI\n    document.\n\n    A key feature of this function is its handling of time. It inspects the\n    epoch's clock information from the element the document depends on. If a\n    global time clock (e.g., 'exp_global_time') is available for the epoch,\n    the time fields within the returned BEATS structure (e.g., '.onset', '.offset')\n    are converted to MATLAB `datetime` objects. If no global clock is found,\n    these timestamps remain as numeric values in seconds from the start of the epoch.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        PPG_BEATS_DOC   - An 'ppg_beats' ndi.document object.\n\n    Outputs:\n        BEATS           - A structure array where each element represents a\n                          detected beat. Time-related fields will be `datetime`\n                          objects if a global clock is present, otherwise they\n                          will be numeric (seconds).\n\n    Example:\n        % Assume 'mySession' is a valid NDI session object and we have found\n        % a 'ppg_beats' document.\n\n        e = mySession.getelements('element.name', 'ppg_heart_lp_whole', 'element.reference', 1);\n        et = e{1}.epochtable();\n        ppg_beats_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ...\n            e{1}.id(), et(1).epoch_id, 'ppg_beats');\n\n        if ~isempty(ppg_beats_doc)\n            beats_with_datetime = mlt.doc.heartBeatData(mySession, ppg_beats_doc{1});\n\n            % Check the class of the onset time for the first beat\n            disp(['Class of beat onset time: ' class(beats_with_datetime(1).onset)]);\n        end\n\n    See also: mlt.beats.beatsdoc2struct, ndi.time.syncgraph.time_convert\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/spectrogramData.m/","title":"mlt.doc.spectrogramData","text":"<pre><code> MLT.DOC.SPECTROGRAMDATA Retrieves spectrogram data from an NDI document.\n\n    [SPEC, F, TS] = mlt.doc.spectrogramData(S, SPECTROGRAM_DOC)\n\n    This function extracts the full spectrogram data matrix, frequency vector, and\n    time vector from a 'spectrogram' NDI document.\n\n    A key feature of this function is its handling of time. It inspects the\n    epoch's clock information from the element the document depends on. If a\n    global time clock (e.g., 'exp_global_time') is available for the epoch, the\n    output time vector 'TS' is converted to a MATLAB `datetime` object. If no\n    global clock is found, the time vector is returned as numeric values in\n    seconds from the start of the epoch.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        SPECTROGRAM_DOC - A 'spectrogram' ndi.document object.\n\n    Outputs:\n        SPEC            - The spectrogram data matrix, with dimensions\n                          [frequency x time].\n        F               - A column vector of frequencies (Hz) corresponding to\n                          the rows of SPEC.\n        TS              - A column vector of timestamps for the spectrogram.\n                          Will be a `datetime` vector if a global clock is\n                          present, otherwise numeric (seconds).\n\n    Example:\n        % Assume 'mySession' is a valid NDI session object and we have found\n        % a 'spectrogram' document for a pylorus element.\n\n        e_pylorus = mySession.getelements('element.name', 'ppg_pylorus_lp_whole', 'element.reference', 1);\n        et = e_pylorus{1}.epochtable();\n        spectrogram_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ...\n            e_pylorus{1}.id(), et(1).epoch_id, 'spectrogram');\n\n        if ~isempty(spectrogram_doc)\n            [spec_data, freqs, times] = mlt.doc.spectrogramData(mySession, spectrogram_doc{1});\n\n            % Check the class of the time vector\n            disp(['Class of time vector TS: ' class(times)]);\n\n            % Plot the spectrogram\n            figure;\n            imagesc(times, freqs, spec_data);\n            set(gca, 'YDir', 'normal');\n            ylabel('Frequency (Hz)');\n            % datetick('x'); % Use if times are datetime\n        end\n\n    See also: ndi.fun.data.readngrid, ndi.time.syncgraph.time_convert\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/Analysis.m/","title":"mlt.hmm.Analysis","text":"<pre><code> ANALYSIS Performs a full HMM analysis pipeline on beat time data.\n\n    [states, timestamps, rates, state_stats] = mlt.hmm.Analysis(beat_times)\n\n    This high-level function runs a complete Hidden Markov Model (HMM)\n    pipeline. It takes a vector of beat times, calculates a continuous\n    beat rate signal, fits an HMM to this signal, and decodes the most\n    likely sequence of hidden states.\n\n    Inputs:\n        beat_times      - A vector of beat times (numeric seconds or datetime).\n\n    Optional Name-Value Pair Arguments:\n        N (1,1) double = 2\n            Number of hidden states.\n        ModelType (1,1) string = \"gaussian\"\n            Model to use: \"discrete\" or \"gaussian\". The \"gaussian\" model\n            requires Kevin Murphy's Bayes Net Toolbox (BNT).\n        InitialModel (1,1) struct = struct()\n            A pre-trained model struct (from mlt.hmm.fit or mlt.hmm.fitGauss).\n            If provided, the fitting step is skipped and this model is used\n            directly for decoding.\n        deltaT (1,1) double = 0.5\n            Time step for rate binning (seconds).\n        W (1,1) double = 5\n            Window size for rate binning (seconds).\n        (And other model-specific options for fitting...)\n\n    Outputs:\n        states          - Vector of the most likely (sorted) state for each bin.\n        timestamps      - Timestamps for the center of each bin.\n        rates           - The calculated beat rate (Hz) for each bin.\n        state_stats     - N-by-2 matrix of [mean_rate, std_dev_rate] for each state.\n\n    Example 1: Standard Fitting and Visualization\n        % First, load the beat times from a pre-processed _beats.mat file\n        L = load('ppg_ppg_heart_lp_whole_1_beats.mat');\n        beat_times = [L.beats.onset];\n\n        % Perform a 2-state Gaussian HMM analysis using default settings\n        [states, ts, rates, stats] = mlt.hmm.Analysis(beat_times);\n\n        % Visualize the state sequence overlaid on the beat rate\n        mlt.plot.HMMStates(states, ts, rates);\n\n        % Optionally, calculate and plot dwell time distributions\n        DwellStats = mlt.hmm.StateDwellTimes(states, ts);\n        mlt.plot.HMMStateDwellTimes(DwellStats);\n\n    Example 2: Using a Pre-Defined 'InitialModel' to Decode\n        % Define a fixed 2-state Gaussian model struct\n        myFixedModel.prior = [0.2; 0.8];\n        myFixedModel.transmat = [0.9 0.1; 0.1 0.9];\n        % BNT requires specific dimensions: [ObsDim x NumStates x NumMixes]\n        myFixedModel.mu = reshape([0 1], [1 2 1]);\n        % BNT requires specific dimensions: [ObsDim x ObsDim x NumStates x NumMixes]\n        myFixedModel.Sigma = reshape([0.05, 1], [1 1 2 1]);\n        myFixedModel.mixmat = ones(2, 1); % For a single Gaussian per state\n        myFixedModel.StateRemap = [1 2];\n\n        % Run analysis, which will now skip the fitting step\n        [states, ts, rates, stats] = mlt.hmm.Analysis(beat_times, ...\n            'ModelType', 'gaussian', ...\n            'InitialModel', myFixedModel);\n\n    See also mlt.hmm.fit, mlt.hmm.decode, mlt.hmm.fitGauss, mlt.hmm.decodeGauss, mlt.plot.HMMStates\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/StateDwellTimes.m/","title":"mlt.hmm.StateDwellTimes","text":"<pre><code> STATEDWELLTIMES Calculates and histograms the dwell time for each HMM state.\n\n    DwellStats = mlt.hmm.StateDwellTimes(states, timestamps)\n\n    Takes the state sequence output from mlt.hmm.Analysis and calculates the\n    duration of each consecutive period spent in a given state. It then\n    computes a histogram of these durations for each state.\n\n    Inputs:\n        states          - A vector of integer state assignments, e.g., from\n                          mlt.hmm.Analysis.\n        timestamps      - A vector of timestamps corresponding to each state\n                          assignment. Can be numeric (seconds) or datetime.\n                          Must be evenly spaced.\n\n    Optional Name-Value Pair Arguments:\n        timeBins        - A vector of bin edges for the histogram.\n                          Default: 100 log-spaced bins from 0.1s to 3600s.\n\n    Outputs:\n        DwellStats      - A structure array with one entry for each state.\n                          Each element has the fields:\n                          - .state: The state number.\n                          - .histBinTimes: The center time of each histogram bin (s).\n                          - .histBinCount: The number of dwells in each bin.\n\n    Example &amp; Plotting:\n        % First, run the main analysis pipeline\n        [states, timestamps] = mlt.hmm.Analysis(beat_times);\n\n        % Now, calculate the dwell time statistics\n        DwellStats = mlt.hmm.StateDwellTimes(states, timestamps);\n\n        % Finally, generate the plot with the dedicated plotting function\n        mlt.plot.HMMStateDwellTimes(DwellStats);\n\n    See also mlt.hmm.Analysis, mlt.plot.HMMStateDwellTimes, histcounts\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/decode.m/","title":"mlt.hmm.decode","text":"<pre><code> DECODE Finds the most likely state sequence using the Viterbi algorithm.\n\n    STATES = mlt.hmm.decode(rates, TRANS, EMIS, fit_info)\n\n    Calculates the most likely sequence of hidden states for a discrete HMM\n    given a sequence of continuous observations ('rates').\n\n    It uses the 'fit_info' struct from mlt.hmm.fit to discretize the rate\n    data and then remaps the output states to match the sorted order\n    from the fitting step.\n\n    Inputs:\n        rates       - A vector of observed continuous rates.\n        TRANS       - An N-by-N state transition matrix from mlt.hmm.fit.\n        EMIS        - The emission probability matrix from mlt.hmm.fit.\n        fit_info    - The fit_info struct output by mlt.hmm.fit.\n\n    Outputs:\n        states      - A vector the same length as 'rates' containing the\n                      most likely sequence of hidden states (sorted 1 to N).\n\n    Example:\n        % Assume 'training_rates' and 'new_rates' are vectors of data\n\n        % 1. Fit an HMM to a training dataset\n        num_states = 4;\n        [TRANS_est, EMIS_est, fit_info] = mlt.hmm.fit(training_rates, num_states);\n\n        % 2. Decode a new sequence of rates using the fitted model\n        most_likely_states = mlt.hmm.decode(new_rates, TRANS_est, EMIS_est, fit_info);\n\n    See also mlt.hmm.fit, hmmviterbi\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/decodeGauss.m/","title":"mlt.hmm.decodeGauss","text":"<pre><code> DECODEGAUSS Finds the most likely state sequence for a Gaussian HMM.\n\n    STATES = mlt.hmm.decodeGauss(rates, model)\n\n    Calculates the most likely sequence of hidden states for an HMM with\n    Gaussian emissions using the Viterbi algorithm.\n\n    *** REQUIRES KEVIN MURPHY'S BAYES NET TOOLBOX (BNT) ***\n\n    Inputs:\n        rates   - A vector of observed continuous rates.\n        model   - The trained Gaussian HMM model struct from mlt.hmm.fitGauss.\n\n    Outputs:\n        states  - A vector of the most likely (sorted) state for each time point.\n\n    Example:\n        % Assume 'training_rates' and 'new_rates' are vectors of data\n\n        % 1. Fit a Gaussian HMM to a training dataset\n        num_states = 4;\n        model = mlt.hmm.fitGauss(training_rates, num_states);\n\n        % 2. Decode a new sequence of rates using the fitted model\n        most_likely_states = mlt.hmm.decodeGauss(new_rates, model);\n\n    See also mlt.hmm.fitGauss, viterbi_path\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/fit.m/","title":"mlt.hmm.fit","text":"<pre><code> FIT Fits a discrete HMM and characterizes states by rate statistics.\n\n    [TRANS, EMIS, state_stats, fit_info] = mlt.hmm.fit(rates, N)\n\n    Fits an N-state Hidden Markov Model (HMM) to the provided rate data. It\n    uses a discrete emission model, which is required by MATLAB's hmmtrain\n    function. To do this, it first quantizes the continuous rate data into a\n    finite number of symbols.\n\n    After fitting, it characterizes each state by the mean and standard\n    deviation of the continuous rates that were assigned to it. The states\n    are then sorted and re-ordered based on this mean rate (lowest to highest).\n\n    Inputs:\n        rates       - A vector of observed rates, e.g., from mlt.beats.beatRateBins.\n        N           - The number of hidden states for the model.\n\n    Optional Name-Value Pair Arguments:\n        NumSymbols (1,1) double = 10\n            The number of discrete symbols to quantize the 'rates' data into.\n        MaxIterations (1,1) double = 100\n            Maximum number of iterations for the Baum-Welch algorithm.\n        Tolerance (1,1) double = 1e-4\n            Convergence tolerance for the Baum-Welch algorithm.\n\n    Outputs:\n        TRANS       - An N-by-N matrix of sorted state transition probabilities.\n        EMIS        - An N-by-NumSymbols sorted emission probability matrix.\n        state_stats - An N-by-2 matrix where column 1 is the mean rate\n                      and column 2 is the std. dev. of the rate for each\n                      sorted state.\n        fit_info    - A struct containing information (quantization edges and\n                      state remapping) needed for decoding new data with\n                      mlt.hmm.decode.\n\n    Example:\n        % Assume 'training_rates' is a vector of beat-to-beat rates\n        num_states = 4;\n        [TRANS, EMIS, stats, info] = mlt.hmm.fit(training_rates, num_states);\n\n        % Now you can use these outputs to decode a new rate sequence:\n        % decoded_states = mlt.hmm.decode(new_rates, TRANS, EMIS, info);\n\n    See also mlt.hmm.decode, hmmtrain, hmmviterbi\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/fitGauss.m/","title":"mlt.hmm.fitGauss","text":"<pre><code> FITGAUSS Fits a Hidden Markov Model with Gaussian emissions using BNT.\n    MODEL = mlt.hmm.fitGauss(rates, N) fits an N-state HMM to the\n    continuous rate data using Gaussian distributions for the emissions. The\n    states are sorted by their mean emission rate (lowest to highest).\n\n    *** REQUIRES KEVIN MURPHY'S BAYES NET TOOLBOX (BNT) ***\n    Download from: https://github.com/bayesnet/bnt\n    And add to your MATLAB path using: addpath(genpath('path/to/bnt'))\n\n    Inputs:\n        rates           - A vector of observed continuous rates.\n        N               - The number of hidden states for the model.\n\n    Optional Name-Value Pair Arguments:\n        MaxIterations   - Maximum number of iterations for the EM algorithm.\n                          Default: 100.\n\n    Outputs:\n        model           - A struct containing the trained and sorted HMM\n                          parameters, ready for use with mlt.hmm.decodeGauss.\n\n    Example:\n        % Assume 'training_rates' is a vector of your data\n        num_states = 4;\n        model = mlt.hmm.fitGauss(training_rates, num_states);\n\n        % The 'model' struct can now be used to decode new sequences:\n        % decoded_states = mlt.hmm.decodeGauss(new_rates, model);\n\n    See also mlt.hmm.decodeGauss, mhmm_em, kmeans\n</code></pre>"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/findInhibitoryBouts.m/","title":"mlt.inhibitoryBouts.findInhibitoryBouts","text":"<pre><code> MLT.FINDINHIBITORYBOUTS Identifies inhibitory bouts from beat time data.\n    bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times) analyzes a vector of beat\n    times to identify periods of significant heart rate slowdown (inhibition)\n    and the subsequent recovery.\n\n    The function first calculates the beat rate in sliding time windows. It\n    then iterates through the rate data to find onsets and offsets.\n\n    SYNTAX:\n    bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times)\n    bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times, Name, Value, ...)\n\n    INPUTS:\n    beat_times          - A vector of beat times (numeric seconds or datetime).\n\n    OPTIONAL NAME-VALUE PAIR ARGUMENTS:\n    'deltaT'            - The time step (in seconds) for rate binning.\n                          Default: 0.5 seconds.\n    'W'                 - The total width of the sliding window (in seconds)\n                          for rate binning.\n                          Default: 5 seconds.\n    'InhibitoryBoutSlowDownOnsetThreshold' - The fractional threshold for\n                          detecting an inhibitory bout onset.\n                          Default: 0.5 (i.e., a 50% slowdown).\n    'InhibitoryBoutEndOnsetThreshold' - The fractional threshold for\n                          detecting the end of a bout.\n                          Default: 1.5 (i.e., a 150% speedup).\n    'InhibitoryBoutOnsetOffsetTimeWindow' - The duration (in seconds) over\n                          which the rate change is evaluated.\n                          Default: 1 second.\n\n    OUTPUTS:\n    bouts               - A structure with four fields:\n                          .inhibitoryBoutOnset: A vector of timestamps for\n                            the start of each detected inhibitory bout.\n                          .inhibitoryBoutOffset: A vector of timestamps for\n                            the end of each detected inhibitory bout.\n                          .beatRate: The vector of binned beat rates (Hz).\n                          .beatRateTimes: The timestamps for each binned rate.\n\n    EXAMPLE:\n        beat_times = [ (0:0.4:10), (10.5:1:20), (20.4:0.4:30) ]';\n        bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times);\n        % The 'bouts' struct now contains onsets, offsets, and the rate data.\n</code></pre>"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibBoutAnalysis.m/","title":"mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis","text":"<pre><code> MLT.inhibitoryBouts.SPECTROGRAMINHIBBOUTANALYSIS Analyze spectrogram FWHM around inhibition bout times.\n\n    [SPECDATA_MATRIX, F, FWHM_VECTOR, LOW_CUTOFF_VECTOR, HIGH_CUTOFF_VECTOR] = ...\n        mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis(E, INHIBBOUTTIMES, SKIP, TIMEWINDOW)\n\n    Analyzes the spectrogram associated with an ndi.element E around specified\n    inhibition bout times. For each time provided in INHIBBOUTTIMES, it defines\n    a time window starting at INHIBBOUTTIMES(i) + SKIP and lasting for\n    TIMEWINDOW seconds. It calculates the time-averaged spectrogram within that\n    window and computes its Full Width at Half Maximum (FWHM).\n\n    Inputs:\n        E              - An ndi.element object. The session is retrieved from e.session.\n                         The element should have associated 'spectrogram' documents.\n        INHIBBOUTTIMES - A vector of Matlab datetime objects indicating the\n                         start times of inhibition bouts.\n        SKIP           - A double scalar indicating the time offset in seconds\n                         relative to each inhibBoutTime to start the analysis window.\n                         Can be positive or negative.\n        TIMEWINDOW     - A double scalar indicating the duration in seconds of the\n                         analysis window. Can be positive (window goes forward\n                         from start) or negative (window goes backward from start).\n\n    Outputs:\n        SPECDATA_MATRIX   - A matrix where each column is the time-averaged\n                            power spectrum (column vector) calculated for the\n                            window corresponding to each entry in INHIBBOUTTIMES.\n                            If analysis fails for a specific bout time, the\n                            corresponding column might be omitted or filled\n                            with NaNs depending on downstream processing needs\n                            (currently, only successful results are concatenated).\n                            Returns [] if no successful analyses are performed.\n        F                 - The frequency vector (numeric column vector)\n                            corresponding to the rows of SPECDATA_MATRIX. Assumes\n                            the frequency vector is consistent across all analyses.\n                            Returns [] if no successful analyses are performed.\n        FWHM_VECTOR       - A row vector containing the FWHM value for each\n                            successfully analyzed time window. Contains NaN for\n                            windows where calculation failed or was not possible.\n        LOW_CUTOFF_VECTOR - A row vector containing the lower frequency cutoff\n                            at half maximum for each successfully analyzed window.\n                            Contains NaN for windows where calculation failed.\n        HIGH_CUTOFF_VECTOR- A row vector containing the upper frequency cutoff\n                            at half maximum for each successfully analyzed window.\n                            Contains NaN for windows where calculation failed.\n\n    Requires:\n        - NDI toolbox (+ndi)\n        - vhlab-toolbox-matlab (+vlt), specifically vlt.signal.fwhm\n        - NDIcalc-marder-matlab (+mlt), specifically mlt.spectrograph.readSpectrogramTimeWindow\n          and this function (mlt.inhibitoryBouts..spectrogramInhibBoutAnalysis).\n        - Associated helper functions like `ndi.fun.data.readngrid` (if not standard)\n</code></pre>"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibitoryBoutOnsetOffsetAnalysis.m/","title":"mlt.inhibitoryBouts.spectrogramInhibitoryBoutOnsetOffsetAnalysis","text":"<pre><code> MLT.SPECTROGRAMINHIBITORYBOUTONSETOFFSETANALYSIS Analyze spectrogram FWHM around inhibition bout onset/offset times.\n\n    [ONSETDATA, OFFSETDATA] = mlt.spectrogramInhibitoryBoutOnsetOffsetAnalysis(S, RECORD_NAME, ...\n        REFERENCE, INHIBBOUTONSETS, INHIBBOUTOFFSETS, SKIP, TIMEWINDOW)\n\n    Analyzes the spectrogram associated with a specified PPG element ('ppg_heart_lp_whole'\n    or 'ppg_pylorus_lp_whole') within session S. It focuses on time windows\n    relative to inhibition bout onset and offset times.\n\n    This function calls `mlt.spectrogramInhibBoutAnalysis` twice:\n    1. For Onsets: It analyzes windows calculated relative to INHIBBOUTONSETS.\n       The window for onset(i) starts at onset(i) - SKIP - TIMEWINDOW and ends\n       at onset(i) - SKIP.\n    2. For Offsets: It analyzes windows calculated relative to INHIBBOUTOFFSETS.\n       The window for offset(i) starts at offset(i) + SKIP and ends at\n       offset(i) + SKIP + TIMEWINDOW.\n\n    It returns the aggregated results for the onset and offset analyses in\n    separate structures.\n\n    Inputs:\n        S                 - An ndi.session or ndi.dataset object.\n        RECORD_NAME       - Character vector or string: 'heart' or 'pylorus'.\n        REFERENCE         - Positive integer scalar: The reference number of the element.\n        INHIBBOUTONSETS   - Column vector of Matlab datetime objects indicating inhibition bout onset times.\n        INHIBBOUTOFFSETS  - Column vector of Matlab datetime objects indicating inhibition bout offset times.\n                            Must be the same size as INHIBBOUTONSETS.\n        SKIP              - Non-negative double scalar: Time offset in seconds used to define\n                            the near edge of the analysis window relative to onset/offset. Allows 0.\n        TIMEWINDOW        - Positive double scalar: Duration in seconds of the analysis window.\n\n    Outputs:\n        ONSETDATA         - Structure containing results from analyzing windows before onsets:\n            .specData_matrix   - Matrix of time-averaged spectra (freq x bouts).\n            .f                 - Frequency vector (column).\n            .fwhm_vector       - Row vector of FWHM values (NaN if failed).\n            .low_cutoff_vector - Row vector of low cutoffs (NaN if failed).\n            .high_cutoff_vector- Row vector of high cutoffs (NaN if failed).\n        OFFSETDATA        - Structure containing results from analyzing windows after offsets:\n            .specData_matrix   - Matrix of time-averaged spectra (freq x bouts).\n            .f                 - Frequency vector (column).\n            .fwhm_vector       - Row vector of FWHM values (NaN if failed).\n            .low_cutoff_vector - Row vector of low cutoffs (NaN if failed).\n            .high_cutoff_vector- Row vector of high cutoffs (NaN if failed).\n                            Returns empty structures with NaN vectors if the\n                            specified element is not found or analysis fails.\n\n    Requires:\n        - NDI toolbox (+ndi)\n        - vhlab-toolbox-matlab (+vlt), specifically vlt.signal.fwhm (used by mlt.spectrogramFWHM)\n        - NDIcalc-marder-matlab (+mlt), specifically mlt.spectrogramFWHM,\n          mlt.readSpectrogramTimeWindow, and this function\n          (mlt.spectrogramInhibitoryBoutOnsetOffsetAnalysis).\n        - Associated helper functions like `ndi.fun.data.readngrid` (if not standard)\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bndi/getElement.m/","title":"mlt.ndi.getElement","text":"<pre><code> GETELEMENT Finds a unique NDI element based on subject and record type.\n\n    ELEM = mlt.ndi.getElement(S, subject_name, record_type, [element_label])\n\n    Searches the NDI session S to find a single, unique ndi.element object\n    that corresponds to the given subject and record type. It performs a\n    database query to find element documents that match all criteria.\n\n    This function will raise an error if zero or more than one element matches\n    the search criteria.\n\n    Inputs:\n        S             - An ndi.session or ndi.dataset object.\n        subject_name  - The name of the subject (e.g., 'SubjectA').\n        record_type   - The type of record ('heart', 'gastric', or 'pylorus').\n        element_label - (Optional) A further label to identify the element.\n                        Defaults to 'lp_whole'.\n\n    Outputs:\n        elem          - The single matching ndi.element object.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HMMStateDwellTimes.m/","title":"mlt.plot.HMMStateDwellTimes","text":"<pre><code> HMMSTATEDWELLTIMES Plots dwell time histograms for Hidden Markov Model (HMM) states.\n\n    FIG_HANDLE = mlt.plot.HMMStateDwellTimes(DwellStats)\n\n    Creates a figure with up to a 2x2 subplot layout, showing the dwell\n    time distribution for each HMM state on a logarithmic time axis. This\n    function is designed to work directly with the output structure from\n    the mlt.hmm.StateDwellTimes function.\n\n    Inputs:\n        DwellStats - A structure array output from mlt.hmm.StateDwellTimes.\n                     It must contain the fields \"state\", \"histBinTimes\",\n                     and \"histBinCount\".\n\n    Outputs:\n        fig_handle - A handle to the created figure.\n\n    Example:\n        % First, run the HMM analysis pipeline and calculate dwell times\n        [states, timestamps] = mlt.hmm.Analysis(beat_times);\n        DwellStats = mlt.hmm.StateDwellTimes(states, timestamps);\n\n        % Now, generate the plot with a single command\n        fig_handle = mlt.plot.HMMStateDwellTimes(DwellStats);\n\n    See also mlt.hmm.Analysis, mlt.hmm.StateDwellTimes\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HMMStates.m/","title":"mlt.plot.HMMStates","text":"<pre><code> HMMSTATES Plots HMM states and beat rates on a dual-y-axis plot.\n\n    AX = mlt.plot.HMMStates(states, timestamps, rates)\n\n    Creates a plot that visualizes the output of an HMM analysis. It plots\n    the continuous beat rate signal on the left y-axis and the corresponding\n    discrete HMM state sequence on the right y-axis.\n\n    The y-axes are scaled relative to each other for intuitive comparison:\n    - The value '1' on the right (State) axis aligns with '0' on the left\n      (Rate) axis.\n    - The highest state number on the right axis aligns with the maximum\n      value of the plotted rate data on the left axis.\n\n    Inputs:\n        states          - A vector of integer HMM state assignments.\n        timestamps      - A vector of time values (numeric or datetime)\n                          corresponding to the states and rates.\n        rates           - A vector of beat rates (Hz) corresponding to the\n                          timestamps.\n\n    Optional Name-Value Pair Arguments:\n        Linewidth (1,1) double = 1.5\n            Line width for both the rate and state plots.\n        RateColor (1,3) double = [0 0.4470 0.7410] (MATLAB blue)\n            Color for the beat rate plot.\n        StateColor (1,3) double = [0.8500 0.3250 0.0980] (MATLAB orange)\n            Color for the HMM state plot.\n\n    Outputs:\n        ax              - A struct containing the handles to the two axes\n                          (ax.RateAxis and ax.StateAxis).\n\n    Example:\n        % First, run the main analysis pipeline to get the required inputs\n        L = load('ppg_ppg_heart_lp_whole_1_beats.mat');\n        beat_times = [L.beats.onset];\n        [states, timestamps, rates, ~] = mlt.hmm.Analysis(beat_times);\n\n        % Now, generate the specialized plot\n        ax = mlt.plot.HMMStates(states, timestamps, rates);\n\n    See also mlt.hmm.Analysis, yyaxis\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeat.m/","title":"mlt.plot.HeartBeat","text":"<pre><code> HEARTBEAT - Plot PPG signal and derived heart beat data in a new figure.\n\n    AX = mlt.plot.HeartBeat(BEATS, D, T)\n\n    Plots heart beat statistics derived from a photoplethysmogram (PPG).\n    It generates a new figure with three stacked and linked subplots:\n    1) The PPG signal with beat onsets/offsets marked.\n    2) The instantaneous beat frequency over time.\n    3) The duty cycle of each beat over time.\n\n    Inputs:\n        beats - A structure array containing heartbeat information. Each\n                element must have the following fields:\n                .onset      (double | datetime) Time of the heartbeat onset.\n                .offset     (double | datetime) Time of the heartbeat offset.\n                .valid      (logical) True if the beat is valid.\n                .instant_freq (double) Instantaneous frequency (Hz).\n                .duty_cycle (double) Duty cycle of the heartbeat.\n        d     - A column vector of the PPG signal data.\n        t     - A column vector of time values for the PPG data. This can\n                be numeric (in seconds) or a datetime vector. Note: If\n                numeric, the x-axis of the plot will be converted to hours.\n\n    Optional Name-Value Pairs:\n        Linewidth (1,1) double = 1\n            Specifies the line width for the frequency and duty cycle plots.\n\n    Outputs:\n        ax    - A 3x1 vector of axes handles for the three subplots\n                (PPG, beat frequency, duty cycle).\n\n    Example 1: Basic usage with numeric time vector\n        % Assuming 'beats', 'd', and 't' (in seconds) are defined:\n        ax = mlt.plot.HeartBeat(beats, d, t);\n\n    Example 2: Specifying a custom linewidth\n        ax = mlt.plot.HeartBeat(beats, d, t, 'Linewidth', 2);\n\n    See also PLOT, SUBPLOT, LINKAXES.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromDocs.m/","title":"mlt.plot.HeartBeatsFromDocs","text":"<pre><code> HEARTBEATFROMDOCS - Plots beat statistics overlaid on the raw PPG signal.\n\n    AX = mlt.plot.HeartBeatFromDocs(S)\n\n    This function visualizes pre-calculated heart beat statistics for each\n    subject and record type in an NDI session. It overlays the statistics on\n    top of the **raw, unnormalized** PPG signal.\n\n    It uses helper functions to find the relevant 'ppg_beats' documents and raw\n    signal data. A separate figure is generated for each unique element found.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object containing the PPG data.\n\n    Optional Name-Value Pairs:\n        Linewidth (1,1) double = 1;\n            The line width for the plotted lines.\n\n    Outputs:\n        AX - A column vector of axes handles from all generated plots.\n\n    Example:\n        ax = mlt.plot.HeartBeatFromDocs(mySession, 'Linewidth', 1.5);\n\n    See also mlt.plot.HeartBeat, mlt.doc.getHeartBeats, mlt.ppg.getRawData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromFiles.m/","title":"mlt.plot.HeartBeatsFromFiles","text":"<pre><code> HEARTBEATSFROMFILES - Plots beat statistics overlaid on the raw PPG signal.\n\n    AX = mlt.plot.HeartBeatsFromFiles(S)\n\n    This function visualizes pre-calculated heart beat statistics by\n    overlaying them on top of the **raw, unnormalized** PPG signal.\n\n    It loads data from pre-processed MAT-files found within the NDI session\n    path. These files contain beat statistics (e.g., onset, frequency) that\n    were derived from a **normalized** version of the data (using a rolling\n    z-score), as well as the original raw PPG signal for the plot background.\n\n    The MAT-files are assumed to follow the naming convention:\n    'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat'\n    ...where AREA is the recording site (e.g., 'heart', 'pylorus') and\n    NUMBER is the element's reference number.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object containing the PPG data.\n\n    Optional Name-Value Pairs:\n        Linewidth (1,1) double = 1;\n            The line width for the plotted lines.\n\n    Outputs:\n        AX - A column vector of axes handles. Each set of 3 axes handles\n             (for the 3 subplots in a figure) is concatenated vertically.\n\n    Example 1: Basic usage\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.HeartBeatsFromFiles(mySession);\n\n    Example 2: Specifying a custom line width\n        ax = mlt.plot.HeartBeatsFromFiles(mySession, 'Linewidth', 2);\n\n    See also mlt.plot.HeartBeat, ndi.session, ndi.dataset\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/Spectrogram.m/","title":"mlt.plot.Spectrogram","text":"<pre><code> GRACEPLOTSPECTROGRAM Plots a spectrogram.\n\n    gracePlotSpectrogram(SPEC, F, TS, OPTIONS) plots a spectrogram in the current axes.\n\n    Plots the spectrogram, applying dB/linear conversions as specified in OPTIONS.\n    Plots time in hours if TS is in seconds, or uses datetime values directly.\n\n    Input Arguments:\n        SPEC: Spectrogram data (matrix).\n        F: Frequency vector.\n        TS: Time vector (double in seconds or datetime).\n        OPTIONS: (Optional) Structure containing options.\n            OPTIONS.convertDBtoLinear: Logical, convert dB to linear (default true).\n            OPTIONS.convertLinearToDB: Logical, convert linear to dB (default false).\n            OPTIONS.shading: Shading style ('faceted', 'flat', or 'interp', default 'flat').\n            OPTIONS.drawLabels: Logical, whether to draw axis labels (default true).\n            OPTIONS.colorbar: Logical, whether to draw a colorbar (default false).\n            OPTIONS.maxColorPercentile:  The percentile of data to use as\n                                        the maximum value for the color scale. (default 99).\n            OPTIONS.colormapName: Name of the colormap to use (default 'parula').\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsBeatsOverlayFromFiles.m/","title":"mlt.plot.SpectrogramsBeatsOverlayFromFiles","text":"<pre><code> SPECTROGRAMBEATSOVERLAYFROMFILES - Plots spectrograms with a heart beat frequency overlay.\n\n    AX = mlt.plot.SpectrogramBeatsOverlayFromFiles(S)\n\n    This function visualizes the relationship between instantaneous heart beat\n    frequency and the spectral content of a PPG signal. For each PPG probe in\n    the NDI session, it plots a spectrogram and overlays the beat frequency\n    trace on top.\n\n    The function loads data from two separate, pre-calculated MAT-files for\n    each probe. It searches for these files in the NDI session's path using\n    the following naming conventions:\n\n    1. Spectrogram File: 'ppg_ppg_AREA_lp_whole_NUMBER.mat'\n       (Must contain 'spec', 'f', and 'ts' variables)\n    2. Beats File: 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat'\n       (Must contain a 'beats' struct)\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the spectrogram data to use as the maximum\n            value for the color scale (0-100).\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot').\n        numSubplots (1,1) double = 10\n            The number of vertical subplots to prepare in the figure.\n\n    Outputs:\n        ax - A column vector of axes handles for the generated subplots.\n\n    Example:\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.SpectrogramBeatsOverlayFromFiles(mySession);\n\n    See also mlt.plot.Spectrogram, mlt.plot.HeartBeatFromFiles\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromDocs.m/","title":"mlt.plot.SpectrogramsFromDocs","text":"<pre><code> SPECTROGRAMSFROMDOCS - Plot spectrograms from NDI document data.\n\n    AX = mlt.plot.SpectrogramsFromDocs(S)\n\n    Plots spectrograms for all 'ppg' probes found within an ndi.session or\n    ndi.dataset object S. The spectrograms for all probes are plotted as\n    subplots within a single figure.\n\n    This function queries the NDI database for documents of type 'spectrogram'\n    associated with each PPG element. It then reads the spectrogram data,\n    frequency vector, and time vector directly from the NDI document and\n    its associated binary data store.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the data to use as the maximum value for the\n            color scale, clipping extreme values. Must be between 0 and 100.\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot', 'gray').\n        numSubplots (1,1) double = 4\n            The number of vertical subplots to prepare in the figure.\n\n    Outputs:\n        ax - A column vector of axes handles for the generated subplots.\n\n    Example 1: Basic usage\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.SpectrogramsFromDocs(mySession);\n\n    Example 2: Plot with 8 subplots and a different colormap\n        ax = mlt.plot.SpectrogramsFromDocs(mySession, 'numSubplots', 8, 'colormapName', 'jet');\n\n    See also mlt.plot.Spectrogram, ndi.session, ndi.document\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromFiles.m/","title":"mlt.plot.SpectrogramsFromFiles","text":"<pre><code> SPECTROGRAMSFROMFILES - Plot spectrograms for PPG elements from pre-calculated files.\n\n    AX = mlt.plot.SpectrogramsFromFiles(S)\n\n    Plots spectrograms for all 'ppg' probes found within an ndi.session or\n    ndi.dataset object S. The spectrograms for all probes are plotted as\n    subplots within a single figure.\n\n    This function searches the NDI session's path for pre-calculated MAT-files\n    that contain spectrogram data. These files are assumed to be named\n    according to the convention:\n\n    'ppg_ppg_AREA_lp_whole_NUMBER.mat'\n\n    ...where AREA is the recording site (e.g., 'heart', 'pylorus') and\n    NUMBER is the element's reference number. Each file must contain the\n    variables: 'spec' (the spectrogram data), 'f' (frequency vector), and\n    'ts' (time vector).\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the data to use as the maximum value for the\n            color scale, clipping extreme values. Must be between 0 and 100.\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot', 'gray').\n        numSubplots (1,1) double = 10\n            The number of vertical subplots to prepare in the figure.\n\n    Outputs:\n        ax - A column vector of axes handles for the generated subplots.\n\n    Example 1: Basic usage\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.SpectrogramsFromFiles(mySession);\n\n    Example 2: Plot with color bars and a different colormap\n        ax = mlt.plot.SpectrogramsFromFiles(mySession, 'colorbar', true, 'colormapName', 'hot');\n\n    See also mlt.plot.gracePlotSpectrogram, imagesc, colormap\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/gracePlotAll.m/","title":"mlt.plot.gracePlotAll","text":"<pre><code> GRACEPLOTALL - Plot all summary data for an NDI session/dataset.\n\n    mlt.plot.gracePlotAll(S)\n\n    Generates a comprehensive set of plots summarizing photoplethysmogram\n    (PPG) data from an ndi.session or ndi.dataset object S. It creates\n    three separate figures:\n        1. Spectrograms of the PPG data.\n        2. Heartbeat statistics plots (raw PPG, frequency, duty cycle).\n        3. Spectrograms with overlaid heartbeat frequency.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Whether to display colorbars for the spectrogram plots.\n\n        colormapName (1,:) char = 'parula'\n            The colormap to use for the spectrogram plots.\n\n        maxColorPercentile (1,1) double = 99\n            The percentile of spectrogram data to use as the maximum\n            value for the color scale (for contrast enhancement).\n\n        Linewidth (1,1) double = 1\n            The line width for the heartbeat statistics plots.\n\n    Details:\n        This function calls three other functions to generate the plots:\n            1. mlt.plot.SpectrogramsFromFiles\n            2. mlt.plot.HeartBeatsFromFiles\n            3. mlt.plot.SpectrogramBeatsOverlayFromFiles\n\n        The function then links the x-axes across all generated figures,\n        ensuring that zooming and panning are synchronized.\n\n    Example 1: Basic Usage\n        mlt.plot.gracePlotAll(mySession);\n\n    Example 2: Name-value pair inputs\n        mlt.plot.gracePlotAll(mySession, 'colorbar', true, ...\n            'colormapName', 'hot', 'Linewidth', 1.5);\n\n    See also mlt.plot.SpectrogramsFromFiles, mlt.plot.HeartBeatsFromFiles,\n    mlt.plot.SpectrogramBeatsOverlayFromFiles, linkaxes\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutONOFF.m/","title":"mlt.plot.plotInhibitoryBoutONOFF","text":"<pre><code> MLT.PLOT.PLOTINHIBITORYBOUTONOFF Plots binned beat rates with bout events.\n    ax = mlt.plotInhibitoryBoutONOFF(bouts) creates a plot of the binned\n    beat rate over time and overlays vertical lines indicating the onset\n    (RED) and offset (BLUE) of inhibitory bouts.\n\n    The function uses the binned rate data stored within the 'bouts'\n    structure, which should be generated by mlt.inhibitoryBouts.findInhibitoryBouts.\n\n    SYNTAX:\n    ax = mlt.plot.plotInhibitoryBoutONOFF(bouts)\n\n    INPUTS:\n    bouts               - The output structure from mlt.inhibitoryBouts.findInhibitoryBouts.\n                          It must contain the fields:\n                          .beatRate\n                          .beatRateTimes\n                          .inhibitoryBoutOnset\n                          .inhibitoryBoutOffset\n\n    OUTPUTS:\n    ax                  - The handle to the axes of the generated plot.\n\n    EXAMPLE:\n        % 1. Create synthetic beat data\n        beat_times = [ (0:0.4:10), (10.5:1:20), (20.4:0.4:30) ]';\n\n        % 2. Find the inhibitory bouts (which now includes rate data)\n        bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times);\n\n        % 3. Plot the results directly from the bouts structure\n        figure;\n        ax = mlt.plot.plotInhibitoryBoutONOFF(bouts);\n        title('Inhibitory Bout Detection');\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutOnsetOffset.m/","title":"mlt.plot.plotInhibitoryBoutOnsetOffset","text":"<pre><code> MLT.PLOT.PLOTINHIBITORYBOUTONSETOFFSET Plot spectrogram analysis results around onset/offset.\n\n    AX = mlt.plot.plotInhibitoryBoutOnsetOffset(ONSETDATA, OFFSETDATA, Name, Value, ...)\n\n    Creates a 3-panel figure summarizing the spectrogram analysis results\n    obtained from `mlt.spectrogram.spectrogramInhibitoryBoutOnsetOffsetAnalysis`.\n\n    Inputs:\n        ONSETDATA  - Structure containing results from analyzing windows before onsets:\n            .specData_matrix   - Matrix of time-averaged spectra (freq x bouts).\n            .f                 - Frequency vector (column).\n            .fwhm_vector       - Row vector of FWHM values.\n            .low_cutoff_vector - Row vector of low cutoffs.\n            .high_cutoff_vector- Row vector of high cutoffs.\n        OFFSETDATA - Structure containing results from analyzing windows after offsets\n                     (same fields as ONSETDATA).\n\n    Optional Name/Value Pair Arguments:\n        CapSize    - (Default: 15) Numeric scalar specifying the size of the\n                     error bar caps in points for the FWHM plot.\n\n    Outputs:\n        AX         - A 3x1 vector of axes handles for the three subplots created.\n\n    Figure Panels:\n        1. Top Panel: Plots the absolute value of individual time-averaged spectra\n           (gray lines) and the mean absolute spectrum (black line) for the\n           OnsetData vs. frequency. Title: 'Prior to onset'. Y-axis: 'Power'.\n           X-axis: 'Frequency (Hz)'.\n        2. Middle Panel: Plots the absolute value of individual time-averaged spectra\n           (gray lines) and the mean absolute spectrum (black line) for the\n           OffsetData vs. frequency. Title: 'After offset'. Y-axis: 'Power'.\n           X-axis: 'Frequency (Hz)'.\n        3. Bottom Panel: Bar graph comparing a modified FWHM measure\n           (high_cutoff - max(0, low_cutoff)) between OnsetData and OffsetData.\n           Individual data points are overlaid with jitter. Error bars show SEM\n           (plotted thicker, brought to front, cap size adjustable).\n           Title displays the p-value from a paired t-test between the groups.\n           Y-axis: 'FWHM (Hz)'. X-axis labels: 'Onset', 'Offset'.\n\n    Requires:\n        - NDI toolbox (+ndi)\n        - vhlab-toolbox-matlab (+vlt), specifically vlt.signal.fwhm (used by mlt.spectrogram.spectrogramFWHM)\n        - NDIcalc-marder-matlab (+mlt), specifically mlt.spectrogram.spectrogramFWHM,\n          mlt.spectrogram.readSpectrogramTimeWindow, and this function\n          (mlt.plot.plotInhibitoryBoutOnsetOffset).\n        - Associated helper functions like `ndi.fun.data.readngrid` (if not standard)\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/subjectTrace.m/","title":"mlt.plot.subjectTrace","text":"<pre><code> SUBJECTTRACE Plots a detailed summary trace for a single subject and record.\n\n    AX = mlt.plot.subjectTrace(S, subject_name, record_type)\n\n    Generates a comprehensive 4-panel plot for a single recording from a\n    specific subject. It loads the pre-calculated spectrogram and heart beat\n    data from their respective NDI documents and visualizes them together.\n\n    The layout consists of:\n    - Top Panel (50%): Spectrogram.\n    - Bottom Panels: Three plots showing beat instantaneous frequency, \n      amplitude, and duty cycle over time.\n\n    All four plot axes are linked horizontally for synchronized zooming and panning.\n\n    Inputs:\n        S             - An ndi.session or ndi.dataset object.\n        subject_name  - The name of the subject (e.g., 'SubjectA').\n        record_type   - The type of record ('heart', 'gastric', or 'pylorus').\n\n    Optional Name-Value Pair Arguments:\n        Linewidth (1,1) double = 1.5\n            Line width for the time-series plots.\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the data to use as the maximum value for the\n            color scale, clipping extreme values. Must be between 0 and 100.\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot', 'gray').\n\n    Outputs:\n        ax - A struct containing the handles to the four subplot axes.\n\n    Example:\n        % Plot a summary for Subject A's heart recording\n        ax = mlt.plot.subjectTrace(mySession, 'SubjectA', 'heart');\n\n    See also mlt.ndi.getElement, mlt.spectrogram.readTimeWindow, mlt.beats.beatsdoc2struct\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bppg/downsample.m/","title":"mlt.ppg.downsample","text":"<pre><code>  DOWNSAMPLE - downsample PPG data for Marder experiments\n\n  DOWNSAMPLE(S)\n\n  Downsample all ppg probes for an ndi.session or ndi.dataset S.\n\n  Downsamples probes of type 'ppg' by adding '_lp' to their name.\n\n  After downsampling, an element with a single epoch of the ppg record is made\n  by adding '_lp_whole' to the element name. This element is returned in \n  ELEM_OUT_O.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bppg/getRawData.m/","title":"mlt.ppg.getRawData","text":"<pre><code> MLT.PPG.GETRAWDATA Retrieves the raw time series data for a unique PPG element.\n\n    [D, T] = mlt.ppg.getRawData(S, SUBJECT_NAME, RECORD_TYPE, [ELEMENT_LABEL])\n\n    This function finds a unique NDI element for a given subject and record\n    type and returns its entire raw time series data. It uses\n    `mlt.ndi.getElement` to perform the search.\n\n    The function also handles time conversion. If the element's epoch is associated\n    with a global experiment clock, the output time vector 'T' will be a `datetime`\n    vector. Otherwise, it will be a numeric vector in seconds from the start of\n    the recording.\n\n    Inputs:\n        S             - An ndi.session or ndi.dataset object.\n        SUBJECT_NAME  - The name of the subject (e.g., 'SubjectA').\n        RECORD_TYPE   - The type of record ('heart', 'gastric', or 'pylorus').\n        ELEMENT_LABEL - (Optional) A further label to identify the element.\n                        Defaults to 'lp_whole'.\n\n    Outputs:\n        D             - The raw data vector (unnormalized).\n        T             - The time vector (`datetime` or numeric seconds).\n\n    Example:\n        % Get the raw heart PPG data for SubjectA\n        [data, time] = mlt.ppg.getRawData(mySession, 'SubjectA', 'heart');\n\n        % Plot the raw data\n        figure;\n        plot(time, data);\n        title('Raw PPG Signal for SubjectA');\n        xlabel('Time');\n\n    See also: mlt.ndi.getElement, ndi.element.readtimeseries\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/FWHM.m/","title":"mlt.spectrogram.FWHM","text":"<pre><code> FWHM Calculates time-averaged spectrogram and its Full Width at Half Maximum.\n\n    [specData_avg, f, fwhm_val, low_cutoff, high_cutoff] = ...\n        mlt.spectrogram.FWHM(e, t0, t1)\n\n    Calculates the time-averaged power spectrum and its full width at half\n    maximum (FWHM) for a given ndi.element 'e' within a specified time\n    window [t0, t1].\n\n    This function first retrieves the spectrogram data for the specified\n    window and then performs the FWHM calculation on the time-averaged result.\n\n    Inputs:\n        e  - An ndi.element object that has associated 'spectrogram' documents.\n        t0 - A datetime object representing the start of the analysis window.\n        t1 - A datetime object representing the end of the analysis window.\n\n    Outputs:\n        specData_avg - A column vector of the power spectrum averaged over time.\n                       Returns empty if no data is found in the window.\n        f            - The corresponding frequency vector (column vector).\n        fwhm_val     - The full width at half maximum (FWHM) of the spectrum (Hz).\n                       Returns NaN if FWHM cannot be calculated.\n        low_cutoff   - The lower frequency cutoff at half maximum height (Hz).\n        high_cutoff  - The upper frequency cutoff at half maximum height (Hz).\n\n    Example:\n        % Assuming 'my_element' is a valid ndi.element with spectrograms\n        t_start = datetime('2025-09-05 10:00:00');\n        t_end = datetime('2025-09-05 10:05:00');\n        [spec_avg, f, fwhm] = mlt.spectrogram.FWHM(my_element, t_start, t_end);\n\n        % Plot the time-averaged spectrum and its FWHM\n        if ~isempty(spec_avg)\n            figure;\n            plot(f, spec_avg);\n            title(['FWHM: ' num2str(fwhm, '%.2f') ' Hz']);\n            xlabel('Frequency (Hz)');\n            ylabel('Average Power');\n            grid on;\n        end\n\n    See also mlt.spectrogram.readTimeWindow, vlt.signal.fwhm\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForDocs.m/","title":"mlt.spectrogram.calculateForDocs","text":"<pre><code> CALCULATEFORDOCS - Calculate and save PPG spectrograms as NDI documents.\n\n    mlt.spectrogram.calculateForDocs(S)\n\n    This is a high-level wrapper function that automates the process of\n    calculating spectrograms for all PPG (photoplethysmogram) probes within\n    a given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls the core processing function, mlt.wholeDaySpectrogramDoc,\n    to perform the spectrogram calculation and save the results as a\n    'spectrogram' NDI document.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.spectrogram.calculateForDocs(mySession);\n\n    See also mlt.wholeDaySpectrogramDoc, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForFiles.m/","title":"mlt.spectrogram.calculateForFiles","text":"<pre><code> CALCULATEFORFILES - Calculate and save PPG spectrograms as .mat files.\n\n    mlt.spectrogram.calculateForFiles(S)\n\n    This is a high-level wrapper function that automates the process of\n    calculating spectrograms for all PPG (photoplethysmogram) probes within\n    a given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls a core processing function to perform the spectrogram\n    calculation and saves the results to a standalone .mat file in the\n    session's path.\n\n    The output files are named according to the convention:\n    'ppg_ELEMENT-NAME_REFERENCE.mat'\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.spectrogram.calculateForFiles(mySession);\n\n    See also mlt.wholeDaySpectrogram, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/readTimeWindow.m/","title":"mlt.spectrogram.readTimeWindow","text":"<pre><code> READTIMEWINDOW Read the first matching spectrogram data within a time window.\n\n    [spectrogram_data, f, t_datetime, spectrogram_doc] = ...\n        mlt.spectrogram.readTimeWindow(e, t0, t1)\n\n    Searches an NDI session for 'spectrogram' documents associated with a\n    given ndi.element 'e'. It finds the first document that temporally\n    overlaps with the window [t0, t1], reads the spectrogram data, and\n    returns only the portion of the data that falls within the window.\n\n    Inputs:\n        e  - An ndi.element object. The session is retrieved from e.session.\n        t0 - A datetime object representing the start of the window.\n        t1 - A datetime object representing the end of the window.\n\n    Outputs:\n        spectrogram_data - The portion of the spectrogram data (numeric matrix,\n                           typically [frequency x time]) that falls within the\n                           [t0, t1] window. Returns [] if no match is found.\n        f                - The frequency vector (column vector) for the data.\n        t_datetime       - A datetime vector for the time axis of the returned data.\n        spectrogram_doc  - The ndi.document object from which the data was extracted.\n\n    Logic:\n        1. Finds all 'spectrogram' documents that depend on the element 'e'.\n        2. For each document, it checks if the document's epoch overlaps with [t0, t1].\n        3. For the first overlapping document, it reads the full ngrid data.\n        4. It converts the data's local timestamps to the session's global time clock.\n        5. It filters the data and timestamps to the requested [t0, t1] window.\n        6. It returns the filtered data and exits. If no match is found, it returns empty.\n\n    Example:\n        % Assuming 'my_element' is a valid ndi.element with spectrograms\n        t_start = datetime('2025-09-05 10:00:00');\n        t_end = datetime('2025-09-05 10:05:00');\n        [spec, freq, time] = mlt.spectrogram.readTimeWindow(my_element, t_start, t_end);\n        if ~isempty(spec)\n            imagesc(time, freq, spec);\n            set(gca, 'YDir', 'normal');\n        end\n\n    See also mlt.spectrogram.FWHM, ndi.session.database_search, ndi.time.syncgraph.time_convert\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogram.m/","title":"mlt.spectrogram.wholeDaySpectrogram","text":"<pre><code> WHOLEDAYSPECTROGRAM Computes a spectrogram for a complete NDI element recording.\n\n    [SPEC, F, TS] = mlt.spectrogram.wholeDaySpectrogram(S, Name, Value, ...)\n\n    Calculates a spectrogram for the entire duration of a specified\n    ndi.element. The function has two primary modes of operation based on\n    the time clocks available for the element's first epoch.\n\n    1.  **Global Clock Mode**: If an 'exp_global_time' clock is found, the\n        function reads the entire time series at once. It then applies a\n        Z-score normalization (either moving or global) to the signal before\n        computing the spectrogram with `mlt.util.computeSpectrogram`.\n\n    2.  **Epoch-by-Epoch Mode**: If no global clock is found, the function\n        iterates through each epoch of the element individually. It computes a\n        spectrogram for each epoch using `mlt.util.makeSpectrogram`, optionally\n        downsamples the result, and concatenates the pieces to form a single,\n        continuous output.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        e_name ('ppg_heart_lp')\n            The name of the ndi.element to analyze.\n        e_reference (1)\n            The reference number of the ndi.element.\n        f (0.1:0.1:10)\n            A vector of frequencies (Hz) to analyze in the spectrogram.\n        windowTime (10)\n            The duration of the sliding window (in seconds) used for the\n            spectrogram calculation.\n        downSample (2)\n            (Epoch-by-Epoch Mode Only) The factor by which to downsample the\n            time dimension of the spectrogram for each epoch. For example, a\n            value of 2 keeps every other time point.\n        zscoreWindowTime (3600)\n            (Global Clock Mode Only) The duration of the moving window (in\n            seconds) for z-score normalization. If set to 0, a global z-score\n            is applied across the entire signal.\n\n    Outputs:\n        spec - The computed spectrogram data matrix ([frequency x time]).\n        f    - The frequency vector (Hz) corresponding to the rows of 'spec'.\n        ts   - The time vector corresponding to the columns of 'spec'. The\n               units are datenum in Global Clock Mode and seconds from the\n               start in Epoch-by-Epoch Mode.\n\n    Example:\n        % Calculate a spectrogram for a specific element\n        [spec, f, ts] = mlt.spectrogram.wholeDaySpectrogram(mySession, ...\n            'e_name', 'ppg_pylorus_lp_whole', 'e_reference', 1);\n\n        % Plot the result\n        figure;\n        imagesc(ts, f, spec);\n        set(gca, 'YDir', 'normal');\n        xlabel('Time');\n        ylabel('Frequency (Hz)');\n\n    See also mlt.util.computeSpectrogram, mlt.util.makeSpectrogram, mlt.util.movzscore, ndi.element\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogramDoc.m/","title":"mlt.spectrogram.wholeDaySpectrogramDoc","text":"<pre><code> WHOLEDAYSPECTROGRAMDOC Computes and saves a spectrogram as an NDI document.\n\n    [DOC] = mlt.spectrogram.wholeDaySpectrogramDoc(S, Name, Value, ...)\n\n    Calculates a spectrogram for the entire duration of a specified\n    ndi.element and saves the result as an NDI document in the session's\n    database. This function is a key step in pre-processing data for later\n    analysis.\n\n    The function has two primary modes of operation based on the time clocks\n    available for the element's first epoch:\n\n    1.  **Continuous Mode**: If a 'dev_local_time' clock is found, the\n        function reads the entire time series for that epoch at once. It\n        then applies a Z-score normalization before computing the spectrogram.\n\n    2.  **Epoch-by-Epoch Mode**: If no local clock is found, the function\n        iterates through each epoch of the element individually, computes a\n        spectrogram for each, and concatenates the results.\n\n    After calculation, the function creates an 'spectrogram' type NDI document,\n    writes the spectrogram data to a binary .ngrid file, links the file to\n    the document, and adds the document to the database. **Note:** If a\n    spectrogram document for this element's first epoch already exists, it\n    will be removed and replaced.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        e_name ('ppg_heart_lp_whole')\n            The name of the ndi.element to analyze.\n        e_reference (1)\n            The reference number of the ndi.element.\n        f (0.1:0.1:10)\n            A vector of frequencies (Hz) to analyze in the spectrogram.\n        windowTime (10)\n            The duration of the sliding window (in seconds) for the calculation.\n        downSample (2)\n            (Epoch-by-Epoch Mode Only) The factor by which to downsample the\n            time dimension of the spectrogram.\n        zscoreWindowTime (3600)\n            (Continuous Mode Only) The duration of the moving window (in\n            seconds) for z-score normalization. If set to 0, a global z-score\n            is applied across the entire signal.\n\n    Outputs:\n        doc - The ndi.document object that was created and added to the database.\n\n    Example:\n        % Calculate a spectrogram and save it as a document for a specific element\n        doc = mlt.spectrogram.wholeDaySpectrogramDoc(mySession, ...\n            'e_name', 'ppg_pylorus_lp_whole', 'e_reference', 1);\n\n    See also mlt.spectrogram.wholeDaySpectrogram, ndi.document, ndi.session.database_add\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/computeChunkedSpectrogram.m/","title":"mlt.util.computeChunkedSpectrogram","text":"<pre><code> COMPUTECHUNKEDSPECTROGRAM Calculates a spectrogram for discontinuously sampled data.\n\n    [spectrogram_data, f, t_s] = computeChunkedSpectrogram(data, t, ...)\n\n    This function is designed to compute a spectrogram for time-series data\n    that may contain gaps or discontinuities in its sampling. It works by\n    identifying large jumps in the time vector, splitting the data into\n    continuous chunks, computing a spectrogram for each chunk, and then\n    concatenating the results.\n\n    This preserves the temporal integrity of the recording, and the output\n    time vector 't_s' will reflect the original gaps.\n\n    Inputs:\n        data - A numeric column vector of time-series data.\n        t    - A numeric or datetime column vector of timestamps for the data.\n\n    Optional Name-Value Pair Arguments:\n        frequencies (1,:) double = 0.1:0.1:10\n            A vector of frequencies (Hz) to evaluate in the spectrogram.\n        windowSizeTime (1,1) double = 10\n            The duration of the sliding window in seconds.\n        useDecibels (1,1) logical = true\n            If true, converts the output power spectrogram to decibels (10*log10(P)).\n        timeIsDatenum (1,1) logical = false\n            If true, the input time vector 't' is treated as MATLAB datenum values.\n        gapThresholdFactor (1,1) double = 2\n            A factor that is multiplied by the median sample interval to\n            determine the time difference that constitutes a gap. Any jump\n            in time greater than this threshold will split the data.\n\n    Outputs:\n        spectrogram_data - The concatenated spectrogram data matrix ([frequency x time]).\n        f                - The frequency vector (Hz) corresponding to the rows.\n        t_s              - The concatenated time vector for the columns. Its type\n                           (numeric or datetime) matches the input time vector 't'\n                           and it will contain the same time gaps.\n\n    See also spectrogram, diff, median\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/computeSpectrogram.m/","title":"mlt.util.computeSpectrogram","text":"<pre><code> COMPUTESPECTROGRAM Calculates a spectrogram with specific toolbox defaults.\n\n    [spectrogram_data, f, t_s] = mlt.util.computeSpectrogram(data, t, ...)\n\n    This is the core spectrogram calculation engine for the toolbox. It serves\n    as a wrapper around MATLAB's built-in `spectrogram` function, providing\n    convenient handling of time vectors (including datetime and datenum) and\n    conversion of the output power to decibels.\n\n    Inputs:\n        data - A numeric column vector of time-series data.\n        t    - A numeric or datetime column vector of timestamps for the data.\n\n    Optional Name-Value Pair Arguments:\n        frequencies (1,:) double = 0.1:0.1:10\n            A vector of frequencies (Hz) to evaluate in the spectrogram.\n        windowSizeTime (1,1) double = 10\n            The duration of the sliding window in seconds.\n        useDecibels (1,1) logical = true\n            If true, converts the output power spectrogram to decibels (10*log10(P)).\n        timeIsDatenum (1,1) logical = false\n            If true, the input time vector 't' is treated as MATLAB datenum values\n            instead of seconds.\n\n    Outputs:\n        spectrogram_data - The computed spectrogram data matrix ([frequency x time]).\n        f                - The frequency vector (Hz) corresponding to the rows.\n        t_s              - The time vector for the columns. Its type (numeric or\n                           datetime) matches the input time vector 't'.\n\n    Example:\n        % Create a sample signal: 2 Hz sine wave for 60 seconds\n        fs = 100; % 100 Hz sampling rate\n        t = (0:1/fs:60-1/fs)';\n        data = sin(2*pi*2*t) + 0.5*randn(size(t));\n        freqs_of_interest = 0:0.5:10;\n\n        [spec, f, ts] = mlt.util.computeSpectrogram(data, t, ...\n            'frequencies', freqs_of_interest, 'windowSizeTime', 5);\n\n    See also spectrogram, datetime, log10\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/makeSpectrogram.m/","title":"mlt.util.makeSpectrogram","text":"<pre><code> MAKESPECTROGRAM Computes a spectrogram for a single NDI element epoch.\n\n    [spectrogram_data, f, t_s] = mlt.util.makeSpectrogram(ndi_element_obj, ...\n        epoch_id, frequencies, windowSizeTime)\n\n    This function serves as a convenient wrapper to compute a spectrogram for\n    the entire time series of a single, specified epoch from an NDI element.\n    It reads the data, normalizes it with a global z-score, and then calls\n    the core `mlt.util.spectrogram` function to perform the calculation.\n\n    Inputs:\n        ndi_element_obj - An ndi.element object.\n        epoch_id        - The character vector or string ID for the epoch to\n                          be analyzed.\n        frequencies     - A vector of frequencies (Hz) to be used in the\n                          spectrogram calculation.\n        windowSizeTime  - The desired window size in seconds.\n\n    Outputs:\n        spectrogram_data - The spectrogram data matrix ([frequency x time]).\n        f                - The frequency vector (Hz) used in the calculation.\n        t_s              - The time vector (seconds) for the spectrogram output.\n\n    Example:\n        % Assume 'my_element' is a valid ndi.element and 'epoch001' is an\n        % ID from its epoch table.\n        freqs = 0.1:0.1:10; % 0.1 to 10 Hz\n        win_sec = 10;       % 10-second window\n        [spec, f, t] = mlt.util.makeSpectrogram(my_element, 'epoch001', freqs, win_sec);\n\n    See also mlt.util.spectrogram, ndi.element.readtimeseries, zscore\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/movzscore.m/","title":"mlt.util.movzscore","text":"<pre><code> MOVZSCORE - Moving z-score calculation.\n\n    Computes the moving z-score of the input data X using a sliding window.\n    The z-score is calculated for each element by centering and scaling\n    the element with the mean and standard deviation of its k neighbors.\n\n    Syntax:\n        Z = MOVZSCORE(X, k)\n            Calculates the moving z-score using a window of length k.\n\n        Z = MOVZSCORE(X, [kb kf])\n            Calculates the moving z-score using a directional window, where\n            kb is the number of elements before and kf is the number of\n            elements after the current element.\n\n        Z = MOVZSCORE(..., Options)\n            Specifies additional options using name-value pairs.\n\n    Input Arguments:\n        X - Input data.\n            Vector, matrix, multidimensional array, table, or timetable.\n\n        k - Window length.\n            Numeric or duration scalar.\n\n        [kb kf] - Directional window length.\n            Numeric or duration row vector containing two elements.\n            kb: Number of elements before the current element.\n            kf: Number of elements after the current element.\n\n        Options - Optional parameters specified as name-value pairs.\n            'Weight'        - Weight indicator for standard deviation.\n                              0 (default): Normalization by N-1.\n                              1: Normalization by N.\n\n            'Dimension'     - Dimension to operate along.\n                              Positive integer scalar.\n\n            'NaNFlag'       - Missing value handling.\n                              'includemissing' (default) or 'includenan': Include NaN/missing values.\n                              'omitmissing' or 'omitnan': Exclude NaN/missing values.\n\n            'Endpoints'     - Method to treat leading and trailing windows.\n                              'shrink' (default): Window shrinks at edges.\n                              'discard': Discard edge values (not supported for tables).\n                              'fill': Fill edge values with NaN.\n                              Numeric or logical scalar: Fill edge values with scalar.\n\n            'SamplePoints'  - Sample points for computation.\n                              Vector.\n\n            'DataVariables' - Table or timetable variables to operate on.\n                              Table variable name, scalar, vector, cell array,\n                              pattern, function handle, or table vartype subscript.\n                              Default: Numeric variables.\n\n            'ReplaceValues' - Replace original values with z-scores.\n                              true (default) or 1: Replace original values.\n                              false or 0: Append z-scores as new variables.\n\n    Output Arguments:\n        Z - Moving z-score.\n            Same type and size as X, or table/timetable with appended z-score\n            variables depending on the 'ReplaceValues' option.\n\n    Example:\n        x = randn(100, 1);\n        z = movzscore(x, 10); % Moving z-score with window length 10.\n\n        x = table(randn(10, 2), randn(10, 2), 'VariableNames', {'A', 'B', 'C', 'D'});\n        z = movzscore(x, 3, 'DataVariables', {'A', 'C'}, 'ReplaceValues', false);\n\n    See also: MOVMEAN, MOVSTD.\n\n    Notes:\n        - When 'Endpoints' is 'discard' and X is a table, 'Endpoints' is\n          automatically set to 'fill' with a warning.\n        - If 'DataVariables' is not specified for tables, numeric variables\n          are used by default.\n\n    Error Handling:\n        - 'MOVZSCORE:endpointsDiscardTabular' : When 'Endpoints' is 'discard' and X is a table.\n        - 'MOVZSCORE:defaultDataVariables' : When DataVariables is not specified for tables.\n        - 'MOVZSCORE:invalidDataVariables' : When DataVariables is an unsupported datatype.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/mscohere.m/","title":"mlt.util.mscohere","text":"<pre><code> MLT.MSCOHERE Computes magnitude-squared coherence with convenient defaults.\n\n    [cxy, f] = mlt.util.mscohere(X, Y, dt) computes the magnitude-squared\n    coherence estimate between time series X and Y. It is a wrapper for\n    the built-in MATLAB `mscohere` function from the Signal Processing\n    Toolbox, tailored for ease of use with specific defaults.\n\n    SYNTAX:\n    [cxy, f] = mlt.util.mscohere(X, Y, dt)\n    [cxy, f] = mlt.util.mscohere(X, Y, dt, Name, Value, ...)\n\n    INPUTS:\n    X           - First time series, specified as a column vector.\n    Y           - Second time series, specified as a column vector. Must be\n                  the same length as X.\n    dt          - The time step (sampling interval) of the time series, in\n                  seconds. The sampling frequency is calculated as 1/dt.\n\n    OPTIONAL NAME-VALUE PAIR INPUTS:\n    'window_length' - Length of the windowing function. The frequency\n                      resolution is determined by Fs/window_length.\n                      Default: 256\n\n    'n_overlap'     - Number of samples by which consecutive windows overlap.\n                      A 50% overlap is generally a good choice.\n                      Default: 128\n\n    'n_fft'         - Number of points for the Fast Fourier Transform.\n                      Note: This function specifies the exact frequencies\n                      to compute via 'freq_vector', so 'n_fft' is not\n                      passed to the underlying MATLAB function. It is\n                      retained here as a parameter for documentation and\n                      potential future use.\n                      Default: 256\n\n    'freq_vector'   - A column vector of frequencies (in Hz) at which to\n                      compute the coherence. This provides direct control\n                      over the output frequency range.\n                      Default: (0:0.1:10)'\n\n    OUTPUTS:\n    cxy         - The magnitude-squared coherence, returned as a column\n                  vector. Values range from 0 to 1.\n    f           - The vector of frequencies (in Hz) corresponding to the\n                  coherence estimates in cxy.\n\n    EXAMPLE:\n    % Create two signals with a common component at 5 Hz\n    Fs = 200;               % Sampling frequency\n    dt = 1/Fs;              % Time step\n    t = (0:dt:10-dt)';      % Time vector (10 seconds)\n\n    common_signal = 0.5 * sin(2*pi*5*t);\n    noise1 = 0.8 * randn(size(t));\n    noise2 = 0.8 * randn(size(t));\n\n    x = common_signal + noise1;\n    y = common_signal + noise2;\n\n    % Compute coherence using the function's defaults (0-10 Hz)\n    [cxy, f] = mlt.util.mscohere(x, y, dt);\n\n    % Plot the results\n    figure;\n    plot(f, cxy, 'LineWidth', 1.5);\n    grid on;\n    title('Coherence between two noisy signals');\n    xlabel('Frequency (Hz)');\n    ylabel('Magnitude-Squared Coherence');\n    ylim([0 1.05]);\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingMarderDataWithNDI/","title":"Tutorial 1 Marder Lab data and NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingMarderDataWithNDI/#11-reading-marder-lab-data-with-ndi","title":"1.1 Reading Marder lab data with NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingMarderDataWithNDI/#about-ndi","title":"About NDI","text":"<p>The Neuroscience Data Interface is a data interface that sits between data and analysis code. NDI presents scientific data so it is in the form of a database that can be accessed through an Application Programming Interface (API) and database queries.</p> <p>See our documentation for:</p> <ol> <li>A short introduction to NDI</li> <li>Key concepts and vocabulary</li> </ol>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingMarderDataWithNDI/#sessions-and-datasets","title":"Sessions and datasets","text":"<p>In NDI, data is organized into sessions and datasets. A dataset is comprised of a set of sessions. </p> <p>To open an existing session, one simply uses:</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingMarderDataWithNDI/#code-block-11","title":"Code block 1.1:","text":"<p>```[matlab] S = ndi.session.dir(path/to/your/session);</p> <pre><code>### Listing subjects in a session\n\nWe have a handy helper function to list all of the subjects in a session in a table, along with some information about the global treatments of those subjects:\n\n#### Code block 1.2:\n```[matlab]\nsT = ndi.fun.docTable.subject(S)\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingMarderDataWithNDI/#seeing-probes-and-elements","title":"Seeing probes and elements","text":"<p>Text</p>"}]}