{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NDIcalc-marder-matlab","text":""},{"location":"#about","title":"About","text":"<p>This package contains a set of database document types and code for performing analysis of Marder lab data. It requires and depends on the Neuroscience Data Interface, NDI.</p>"},{"location":"#installation","title":"Installation","text":"<p>Check out the NDI Installation Guide.</p>"},{"location":"#help-and-support","title":"Help and Support","text":"<p>Use the issue tracker to submit questions, bugs, and issues.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Anyone with a GitHub account can contribute. Please see the guidelines below!</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>If you have code that you would like to write, do the following.</p> <ol> <li> <p>Press the Fork button in the upper-right corner of the NDIcalc-marder-matlab GitHub repository to make a copy of NDIcalc-marder-matlab in your own GitHub space.</p> </li> <li> <p>Make your changes to NDIcalc-marder-matlab.</p> </li> <li> <p>Commit your changes back to your fork.</p> </li> <li> <p>Finally, issue a Pull Request on GitHub from your fork. The request will be received by the NDI development team for integration.</p> </li> </ol>"},{"location":"installation/","title":"Installation:","text":"<ol> <li>Install NDI</li> </ol> <p>See the NDI Installation Guide and check out its requirements.</p> <ol> <li> <p>In a terminal or DOS shell, use the function <code>cd</code> to navigate to your user account Matlab documents directory. On a Mac, for example, it is <code>/Users/yourusername/Documents/MATLAB/</code>. Then, navigate to the <code>tools</code> directory within.</p> </li> <li> <p>Finally, clone this repository using <code>git clone https://github.com/VH-Lab/NDIcalc-matlab-matlab</code>.</p> </li> </ol>"},{"location":"documents/heart/ppg_beats/","title":"ppg_beats (ndi.document class)","text":""},{"location":"documents/heart/ppg_beats/#class-definition","title":"Class definition","text":"<p>Class name: ppg_beats Short name: ppg_beats Superclasses: base, epochid</p> <p>Definition: $NDICALCDOCUMENTPATH/heart/ppg_beats.json Schema for validation: $NDICALCSCHEMAPATH/heart/ppg_beats.json Property_list_name: <code>ppg_beats</code> Class_version: <code>1</code></p>"},{"location":"documents/heart/ppg_beats/#ppg_beats-fields","title":"ppg_beats fields","text":"<p>Accessed by <code>ppg_beats.field</code> where field is one of the field names below</p> field default_value data type description detection_parameters fields"},{"location":"documents/heart/ppg_beats/#base-fields","title":"base fields","text":"<p>Accessed by <code>base.field</code> where field is one of the field names below</p> field default_value data type description id session_id name datestamp"},{"location":"documents/heart/ppg_beats/#epochid-fields","title":"epochid fields","text":"<p>Accessed by <code>epochid.field</code> where field is one of the field names below</p> field default_value data type description epochid"},{"location":"documents/heart/spectrogram/","title":"spectrogram (ndi.document class)","text":""},{"location":"documents/heart/spectrogram/#class-definition","title":"Class definition","text":"<p>Class name: spectrogram Short name: spectrogram Superclasses: base, ngrid, epochid</p> <p>Definition: $NDICALCDOCUMENTPATH/heart/spectrogram.json Schema for validation: $NDICALCSCHEMAPATH/heart/spectrogram_schema.json Property_list_name: <code>spectrogram</code> Class_version: <code>1</code></p>"},{"location":"documents/heart/spectrogram/#spectrogram-fields","title":"spectrogram fields","text":"<p>Accessed by <code>spectrogram.field</code> where field is one of the field names below</p> field default_value data type description frequency_ngrid_dim timestamp_ngrid_dim decibels"},{"location":"documents/heart/spectrogram/#base-fields","title":"base fields","text":"<p>Accessed by <code>base.field</code> where field is one of the field names below</p> field default_value data type description id session_id name datestamp"},{"location":"documents/heart/spectrogram/#ngrid-fields","title":"ngrid fields","text":"<p>Accessed by <code>ngrid.field</code> where field is one of the field names below</p> field default_value data type description data_size data_type data_dim coordinates"},{"location":"documents/heart/spectrogram/#epochid-fields","title":"epochid fields","text":"<p>Accessed by <code>epochid.field</code> where field is one of the field names below</p> field default_value data type description epochid"},{"location":"reference/%2Bmlt/graceAnalysisAll.m/","title":"mlt.graceAnalysisAll","text":"<pre><code> GRACEANALYSISALL Runs the complete pre-processing and analysis pipeline for a session.\n\n    mlt.graceAnalysisAll(S)\n\n    This is the main, top-level wrapper function that executes the entire\n    pre-processing and analysis pipeline for all PPG (photoplethysmogram)\n    probes in a given NDI session.\n\n    It performs the following steps in order:\n    1.  Downsamples the raw PPG data to create the '_lp_whole' elements.\n    2.  Calculates spectrograms and saves them as .mat files.\n    3.  Calculates spectrograms and saves them as NDI documents.\n    4.  Detects heart beats and saves them as .mat files.\n    5.  Detects heart beats and saves them as NDI documents.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Run the entire analysis pipeline on a session\n        mlt.graceAnalysisAll(mySession);\n\n    See also mlt.ppg.downsampleAll, mlt.spectrogram.calculateForFiles,\n    mlt.spectrogram.calculateForDocs, mlt.beats.calculateForFiles,\n    mlt.beats.calculateForDocs\n</code></pre>"},{"location":"reference/%2Bmlt/gracedemo.m/","title":"mlt.gracedemo","text":"<pre><code>mlt.gracedemo is a script.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBinQuantize.m/","title":"mlt.beats.beatRateBinQuantize","text":"<pre><code> BEATRATEBINQUANTIZE Quantizes continuous rate data into discrete symbols.\n    [discrete_seq, edges] = mlt.beatRateBinQuantize(rates, NumSymbols)\n    converts a vector of continuous rate data into a sequence of integer\n    symbols from 1 to NumSymbols.\n\n    It uses the quantile function to define the bin edges, which helps\n    ensure that each symbol has a similar number of occurrences in the\n    output sequence, even if the input data is highly skewed.\n\n    INPUTS:\n    rates        - A vector of observed continuous rates.\n    NumSymbols   - The number of discrete symbols to quantize the data into.\n\n    OUTPUTS:\n    discrete_seq - A vector the same length as 'rates' containing the\n                   corresponding integer symbol for each rate.\n    edges        - The vector of bin edges used for quantization.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatRateBins.m/","title":"mlt.beats.beatRateBins","text":"<pre><code> BEATRATEBINS Estimates beat rate in regularly spaced time bins.\n    [rates, bin_centers] = mlt.beats.beatRateBins(beat_times) estimates the heart\n    rate from a vector of beat times (beat_times). The function uses a\n    sliding window approach to calculate the rate at regular intervals.\n\n    The input beat_times can be a numeric vector (assumed to be in seconds)\n    or a datetime vector. The output bin_centers will be of the same type.\n\n    This function is part of the mlt (Marder Lab Tools) namespace.\n\n    SYNTAX:\n    [rates, bin_centers] = mlt.beats.beatRateBins(beat_times)\n    [rates, bin_centers] = mlt.beats.beatRateBins(beat_times, 'deltaT', dt, 'W', w)\n\n    INPUTS:\n    beat_times          - A vector of beat times. Can be a numeric vector\n                          (e.g., seconds from the start of a recording) or a\n                          datetime vector. Must be sorted chronologically.\n\n    OPTIONAL NAME-VALUE PAIR ARGUMENTS:\n    'deltaT'            - The time step (in seconds) between the centers of\n                          consecutive bins.\n                          Default: 0.5 seconds.\n    'W'                 - The total width of the sliding window (in seconds)\n                          used to count beats for each bin.\n                          Default: 5 seconds.\n\n    OUTPUTS:\n    rates               - A vector of the calculated beat rates in beats\n                          per second (Hz) for each bin.\n    bin_centers         - A vector of the timestamps for the center of each\n                          bin. The data type will match the input\n                          'beat_times' (double or datetime).\n\n    EXAMPLE:\n        % Generate some noisy, simulated beat data where rate changes\n        true_rate = @(t) 2 + 0.5 * sin(2*pi*t/60); % Rate oscillates over time\n        t_sim = 0:0.01:120; % 120 seconds of simulation time\n        beats = [];\n        next_beat = 0;\n        while next_beat &lt; 120\n            current_rate = true_rate(next_beat);\n            ibi = 1/current_rate * (1 + 0.1*(rand-0.5)); % Add noise to inter-beat interval\n            next_beat = next_beat + ibi;\n            beats(end+1) = next_beat;\n        end\n\n        % 1. Calculate beat rate with default parameters\n        [rates, centers] = mlt.beats.beatRateBins(beats);\n\n        % 2. Calculate with custom window and step size\n        [rates_custom, centers_custom] = mlt.beats.beatRateBins(beats, 'deltaT', 1, 'W', 10);\n\n        % Plot results\n        figure;\n        plot(beats(2:end), 1./diff(beats), '.', 'Color', [0.7 0.7 0.7], 'DisplayName', 'Instantaneous Rate');\n        hold on;\n        plot(centers, rates, 'b-o', 'LineWidth', 1.5, 'DisplayName', 'Binned Rate (W=5, deltaT=0.5)');\n        plot(centers_custom, rates_custom, 'r-s', 'LineWidth', 1.5, 'DisplayName', 'Binned Rate (W=10, deltaT=1)');\n        plot(t_sim, true_rate(t_sim), 'k--', 'LineWidth', 2, 'DisplayName', 'True Rate');\n        hold off;\n        xlabel('Time (s)');\n        ylabel('Beat Rate (Hz)');\n        title('Heart Beat Rate Estimation');\n        legend;\n        grid on;\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatsdoc2struct.m/","title":"mlt.beats.beatsdoc2struct","text":"<pre><code> BEATSDOC2STRUCT Reads PPG beat data from an NDI document into a structure.\n\n    BEATS = BEATSDOC2STRUCT(S, DOC) reads photoplethysmogram (PPG) beat\n    information associated with a specific NDI document DOC within the\n    context of an NDI session or dataset S. It retrieves the beat data\n    from a binary file ('beats.vhsb'), formats it into a table based on\n    metadata in DOC, and returns the result as a structure array.\n\n    Inputs:\n        S       - An NDI session object (`ndi.session`) or NDI dataset\n                  object (`ndi.dataset`).\n        DOC     - An NDI document object (`ndi.document`) that references\n                  the PPG beat data. This document must contain the\n                  property `ppg_beats.fields` (a comma-separated string\n                  of field names).\n\n    Outputs:\n        BEATS   - A structure array where each element represents a single\n                  PPG beat. The fields of the structure include:\n                    - onset: Beat onset time.\n                    - offset: Beat offset time.\n                    - peak_time: Time of the beat's peak.\n                    - peak_val: Signal value at the beat's peak.\n                    - valley_time: Time of the beat's valley (trough).\n                    - valley_val: Signal value at the beat's valley.\n                    - up_time: Time of the upward slope.\n                    - down_time: Time of the downward slope.\n                    - duty_cycle: Ratio of beat duration to the period between beats.\n                    - period: Time between consecutive beats.\n                    - instant_freq: Instantaneous heart rate (beats per second).\n                    - amplitude: Peak-to-peak amplitude.\n                    - amplitude_high: Amplitude above a high threshold.\n                    - amplitude_low: Amplitude below a low threshold.\n                    - valid: Boolean indicating if the beat meets validity criteria.\n                    - up_duration: Duration of the upward slope of the beat.\n\n    See also: mlt.beats.detectHeartBeatsImproved, mlt.beats.beatsstruct2doc,\n        vlt.file.custom_file_formats.vhsb_read\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/beatsstruct2doc.m/","title":"mlt.beats.beatsstruct2doc","text":"<pre><code> MLT.BEATS.BEATSSTRUCT2DOC Adds PPG beat data from a structure to an NDI document.\n\n    DOC_OUT = BEATSSTRUCT2DOC(DOC_IN, BEATS) takes photoplethysmogram (PPG)\n    beat information stored in a structure array BEATS and writes it to a\n    binary file ('beats.vhsb'). It then associates this file with the\n    provided NDI document object DOC_IN.\n\n    Inputs:\n        DOC_IN  - An NDI document object (`ndi.document`) to which the beat\n                  data file will be added.\n        BEATS   - A structure array where each element represents a single\n                  PPG beat. The fields of the structure include:\n                    - onset: Beat onset time.\n                    - offset: Beat offset time.\n                    - peak_time: Time of the beat's peak.\n                    - peak_val: Signal value at the beat's peak.\n                    - valley_time: Time of the beat's valley (trough).\n                    - valley_val: Signal value at the beat's valley.\n                    - up_time: Time of the upward slope.\n                    - down_time: Time of the downward slope.\n                    - duty_cycle: Ratio of beat duration to the period between beats.\n                    - period: Time between consecutive beats.\n                    - instant_freq: Instantaneous heart rate (beats per second).\n                    - amplitude: Peak-to-peak amplitude.\n                    - amplitude_high: Amplitude above a high threshold.\n                    - amplitude_low: Amplitude below a low threshold.\n                    - valid: Boolean indicating if the beat meets validity criteria.\n                    - up_duration: Duration of the upward slope of the beat.\n\n    Outputs:\n        DOC_OUT - The updated NDI document object (`ndi.document`) that now\n                  includes a reference to the newly created 'beats.vhsb' file\n                  containing the beat data.\n\n    See also: mlt.beats.detectHeartBeatsImproved, mlt.beats.beatsdoc2struct,\n        vlt.file.custom_file_formats.vhsb_write\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForDocs.m/","title":"mlt.beats.calculateForDocs","text":"<pre><code> CALCULATEFORDOCS - Calculate and save heart beat data as NDI documents for a session.\n\n    mlt.beats.calculateForDocs(S)\n\n    This is a high-level wrapper function that automates the process of\n    heart beat detection for all PPG (photoplethysmogram) probes within a\n    given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls the core processing function, mlt.beats.wholeDayHeartBeatDoc,\n    to perform the beat detection and save the results as a 'ppg_beats'\n    NDI document.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.beats.calculateForDocs(mySession);\n\n    See also mlt.beats.wholeDayHeartBeatDoc, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/calculateForFiles.m/","title":"mlt.beats.calculateForFiles","text":"<pre><code> CALCULATEFORFILES - Calculate and save heart beat data as .mat files for a session.\n\n    mlt.beats.calculateForFiles(S)\n\n    This is a high-level wrapper function that automates the process of\n    heart beat detection for all PPG (photoplethysmogram) probes within a\n    given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls a core processing function to perform the beat detection\n    and save the results to a standalone .mat file in the session's path.\n\n    The output files are named according to the convention:\n    'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat'\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.beats.calculateForFiles(mySession);\n\n    See also mlt.beats.wholeDayHeartBeatFile, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeats.m/","title":"mlt.beats.detectHeartBeats","text":"<pre><code> DETECTHEARTBEATS Detect heartbeats in a pulsatile signal.\n\n    BEATS = DETECTHEARTBEATS(T, D, OPTIONS) detects heartbeats in a \n    pulsatile signal, such as a photoplethysmography (PPG) signal. \n    The function uses a threshold-based approach to identify \n    individual beats and their characteristics.\n\n    Inputs:\n        T: A vector of timestamps corresponding to the signal. Can be either:\n            - Numeric vector in seconds.\n            - Datetime vector.\n        D: A vector of signal values (e.g., PPG signal).\n        OPTIONS: (Optional) A structure specifying detection parameters:\n            THRESHOLD_HIGH: Upper threshold for beat detection (default: 0.75).\n            THRESHOLD_LOW: Lower threshold for beat detection (default: -0.75).\n            REFRACT: Minimum time between consecutive beats (refractory period, default: 0.2).\n            amplitude_high_min: Minimum amplitude above THRESHOLD_HIGH (default: 0).\n            amplitude_low_min: Minimum amplitude below THRESHOLD_LOW (default: 0).\n            amplitude_min: Minimum peak-to-peak amplitude (default: 0).\n            duration_min: Minimum beat duration (default: 0).\n\n    Outputs:\n        BEATS: A structure array where each element represents a detected beat.\n            Fields include:\n                onset: Beat onset time (datetime if T is datetime, double in seconds otherwise).\n                offset: Beat offset time (datetime if T is datetime, double in seconds otherwise).\n                duty_cycle: Ratio of beat duration to the period between beats (double).\n                period: Time between consecutive beats (double in seconds).\n                instant_freq: Instantaneous heart rate (double in beats per second).\n                amplitude: Peak-to-peak amplitude (double).\n                amplitude_high: Amplitude above THRESHOLD_HIGH (double).\n                amplitude_low: Amplitude below THRESHOLD_LOW (double).\n                valid: Boolean indicating if the beat meets validity criteria.\n                up_duration: Duration of the upward slope of the beat (double in seconds).\n\n    Notes:\n    - The input signal D is assumed to be preprocessed and normalized.\n    - The algorithm detects beats by identifying upward and downward \n      crossings of the specified thresholds.\n    - The validity of each beat is assessed based on amplitude and duration criteria.\n    - The function handles edge cases, such as incomplete beats at the end of the signal.\n    - If T is a datetime vector, the output onset and offset times will be datetime values,\n      while durations, period, and instant_freq will be double values in seconds.\n\n    Example:\n        % Load PPG data with time in seconds\n        %%%%[t_sec, d] = load_ppg_data_seconds somehow; \n        beats_sec = detectHeartBeats(t_sec, d);\n\n        % Load PPG data with datetime values\n        %%%%%[t_datetime, d] = load_ppg_data_datetime somehow\n        beats_datetime = detectHeartBeats(t_datetime, d);\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/detectHeartBeatsImproved.m/","title":"mlt.beats.detectHeartBeatsImproved","text":"<pre><code> DETECTHEARTBEATSIMPROVED Detect heartbeats in a pulsatile signal.\n\n    BEATS = DETECTHEARTBEATSIMPROVED(T, D, DRAW, OPTIONS) detects heartbeats in a\n    pulsatile signal, such as a photoplethysmography (PPG) signal. \n    The function uses a threshold-based approach to identify \n    individual beats and their characteristics.\n\n    Inputs:\n        T: A vector of timestamps corresponding to the signal. Can be either:\n            - Numeric vector in seconds.\n            - Datetime vector.\n        D: A vector of signal values (e.g., PPG signal).\n        DRAW: The raw data signal.\n        OPTIONS: (Optional) A structure specifying detection parameters:\n            threshold_high: Upper threshold for beat detection (default: 0.75).\n            threshold_low: Lower threshold for beat detection (default: -0.75).\n            refractory_period: Minimum time between consecutive beats (refractory period, default: 0.2).\n            amplitude_high_min: Minimum amplitude above THRESHOLD_HIGH (default: 0).\n            amplitude_low_min: Minimum amplitude below THRESHOLD_LOW (default: 0).\n            amplitude_min: Minimum peak-to-peak amplitude (default: 0).\n            duration_min: Minimum beat duration (default: 0).\n\n    Outputs:\n        BEATS: A structure array where each element represents a detected beat.\n            Fields include:\n                onset: Beat onset time (datetime if T is datetime, double in seconds otherwise).\n                offset: Beat offset time (datetime if T is datetime, double in seconds otherwise).\n                duty_cycle: Ratio of beat duration to the period between beats (double).\n                period: Time between consecutive beats (double in seconds).\n                instant_freq: Instantaneous heart rate (double in beats per second).\n                amplitude: Peak-to-peak amplitude (double).\n                amplitude_high: Amplitude above THRESHOLD_HIGH (double).\n                amplitude_low: Amplitude below THRESHOLD_LOW (double).\n                valid: Boolean indicating if the beat meets validity criteria.\n                up_duration: Duration of the upward slope of the beat (double in seconds).\n        OPTIONS: A structure specifying the detection parameters used.\n\n    Notes:\n    - The input signal D is assumed to be preprocessed and normalized.\n    - The algorithm detects beats by identifying upward and downward \n      crossings of the specified thresholds.\n    - The validity of each beat is assessed based on amplitude and duration criteria.\n    - The function handles edge cases, such as incomplete beats at the end of the signal.\n    - If T is a datetime vector, the output onset and offset times will be datetime values,\n      while durations, period, and instant_freq will be double values in seconds.\n\n    Example:\n        % Load PPG data with time in seconds\n        %%%%[t_sec, d] = load_ppg_data_seconds somehow; \n        beats_sec = detectHeartBeats(t_sec, d);\n\n        % Load PPG data with datetime values\n        %%%%%[t_datetime, d] = load_ppg_data_datetime somehow\n        beats_datetime = detectHeartBeats(t_datetime, d);\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValues.m/","title":"mlt.beats.getRawBeatValues","text":"<pre><code> GETRAWBEATVALUES Recalculates beat amplitudes using the raw signal.\n\n    beats_out = mlt.beats.getRawBeatValues(beats_in, t_raw, d_raw)\n\n    This function takes a 'beats' structure, whose timing was likely\n    determined from a normalized signal, and adds new amplitude fields\n    calculated from the original, un-normalized (raw) signal. This is useful\n    for recovering the true physiological amplitudes of detected beats.\n\n    Inputs:\n        beats   - A structure array of detected beats, with at least 'onset'\n                  and 'offset' time fields.\n        t_raw   - The time vector (numeric or datetime) of the raw signal.\n        d_raw   - The raw (un-normalized) signal vector.\n\n    Outputs:\n        beats   - The input 'beats' structure with the following new fields\n                  added to each element:\n                  .rawPeak: The maximum signal value during the beat.\n                  .rawTrough: The minimum signal value in the period\n                              preceding the beat onset.\n                  .rawAmplitude: The peak-to-trough amplitude (rawPeak - rawTrough).\n\n    See also mlt.beats.getRawBeatValuesFromDoc, mlt.beats.detectHeartBeatsImproved\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/getRawBeatValuesFromDoc.m/","title":"mlt.beats.getRawBeatValuesFromDoc","text":"<pre><code> GETRAWBEATVALUESFROMDOC Loads beat data and adds raw amplitude values.\n\n    beats_out = mlt.beats.getRawBeatValuesFromDoc(S, name, number)\n\n    This is a high-level function that loads a 'ppg_beats' NDI document\n    for a specified element, reads the corresponding raw (un-normalized)\n    time series data, and then calls mlt.beats.getRawBeatValues to add\n    raw amplitude information to the beats structure.\n\n    Inputs:\n        S       - An ndi.session object.\n        name    - The record name ('pylorus', 'heart', or 'gastric').\n        number  - The record number (a positive integer).\n\n    Outputs:\n        beats_with_raw - The 'beats' structure from the document, with the\n                         new raw amplitude fields (.rawPeak, .rawTrough,\n                         .rawAmplitude) added.\n\n    Example:\n        % Get beats with raw amplitudes for the 'pylorus' element, record 1\n        b_raw = mlt.beats.getRawBeatValuesFromDoc(mySession, 'pylorus', 1);\n\n    See also mlt.beats.getRawBeatValues, mlt.beats.beatsdoc2struct\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatDoc.m/","title":"mlt.beats.wholeDayHeartBeatDoc","text":"<pre><code> MLT.BEATS.WHOLEDAYHEARTBEATDOC Generate heartbeat record for a whole day's recording.\n\n    [BEATS, D, T] = mlt.beats.wholeDayHeartBeatDoc(S, OPTIONS) computes heart beat\n    analysis for an entire day's worth of data from an ndi.element, \n    typically 'ppg_heart_lp'. The function reads the data from the \n    specified element and performs heart beat detection.\n\n    Inputs:\n        S: An ndi.session or ndi.dataset object containing the data.\n        OPTIONS: A structure containing optional parameters.\n            e_name: The name of the ndi.element to analyze (default: 'ppg_heart_lp').\n            e_reference: The reference number of the ndi.element (default: 1).\n            zscoreWindowTime: The z-score time window in seconds (default: 3600).\n\n    Outputs:\n        DOC: A document containing the saved beats data\n        BEATS: A structure of heart beat data.\n        D: The data stream used for heart beat detection.\n        T: The timestamps corresponding to the data stream.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bbeats/wholeDayHeartBeatFile.m/","title":"mlt.beats.wholeDayHeartBeatFile","text":"<pre><code> MLT.BEATS.WHOLEDAYHEARTBEATFILE Generate heartbeat record for a whole day's recording.\n\n    [BEATS, D, T] = WHOLEDAYHEARTBEATFILE(S, OPTIONS) computes heart beat \n    analysis for an entire day's worth of data from an ndi.element, \n    typically 'ppg_heart_lp'. The function reads the data from the \n    specified element and performs heart beat detection.\n\n    Inputs:\n        S: An ndi.session or ndi.dataset object containing the data.\n        OPTIONS: A structure containing optional parameters.\n            e_name: The name of the ndi.element to analyze (default: 'ppg_heart_lp').\n            e_reference: The reference number of the ndi.element (default: 1).\n            zscoreWindowTime: The z-score time window in seconds (default: 3600).\n\n    Outputs:\n        BEATS: A vector of heart beat timestamps.\n        D: The data stream used for heart beat detection.\n        T: The timestamps corresponding to the data stream.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeatAndSpectrogram.m/","title":"mlt.doc.getHeartBeatAndSpectrogram","text":"<pre><code> MLT.DOC.GETHEARTBEATANDSPECTROGRAM Fetches heartbeats and spectrograms for a subject across multiple sessions.\n\n    DATA = mlt.doc.getHeartBeatAndSpectrogram(S_IN, SUBJECT_NAME, RECORD_TYPE)\n\n    This function retrieves both heart beat and spectrogram data for a single,\n    unique subject element identified by SUBJECT_NAME and RECORD_TYPE. It can\n    operate on one or more sessions.\n\n    It internally calls `mlt.doc.getHeartBeats` and `mlt.doc.getSpectrogramData`\n    to fetch the respective data and documents for each session.\n\n    The function returns a structure array with the following fields:\n    'session'                  - The ndi.session or ndi.dataset object for that entry.\n    'subject_local_identifier' - The name of the subject.\n    'recordType'               - The type of record ('heart', 'pylorus', 'gastric').\n    'HeartBeatDocs'            - Cell array of 'ppg_beats' ndi.document objects.\n    'HeartBeatData'            - Cell array of heart beat data structures.\n    'SpectrogramDocs'          - Cell array of 'spectrogram' ndi.document objects.\n    'SpectrogramData'          - Cell array of spectrogram data structures.\n\n    Inputs:\n        S_IN            - An ndi.session, ndi.dataset object, or a cell array of them.\n        SUBJECT_NAME    - The name of the subject (e.g., 'SubjectA').\n        RECORD_TYPE     - The record type (e.g., 'heart').\n\n    Outputs:\n        DATA            - A structure array containing the combined data, with one entry per session.\n\n    See also: mlt.doc.getHeartBeats, mlt.doc.getSpectrogramData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/getHeartBeats.m/","title":"mlt.doc.getHeartBeats","text":"<pre><code> MLT.DOC.GETHEARTBEATS Finds heart beat documents for a unique subject element.\n\n    [HEARTBEAT_DOCS, HEARTBEAT_DATA] = mlt.doc.getHeartBeats(S, SUBJECT_NAME, RECORD_TYPE)\n\n    Searches an NDI session for a UNIQUE element that corresponds to a specific\n    subject and recording location (e.g., 'heart') by calling `mlt.ndi.getElement`.\n    It then finds all associated 'ppg_beats' NDI documents for that single element.\n    If zero or more than one element matches the subject/type criteria, this function will error.\n\n    For each document found, it calls `mlt.doc.heartBeatData` to extract the\n    beat structure, performing time conversions to `datetime` objects if a\n    global clock is available for the epoch.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        SUBJECT_NAME    - The name of the subject (e.g., 'SubjectA') as a\n                          character vector or string.\n        RECORD_TYPE     - The type of record to search for. Must be one of\n                          'heart', 'pylorus', or 'gastric'.\n\n    Outputs:\n        HEARTBEAT_DOCS  - A cell array of all matching 'ppg_beats'\n                          `ndi.document` objects for the single found element.\n        HEARTBEAT_DATA  - A cell array of the same size as HEARTBEAT_DOCS,\n                          where each cell contains the corresponding beat data\n                          structure returned by `mlt.doc.heartBeatData`.\n\n    Example:\n        % Find the heart beat records for 'SubjectB', assuming they have only one 'heart' element.\n        [docs, data] = mlt.doc.getHeartBeats(mySession, 'SubjectB', 'heart');\n\n    See also: mlt.ndi.getElement, mlt.doc.heartBeatData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/getSpectrogramData.m/","title":"mlt.doc.getSpectrogramData","text":"<pre><code> MLT.DOC.GETSPECTROGRAMDATA Finds spectrogram documents for a unique subject element.\n\n    [SPECTROGRAM_DOCS, SPECTROGRAM_DATA] = mlt.doc.getSpectrogramData(S, SUBJECT_NAME, RECORD_TYPE)\n\n    Searches an NDI session for a UNIQUE element that corresponds to a specific\n    subject and recording location (e.g., 'heart') by calling `mlt.ndi.getElement`.\n    It then finds all associated 'spectrogram' NDI documents for that single element.\n    If zero or more than one element matches the subject/type criteria, this function will error.\n\n    For each document found, it calls `mlt.doc.spectrogramData` to extract the\n    spectrogram matrix, frequency vector, and time vector, performing time\n    conversions to `datetime` objects if a global clock is available.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        SUBJECT_NAME    - The name of the subject (e.g., 'SubjectA') as a\n                          character vector or string.\n        RECORD_TYPE     - The type of record to search for. Must be one of\n                          'heart', 'pylorus', or 'gastric'.\n\n    Outputs:\n        SPECTROGRAM_DOCS - A cell array of all matching 'spectrogram'\n                           `ndi.document` objects for the single found element.\n        SPECTROGRAM_DATA - A cell array of the same size as SPECTROGRAM_DOCS.\n                           Each cell contains a structure with the fields:\n                           .spec - The spectrogram data matrix\n                           .f    - The frequency vector\n                           .ts   - The time vector (`datetime` or numeric)\n\n    Example:\n        % Find the spectrogram records for 'SubjectB', assuming they have only one 'heart' element.\n        [docs, data] = mlt.doc.getSpectrogramData(mySession, 'SubjectB', 'heart');\n\n    See also: mlt.ndi.getElement, mlt.doc.spectrogramData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/heartBeatData.m/","title":"mlt.doc.heartBeatData","text":"<pre><code> MLT.DOC.HEARTBEATDATA Retrieves heart beat data from an NDI document with datetime conversion.\n\n    BEATS = mlt.doc.heartBeatData(S, PPG_BEATS_DOC)\n\n    This function accesses the beat information stored in a 'ppg_beats' NDI\n    document.\n\n    A key feature of this function is its handling of time. It inspects the\n    epoch's clock information from the element the document depends on. If a\n    global time clock (e.g., 'exp_global_time') is available for the epoch,\n    the time fields within the returned BEATS structure (e.g., '.onset', '.offset')\n    are converted to MATLAB `datetime` objects. If no global clock is found,\n    these timestamps remain as numeric values in seconds from the start of the epoch.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        PPG_BEATS_DOC   - An 'ppg_beats' ndi.document object.\n\n    Outputs:\n        BEATS           - A structure array where each element represents a\n                          detected beat. Time-related fields will be `datetime`\n                          objects if a global clock is present, otherwise they\n                          will be numeric (seconds).\n\n    Example:\n        % Assume 'mySession' is a valid NDI session object and we have found\n        % a 'ppg_beats' document.\n\n        e = mySession.getelements('element.name', 'ppg_heart_lp_whole', 'element.reference', 1);\n        et = e{1}.epochtable();\n        ppg_beats_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ...\n            e{1}.id(), et(1).epoch_id, 'ppg_beats');\n\n        if ~isempty(ppg_beats_doc)\n            beats_with_datetime = mlt.doc.heartBeatData(mySession, ppg_beats_doc{1});\n\n            % Check the class of the onset time for the first beat\n            disp(['Class of beat onset time: ' class(beats_with_datetime(1).onset)]);\n        end\n\n    See also: mlt.beats.beatsdoc2struct, ndi.time.syncgraph.time_convert\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bdoc/spectrogramData.m/","title":"mlt.doc.spectrogramData","text":"<pre><code> MLT.DOC.SPECTROGRAMDATA Retrieves spectrogram data from an NDI document.\n\n    [SPEC, F, TS] = mlt.doc.spectrogramData(S, SPECTROGRAM_DOC)\n\n    This function extracts the full spectrogram data matrix, frequency vector, and\n    time vector from a 'spectrogram' NDI document.\n\n    A key feature of this function is its handling of time. It inspects the\n    epoch's clock information from the element the document depends on. If a\n    global time clock (e.g., 'exp_global_time') is available for the epoch, the\n    output time vector 'TS' is converted to a MATLAB `datetime` object. If no\n    global clock is found, the time vector is returned as numeric values in\n    seconds from the start of the epoch.\n\n    Inputs:\n        S               - An ndi.session or ndi.dataset object.\n        SPECTROGRAM_DOC - A 'spectrogram' ndi.document object.\n\n    Outputs:\n        SPEC            - The spectrogram data matrix, with dimensions\n                          [frequency x time].\n        F               - A column vector of frequencies (Hz) corresponding to\n                          the rows of SPEC.\n        TS              - A column vector of timestamps for the spectrogram.\n                          Will be a `datetime` vector if a global clock is\n                          present, otherwise numeric (seconds).\n\n    Example:\n        % Assume 'mySession' is a valid NDI session object and we have found\n        % a 'spectrogram' document for a pylorus element.\n\n        e_pylorus = mySession.getelements('element.name', 'ppg_pylorus_lp_whole', 'element.reference', 1);\n        et = e_pylorus{1}.epochtable();\n        spectrogram_doc = ndi.database.fun.finddocs_elementEpochType(mySession, ...\n            e_pylorus{1}.id(), et(1).epoch_id, 'spectrogram');\n\n        if ~isempty(spectrogram_doc)\n            [spec_data, freqs, times] = mlt.doc.spectrogramData(mySession, spectrogram_doc{1});\n\n            % Check the class of the time vector\n            disp(['Class of time vector TS: ' class(times)]);\n\n            % Plot the spectrogram\n            figure;\n            imagesc(times, freqs, spec_data);\n            set(gca, 'YDir', 'normal');\n            ylabel('Frequency (Hz)');\n            % datetick('x'); % Use if times are datetime\n        end\n\n    See also: ndi.fun.data.readngrid, ndi.time.syncgraph.time_convert\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/Analysis.m/","title":"mlt.hmm.Analysis","text":"<pre><code> ANALYSIS Performs a full HMM analysis pipeline on beat time data.\n\n    [states, timestamps, rates, state_stats] = mlt.hmm.Analysis(beat_times)\n\n    This high-level function runs a complete Hidden Markov Model (HMM)\n    pipeline. It takes a vector of beat times, calculates a continuous\n    beat rate signal, fits an HMM to this signal, and decodes the most\n    likely sequence of hidden states.\n\n    Inputs:\n        beat_times      - A vector of beat times (numeric seconds or datetime).\n\n    Optional Name-Value Pair Arguments:\n        N (1,1) double = 2\n            Number of hidden states.\n        ModelType (1,1) string = \"gaussian\"\n            Model to use: \"discrete\" or \"gaussian\". The \"gaussian\" model\n            requires Kevin Murphy's Bayes Net Toolbox (BNT).\n        InitialModel (1,1) struct = struct()\n            A pre-trained model struct (from mlt.hmm.fit or mlt.hmm.fitGauss).\n            If provided, the fitting step is skipped and this model is used\n            directly for decoding.\n        deltaT (1,1) double = 0.5\n            Time step for rate binning (seconds).\n        W (1,1) double = 5\n            Window size for rate binning (seconds).\n        (And other model-specific options for fitting...)\n\n    Outputs:\n        states          - Vector of the most likely (sorted) state for each bin.\n        timestamps      - Timestamps for the center of each bin.\n        rates           - The calculated beat rate (Hz) for each bin.\n        state_stats     - N-by-2 matrix of [mean_rate, std_dev_rate] for each state.\n\n    Example 1: Standard Fitting and Visualization\n        % First, load the beat times from a pre-processed _beats.mat file\n        L = load('ppg_ppg_heart_lp_whole_1_beats.mat');\n        beat_times = [L.beats.onset];\n\n        % Perform a 2-state Gaussian HMM analysis using default settings\n        [states, ts, rates, stats] = mlt.hmm.Analysis(beat_times);\n\n        % Visualize the state sequence overlaid on the beat rate\n        mlt.plot.HMMStates(states, ts, rates);\n\n        % Optionally, calculate and plot dwell time distributions\n        DwellStats = mlt.hmm.StateDwellTimes(states, ts);\n        mlt.plot.HMMStateDwellTimes(DwellStats);\n\n    Example 2: Using a Pre-Defined 'InitialModel' to Decode\n        % Define a fixed 2-state Gaussian model struct\n        myFixedModel.prior = [0.2; 0.8];\n        myFixedModel.transmat = [0.9 0.1; 0.1 0.9];\n        % BNT requires specific dimensions: [ObsDim x NumStates x NumMixes]\n        myFixedModel.mu = reshape([0 1], [1 2 1]);\n        % BNT requires specific dimensions: [ObsDim x ObsDim x NumStates x NumMixes]\n        myFixedModel.Sigma = reshape([0.05, 1], [1 1 2 1]);\n        myFixedModel.mixmat = ones(2, 1); % For a single Gaussian per state\n        myFixedModel.StateRemap = [1 2];\n\n        % Run analysis, which will now skip the fitting step\n        [states, ts, rates, stats] = mlt.hmm.Analysis(beat_times, ...\n            'ModelType', 'gaussian', ...\n            'InitialModel', myFixedModel);\n\n    See also mlt.hmm.fit, mlt.hmm.decode, mlt.hmm.fitGauss, mlt.hmm.decodeGauss, mlt.plot.HMMStates\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/StateDwellTimes.m/","title":"mlt.hmm.StateDwellTimes","text":"<pre><code> STATEDWELLTIMES Calculates and histograms the dwell time for each HMM state.\n\n    DwellStats = mlt.hmm.StateDwellTimes(states, timestamps)\n\n    Takes the state sequence output from mlt.hmm.Analysis and calculates the\n    duration of each consecutive period spent in a given state. It then\n    computes a histogram of these durations for each state.\n\n    Inputs:\n        states          - A vector of integer state assignments, e.g., from\n                          mlt.hmm.Analysis.\n        timestamps      - A vector of timestamps corresponding to each state\n                          assignment. Can be numeric (seconds) or datetime.\n                          Must be evenly spaced.\n\n    Optional Name-Value Pair Arguments:\n        timeBins        - A vector of bin edges for the histogram.\n                          Default: 100 log-spaced bins from 0.1s to 3600s.\n\n    Outputs:\n        DwellStats      - A structure array with one entry for each state.\n                          Each element has the fields:\n                          - .state: The state number.\n                          - .histBinTimes: The center time of each histogram bin (s).\n                          - .histBinCount: The number of dwells in each bin.\n\n    Example &amp; Plotting:\n        % First, run the main analysis pipeline\n        [states, timestamps] = mlt.hmm.Analysis(beat_times);\n\n        % Now, calculate the dwell time statistics\n        DwellStats = mlt.hmm.StateDwellTimes(states, timestamps);\n\n        % Finally, generate the plot with the dedicated plotting function\n        mlt.plot.HMMStateDwellTimes(DwellStats);\n\n    See also mlt.hmm.Analysis, mlt.plot.HMMStateDwellTimes, histcounts\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/decode.m/","title":"mlt.hmm.decode","text":"<pre><code> DECODE Finds the most likely state sequence using the Viterbi algorithm.\n\n    STATES = mlt.hmm.decode(rates, TRANS, EMIS, fit_info)\n\n    Calculates the most likely sequence of hidden states for a discrete HMM\n    given a sequence of continuous observations ('rates').\n\n    It uses the 'fit_info' struct from mlt.hmm.fit to discretize the rate\n    data and then remaps the output states to match the sorted order\n    from the fitting step.\n\n    Inputs:\n        rates       - A vector of observed continuous rates.\n        TRANS       - An N-by-N state transition matrix from mlt.hmm.fit.\n        EMIS        - The emission probability matrix from mlt.hmm.fit.\n        fit_info    - The fit_info struct output by mlt.hmm.fit.\n\n    Outputs:\n        states      - A vector the same length as 'rates' containing the\n                      most likely sequence of hidden states (sorted 1 to N).\n\n    Example:\n        % Assume 'training_rates' and 'new_rates' are vectors of data\n\n        % 1. Fit an HMM to a training dataset\n        num_states = 4;\n        [TRANS_est, EMIS_est, fit_info] = mlt.hmm.fit(training_rates, num_states);\n\n        % 2. Decode a new sequence of rates using the fitted model\n        most_likely_states = mlt.hmm.decode(new_rates, TRANS_est, EMIS_est, fit_info);\n\n    See also mlt.hmm.fit, hmmviterbi\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/decodeGauss.m/","title":"mlt.hmm.decodeGauss","text":"<pre><code> DECODEGAUSS Finds the most likely state sequence for a Gaussian HMM.\n\n    STATES = mlt.hmm.decodeGauss(rates, model)\n\n    Calculates the most likely sequence of hidden states for an HMM with\n    Gaussian emissions using the Viterbi algorithm.\n\n    *** REQUIRES KEVIN MURPHY'S BAYES NET TOOLBOX (BNT) ***\n\n    Inputs:\n        rates   - A vector of observed continuous rates.\n        model   - The trained Gaussian HMM model struct from mlt.hmm.fitGauss.\n\n    Outputs:\n        states  - A vector of the most likely (sorted) state for each time point.\n\n    Example:\n        % Assume 'training_rates' and 'new_rates' are vectors of data\n\n        % 1. Fit a Gaussian HMM to a training dataset\n        num_states = 4;\n        model = mlt.hmm.fitGauss(training_rates, num_states);\n\n        % 2. Decode a new sequence of rates using the fitted model\n        most_likely_states = mlt.hmm.decodeGauss(new_rates, model);\n\n    See also mlt.hmm.fitGauss, viterbi_path\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/fit.m/","title":"mlt.hmm.fit","text":"<pre><code> FIT Fits a discrete HMM and characterizes states by rate statistics.\n\n    [TRANS, EMIS, state_stats, fit_info] = mlt.hmm.fit(rates, N)\n\n    Fits an N-state Hidden Markov Model (HMM) to the provided rate data. It\n    uses a discrete emission model, which is required by MATLAB's hmmtrain\n    function. To do this, it first quantizes the continuous rate data into a\n    finite number of symbols.\n\n    After fitting, it characterizes each state by the mean and standard\n    deviation of the continuous rates that were assigned to it. The states\n    are then sorted and re-ordered based on this mean rate (lowest to highest).\n\n    Inputs:\n        rates       - A vector of observed rates, e.g., from mlt.beats.beatRateBins.\n        N           - The number of hidden states for the model.\n\n    Optional Name-Value Pair Arguments:\n        NumSymbols (1,1) double = 10\n            The number of discrete symbols to quantize the 'rates' data into.\n        MaxIterations (1,1) double = 100\n            Maximum number of iterations for the Baum-Welch algorithm.\n        Tolerance (1,1) double = 1e-4\n            Convergence tolerance for the Baum-Welch algorithm.\n\n    Outputs:\n        TRANS       - An N-by-N matrix of sorted state transition probabilities.\n        EMIS        - An N-by-NumSymbols sorted emission probability matrix.\n        state_stats - An N-by-2 matrix where column 1 is the mean rate\n                      and column 2 is the std. dev. of the rate for each\n                      sorted state.\n        fit_info    - A struct containing information (quantization edges and\n                      state remapping) needed for decoding new data with\n                      mlt.hmm.decode.\n\n    Example:\n        % Assume 'training_rates' is a vector of beat-to-beat rates\n        num_states = 4;\n        [TRANS, EMIS, stats, info] = mlt.hmm.fit(training_rates, num_states);\n\n        % Now you can use these outputs to decode a new rate sequence:\n        % decoded_states = mlt.hmm.decode(new_rates, TRANS, EMIS, info);\n\n    See also mlt.hmm.decode, hmmtrain, hmmviterbi\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bhmm/fitGauss.m/","title":"mlt.hmm.fitGauss","text":"<pre><code> FITGAUSS Fits a Hidden Markov Model with Gaussian emissions using BNT.\n    MODEL = mlt.hmm.fitGauss(rates, N) fits an N-state HMM to the\n    continuous rate data using Gaussian distributions for the emissions. The\n    states are sorted by their mean emission rate (lowest to highest).\n\n    *** REQUIRES KEVIN MURPHY'S BAYES NET TOOLBOX (BNT) ***\n    Download from: https://github.com/bayesnet/bnt\n    And add to your MATLAB path using: addpath(genpath('path/to/bnt'))\n\n    Inputs:\n        rates           - A vector of observed continuous rates.\n        N               - The number of hidden states for the model.\n\n    Optional Name-Value Pair Arguments:\n        MaxIterations   - Maximum number of iterations for the EM algorithm.\n                          Default: 100.\n\n    Outputs:\n        model           - A struct containing the trained and sorted HMM\n                          parameters, ready for use with mlt.hmm.decodeGauss.\n\n    Example:\n        % Assume 'training_rates' is a vector of your data\n        num_states = 4;\n        model = mlt.hmm.fitGauss(training_rates, num_states);\n\n        % The 'model' struct can now be used to decode new sequences:\n        % decoded_states = mlt.hmm.decodeGauss(new_rates, model);\n\n    See also mlt.hmm.decodeGauss, mhmm_em, kmeans\n</code></pre>"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/findInhibitoryBouts.m/","title":"mlt.inhibitoryBouts.findInhibitoryBouts","text":"<pre><code> MLT.FINDINHIBITORYBOUTS Identifies inhibitory bouts from beat time data.\n    bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times) analyzes a vector of beat\n    times to identify periods of significant heart rate slowdown (inhibition)\n    and the subsequent recovery.\n\n    The function first calculates the beat rate in sliding time windows. It\n    then iterates through the rate data to find onsets and offsets.\n\n    SYNTAX:\n    bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times)\n    bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times, Name, Value, ...)\n\n    INPUTS:\n    beat_times          - A vector of beat times (numeric seconds or datetime).\n\n    OPTIONAL NAME-VALUE PAIR ARGUMENTS:\n    'deltaT'            - The time step (in seconds) for rate binning.\n                          Default: 0.5 seconds.\n    'W'                 - The total width of the sliding window (in seconds)\n                          for rate binning.\n                          Default: 5 seconds.\n    'InhibitoryBoutSlowDownOnsetThreshold' - The fractional threshold for\n                          detecting an inhibitory bout onset.\n                          Default: 0.5 (i.e., a 50% slowdown).\n    'InhibitoryBoutEndOnsetThreshold' - The fractional threshold for\n                          detecting the end of a bout.\n                          Default: 1.5 (i.e., a 150% speedup).\n    'InhibitoryBoutOnsetOffsetTimeWindow' - The duration (in seconds) over\n                          which the rate change is evaluated.\n                          Default: 1 second.\n\n    OUTPUTS:\n    bouts               - A structure with four fields:\n                          .inhibitoryBoutOnset: A vector of timestamps for\n                            the start of each detected inhibitory bout.\n                          .inhibitoryBoutOffset: A vector of timestamps for\n                            the end of each detected inhibitory bout.\n                          .beatRate: The vector of binned beat rates (Hz).\n                          .beatRateTimes: The timestamps for each binned rate.\n\n    EXAMPLE:\n        beat_times = [ (0:0.4:10), (10.5:1:20), (20.4:0.4:30) ]';\n        bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times);\n        % The 'bouts' struct now contains onsets, offsets, and the rate data.\n</code></pre>"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibBoutAnalysis.m/","title":"mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis","text":"<pre><code> MLT.inhibitoryBouts.SPECTROGRAMINHIBBOUTANALYSIS Analyze spectrogram FWHM around inhibition bout times.\n\n    [SPECDATA_MATRIX, F, FWHM_VECTOR, LOW_CUTOFF_VECTOR, HIGH_CUTOFF_VECTOR] = ...\n        mlt.inhibitoryBouts.spectrogramInhibBoutAnalysis(E, INHIBBOUTTIMES, SKIP, TIMEWINDOW)\n\n    Analyzes the spectrogram associated with an ndi.element E around specified\n    inhibition bout times. For each time provided in INHIBBOUTTIMES, it defines\n    a time window starting at INHIBBOUTTIMES(i) + SKIP and lasting for\n    TIMEWINDOW seconds. It calculates the time-averaged spectrogram within that\n    window and computes its Full Width at Half Maximum (FWHM).\n\n    Inputs:\n        E              - An ndi.element object. The session is retrieved from e.session.\n                         The element should have associated 'spectrogram' documents.\n        INHIBBOUTTIMES - A vector of Matlab datetime objects indicating the\n                         start times of inhibition bouts.\n        SKIP           - A double scalar indicating the time offset in seconds\n                         relative to each inhibBoutTime to start the analysis window.\n                         Can be positive or negative.\n        TIMEWINDOW     - A double scalar indicating the duration in seconds of the\n                         analysis window. Can be positive (window goes forward\n                         from start) or negative (window goes backward from start).\n\n    Outputs:\n        SPECDATA_MATRIX   - A matrix where each column is the time-averaged\n                            power spectrum (column vector) calculated for the\n                            window corresponding to each entry in INHIBBOUTTIMES.\n                            If analysis fails for a specific bout time, the\n                            corresponding column might be omitted or filled\n                            with NaNs depending on downstream processing needs\n                            (currently, only successful results are concatenated).\n                            Returns [] if no successful analyses are performed.\n        F                 - The frequency vector (numeric column vector)\n                            corresponding to the rows of SPECDATA_MATRIX. Assumes\n                            the frequency vector is consistent across all analyses.\n                            Returns [] if no successful analyses are performed.\n        FWHM_VECTOR       - A row vector containing the FWHM value for each\n                            successfully analyzed time window. Contains NaN for\n                            windows where calculation failed or was not possible.\n        LOW_CUTOFF_VECTOR - A row vector containing the lower frequency cutoff\n                            at half maximum for each successfully analyzed window.\n                            Contains NaN for windows where calculation failed.\n        HIGH_CUTOFF_VECTOR- A row vector containing the upper frequency cutoff\n                            at half maximum for each successfully analyzed window.\n                            Contains NaN for windows where calculation failed.\n\n    Requires:\n        - NDI toolbox (+ndi)\n        - vhlab-toolbox-matlab (+vlt), specifically vlt.signal.fwhm\n        - NDIcalc-marder-matlab (+mlt), specifically mlt.spectrograph.readSpectrogramTimeWindow\n          and this function (mlt.inhibitoryBouts..spectrogramInhibBoutAnalysis).\n        - Associated helper functions like `ndi.fun.data.readngrid` (if not standard)\n</code></pre>"},{"location":"reference/%2Bmlt/%2BinhibitoryBouts/spectrogramInhibitoryBoutOnsetOffsetAnalysis.m/","title":"mlt.inhibitoryBouts.spectrogramInhibitoryBoutOnsetOffsetAnalysis","text":"<pre><code> MLT.SPECTROGRAMINHIBITORYBOUTONSETOFFSETANALYSIS Analyze spectrogram FWHM around inhibition bout onset/offset times.\n\n    [ONSETDATA, OFFSETDATA] = mlt.spectrogramInhibitoryBoutOnsetOffsetAnalysis(S, RECORD_NAME, ...\n        REFERENCE, INHIBBOUTONSETS, INHIBBOUTOFFSETS, SKIP, TIMEWINDOW)\n\n    Analyzes the spectrogram associated with a specified PPG element ('ppg_heart_lp_whole'\n    or 'ppg_pylorus_lp_whole') within session S. It focuses on time windows\n    relative to inhibition bout onset and offset times.\n\n    This function calls `mlt.spectrogramInhibBoutAnalysis` twice:\n    1. For Onsets: It analyzes windows calculated relative to INHIBBOUTONSETS.\n       The window for onset(i) starts at onset(i) - SKIP - TIMEWINDOW and ends\n       at onset(i) - SKIP.\n    2. For Offsets: It analyzes windows calculated relative to INHIBBOUTOFFSETS.\n       The window for offset(i) starts at offset(i) + SKIP and ends at\n       offset(i) + SKIP + TIMEWINDOW.\n\n    It returns the aggregated results for the onset and offset analyses in\n    separate structures.\n\n    Inputs:\n        S                 - An ndi.session or ndi.dataset object.\n        RECORD_NAME       - Character vector or string: 'heart' or 'pylorus'.\n        REFERENCE         - Positive integer scalar: The reference number of the element.\n        INHIBBOUTONSETS   - Column vector of Matlab datetime objects indicating inhibition bout onset times.\n        INHIBBOUTOFFSETS  - Column vector of Matlab datetime objects indicating inhibition bout offset times.\n                            Must be the same size as INHIBBOUTONSETS.\n        SKIP              - Non-negative double scalar: Time offset in seconds used to define\n                            the near edge of the analysis window relative to onset/offset. Allows 0.\n        TIMEWINDOW        - Positive double scalar: Duration in seconds of the analysis window.\n\n    Outputs:\n        ONSETDATA         - Structure containing results from analyzing windows before onsets:\n            .specData_matrix   - Matrix of time-averaged spectra (freq x bouts).\n            .f                 - Frequency vector (column).\n            .fwhm_vector       - Row vector of FWHM values (NaN if failed).\n            .low_cutoff_vector - Row vector of low cutoffs (NaN if failed).\n            .high_cutoff_vector- Row vector of high cutoffs (NaN if failed).\n        OFFSETDATA        - Structure containing results from analyzing windows after offsets:\n            .specData_matrix   - Matrix of time-averaged spectra (freq x bouts).\n            .f                 - Frequency vector (column).\n            .fwhm_vector       - Row vector of FWHM values (NaN if failed).\n            .low_cutoff_vector - Row vector of low cutoffs (NaN if failed).\n            .high_cutoff_vector- Row vector of high cutoffs (NaN if failed).\n                            Returns empty structures with NaN vectors if the\n                            specified element is not found or analysis fails.\n\n    Requires:\n        - NDI toolbox (+ndi)\n        - vhlab-toolbox-matlab (+vlt), specifically vlt.signal.fwhm (used by mlt.spectrogramFWHM)\n        - NDIcalc-marder-matlab (+mlt), specifically mlt.spectrogramFWHM,\n          mlt.readSpectrogramTimeWindow, and this function\n          (mlt.spectrogramInhibitoryBoutOnsetOffsetAnalysis).\n        - Associated helper functions like `ndi.fun.data.readngrid` (if not standard)\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bjacquerie/kathleenTime1.m/","title":"mlt.jacquerie.kathleenTime1","text":"<pre><code>  kathleenTime1 defines datetime intervals and returns them in a structure.\n  The structure array contains the interval and a temperature field.\n\n  Syntax:\n    timeData = kathleenTime1()\n    timeData = kathleenTime1(intervalWidthSeconds)\n\n  Description:\n    timeData = kathleenTime1() returns datetime intervals with a default\n    width of 180 seconds (3 minutes).\n\n    timeData = kathleenTime1(intervalWidthSeconds) returns datetime intervals\n    with a specified width in seconds.\n\n  Example:\n    % Get time intervals for a 5-minute (300 second) window\n    myData = kathleenTime1(300);\n\n  See also: kathleenTime2\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bjacquerie/kathleenTime2.m/","title":"mlt.jacquerie.kathleenTime2","text":"<pre><code>  kathleenTime2 defines datetime intervals and returns them in a structure.\n  The structure array contains the interval and a temperature field.\n\n  Syntax:\n    timeData = kathleenTime2()\n    timeData = kathleenTime2(intervalWidthSeconds)\n\n  Description:\n    timeData = kathleenTime2() returns datetime intervals with a default\n    width of 180 seconds (3 minutes).\n\n    timeData = kathleenTime2(intervalWidthSeconds) returns datetime intervals\n    with a specified width in seconds.\n\n  Example:\n    % Get time intervals for a 1-minute (60 second) window\n    myData = kathleenTime2(60);\n\n  See also: kathleenTime1\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure1.m/","title":"mlt.jacquerie.makeFigure1","text":"<pre><code>  makeFigure1 Generates a figure from session data.\n    makeFigure1(dataPrefix) takes the directory path 'dataPrefix' \n    where session data is stored and creates a figure.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bjacquerie/makeFigure2.m/","title":"mlt.jacquerie.makeFigure2","text":"<pre><code>  makeFigure1 Generates a figure from session data.\n    makeFigure1(dataPrefix) takes the directory path 'dataPrefix' \n    where session data is stored and creates a figure.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bndi/getElement.m/","title":"mlt.ndi.getElement","text":"<pre><code> GETELEMENT Finds a unique NDI element based on subject and record type.\n\n    ELEM = mlt.ndi.getElement(S, subject_name, record_type, [element_label])\n\n    Searches the NDI session S to find a single, unique ndi.element object\n    that corresponds to the given subject and record type. It performs a\n    database query to find element documents that match all criteria.\n\n    This function will raise an error if zero or more than one element matches\n    the search criteria.\n\n    Inputs:\n        S             - An ndi.session or ndi.dataset object.\n        subject_name  - The name of the subject (e.g., 'SubjectA').\n        record_type   - The type of record ('heart', 'gastric', or 'pylorus').\n        element_label - (Optional) A further label to identify the element.\n                        Defaults to 'lp_whole'.\n\n    Outputs:\n        elem          - The single matching ndi.element object.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HMMStateDwellTimes.m/","title":"mlt.plot.HMMStateDwellTimes","text":"<pre><code> HMMSTATEDWELLTIMES Plots dwell time histograms for Hidden Markov Model (HMM) states.\n\n    FIG_HANDLE = mlt.plot.HMMStateDwellTimes(DwellStats)\n\n    Creates a figure with up to a 2x2 subplot layout, showing the dwell\n    time distribution for each HMM state on a logarithmic time axis. This\n    function is designed to work directly with the output structure from\n    the mlt.hmm.StateDwellTimes function.\n\n    Inputs:\n        DwellStats - A structure array output from mlt.hmm.StateDwellTimes.\n                     It must contain the fields \"state\", \"histBinTimes\",\n                     and \"histBinCount\".\n\n    Outputs:\n        fig_handle - A handle to the created figure.\n\n    Example:\n        % First, run the HMM analysis pipeline and calculate dwell times\n        [states, timestamps] = mlt.hmm.Analysis(beat_times);\n        DwellStats = mlt.hmm.StateDwellTimes(states, timestamps);\n\n        % Now, generate the plot with a single command\n        fig_handle = mlt.plot.HMMStateDwellTimes(DwellStats);\n\n    See also mlt.hmm.Analysis, mlt.hmm.StateDwellTimes\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HMMStates.m/","title":"mlt.plot.HMMStates","text":"<pre><code> HMMSTATES Plots HMM states and beat rates on a dual-y-axis plot.\n\n    AX = mlt.plot.HMMStates(states, timestamps, rates)\n\n    Creates a plot that visualizes the output of an HMM analysis. It plots\n    the continuous beat rate signal on the left y-axis and the corresponding\n    discrete HMM state sequence on the right y-axis.\n\n    The y-axes are scaled relative to each other for intuitive comparison:\n    - The value '1' on the right (State) axis aligns with '0' on the left\n      (Rate) axis.\n    - The highest state number on the right axis aligns with the maximum\n      value of the plotted rate data on the left axis.\n\n    Inputs:\n        states          - A vector of integer HMM state assignments.\n        timestamps      - A vector of time values (numeric or datetime)\n                          corresponding to the states and rates.\n        rates           - A vector of beat rates (Hz) corresponding to the\n                          timestamps.\n\n    Optional Name-Value Pair Arguments:\n        Linewidth (1,1) double = 1.5\n            Line width for both the rate and state plots.\n        RateColor (1,3) double = [0 0.4470 0.7410] (MATLAB blue)\n            Color for the beat rate plot.\n        StateColor (1,3) double = [0.8500 0.3250 0.0980] (MATLAB orange)\n            Color for the HMM state plot.\n\n    Outputs:\n        ax              - A struct containing the handles to the two axes\n                          (ax.RateAxis and ax.StateAxis).\n\n    Example:\n        % First, run the main analysis pipeline to get the required inputs\n        L = load('ppg_ppg_heart_lp_whole_1_beats.mat');\n        beat_times = [L.beats.onset];\n        [states, timestamps, rates, ~] = mlt.hmm.Analysis(beat_times);\n\n        % Now, generate the specialized plot\n        ax = mlt.plot.HMMStates(states, timestamps, rates);\n\n    See also mlt.hmm.Analysis, yyaxis\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeat.m/","title":"mlt.plot.HeartBeat","text":"<pre><code> HEARTBEAT - Plot PPG signal and derived heart beat data in a new figure.\n\n    AX = mlt.plot.HeartBeat(BEATS, D, T)\n\n    Plots heart beat statistics derived from a photoplethysmogram (PPG).\n    It generates a new figure with three stacked and linked subplots:\n    1) The PPG signal with beat onsets/offsets marked.\n    2) The instantaneous beat frequency over time.\n    3) The duty cycle of each beat over time.\n\n    Inputs:\n        beats - A structure array containing heartbeat information. Each\n                element must have the following fields:\n                .onset      (double | datetime) Time of the heartbeat onset.\n                .offset     (double | datetime) Time of the heartbeat offset.\n                .valid      (logical) True if the beat is valid.\n                .instant_freq (double) Instantaneous frequency (Hz).\n                .duty_cycle (double) Duty cycle of the heartbeat.\n        d     - A column vector of the PPG signal data.\n        t     - A column vector of time values for the PPG data. This can\n                be numeric (in seconds) or a datetime vector. Note: If\n                numeric, the x-axis of the plot will be converted to hours.\n\n    Optional Name-Value Pairs:\n        Linewidth (1,1) double = 1\n            Specifies the line width for the frequency and duty cycle plots.\n\n    Outputs:\n        ax    - A 3x1 vector of axes handles for the three subplots\n                (PPG, beat frequency, duty cycle).\n\n    Example 1: Basic usage with numeric time vector\n        % Assuming 'beats', 'd', and 't' (in seconds) are defined:\n        ax = mlt.plot.HeartBeat(beats, d, t);\n\n    Example 2: Specifying a custom linewidth\n        ax = mlt.plot.HeartBeat(beats, d, t, 'Linewidth', 2);\n\n    See also PLOT, SUBPLOT, LINKAXES.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromDocs.m/","title":"mlt.plot.HeartBeatsFromDocs","text":"<pre><code> MLT.PLOT.HEARTBEATSFROMDOCS - Plots beat statistics overlaid on the raw PPG signal.\n\n    AX = mlt.plot.HeartBeatsFromDocs(S)\n\n    This function visualizes pre-calculated heart beat statistics for each\n    subject and record type in an NDI session. It overlays the statistics on\n    top of the **raw, unnormalized** PPG signal.\n\n    It uses helper functions to find the relevant 'ppg_beats' documents and raw\n    signal data. A separate figure is generated for each unique element found.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object containing the PPG data.\n\n    Optional Name-Value Pairs:\n        Linewidth (1,1) double = 1;\n            The line width for the plotted lines.\n\n    Outputs:\n        AX - A column vector of axes handles from all generated plots.\n\n    Example:\n        ax = mlt.plot.HeartBeatsFromDocs(mySession, 'Linewidth', 1.5);\n\n    See also mlt.plot.HeartBeat, mlt.doc.getHeartBeats, mlt.ppg.getRawData\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/HeartBeatsFromFiles.m/","title":"mlt.plot.HeartBeatsFromFiles","text":"<pre><code> HEARTBEATSFROMFILES - Plots beat statistics overlaid on the raw PPG signal.\n\n    AX = mlt.plot.HeartBeatsFromFiles(S)\n\n    This function visualizes pre-calculated heart beat statistics by\n    overlaying them on top of the **raw, unnormalized** PPG signal.\n\n    It loads data from pre-processed MAT-files found within the NDI session\n    path. These files contain beat statistics (e.g., onset, frequency) that\n    were derived from a **normalized** version of the data (using a rolling\n    z-score), as well as the original raw PPG signal for the plot background.\n\n    The MAT-files are assumed to follow the naming convention:\n    'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat'\n    ...where AREA is the recording site (e.g., 'heart', 'pylorus') and\n    NUMBER is the element's reference number.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object containing the PPG data.\n\n    Optional Name-Value Pairs:\n        Linewidth (1,1) double = 1;\n            The line width for the plotted lines.\n\n    Outputs:\n        AX - A column vector of axes handles. Each set of 3 axes handles\n             (for the 3 subplots in a figure) is concatenated vertically.\n\n    Example 1: Basic usage\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.HeartBeatsFromFiles(mySession);\n\n    Example 2: Specifying a custom line width\n        ax = mlt.plot.HeartBeatsFromFiles(mySession, 'Linewidth', 2);\n\n    See also mlt.plot.HeartBeat, ndi.session, ndi.dataset\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/Spectrogram.m/","title":"mlt.plot.Spectrogram","text":"<pre><code> MLT.PLOT.SPECTROGRAM Plots a spectrogram.\n\n    mlt.plot.Spectrogram(SPEC, F, TS, Name, Value, ...) plots a spectrogram in the current axes.\n\n    Plots the spectrogram, applying dB/linear conversions as specified.\n    Plots time in hours if TS is in seconds, or uses datetime values directly.\n\n    Input Arguments:\n        SPEC: Spectrogram data (matrix).\n        F: Frequency vector.\n        TS: Time vector (double in seconds or datetime).\n\n    Name/Value Pairs:\n        convertDBtoLinear: Logical, convert dB to linear (default true).\n        convertLinearToDB: Logical, convert linear to dB (default false).\n        shading: Shading style ('faceted', 'flat', or 'interp', default 'flat').\n        drawLabels: Logical, whether to draw axis labels (default true).\n        colorbar: Logical, whether to draw a colorbar (default false).\n        maxColorPercentile:  The percentile of data to use as\n                                        the maximum value for the color scale. (default 99).\n        colormapName: Name of the colormap to use (default 'parula').\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsBeatsOverlayFromFiles.m/","title":"mlt.plot.SpectrogramsBeatsOverlayFromFiles","text":"<pre><code> MLT.PLOT.SPECTROGRAMSBEATSOVERLAYFROMFILES - Plots spectrograms with a heart beat frequency overlay.\n\n    AX = mlt.plot.SpectrogramsBeatsOverlayFromFiles(S)\n\n    This function visualizes the relationship between instantaneous heart beat\n    frequency and the spectral content of a PPG signal. For each PPG probe in\n    the NDI session, it plots a spectrogram and overlays the beat frequency\n    trace on top.\n\n    The function loads data from two separate, pre-calculated MAT-files for\n    each probe. It searches for these files in the NDI session's path using\n    the following naming conventions:\n\n    1. Spectrogram File: 'ppg_ppg_AREA_lp_whole_NUMBER.mat'\n       (Must contain 'spec', 'f', and 'ts' variables)\n    2. Beats File: 'ppg_ppg_AREA_lp_whole_NUMBER_beats.mat'\n       (Must contain a 'beats' struct)\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the spectrogram data to use as the maximum\n            value for the color scale (0-100).\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot').\n        numSubplots (1,1) double = 10\n            The number of vertical subplots to prepare in the figure.\n\n    Outputs:\n        ax - A column vector of axes handles for the generated subplots.\n\n    Example:\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.SpectrogramsBeatsOverlayFromFiles(mySession);\n\n    See also mlt.plot.Spectrogram, mlt.plot.HeartBeatFromFiles\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromDocs.m/","title":"mlt.plot.SpectrogramsFromDocs","text":"<pre><code>  SPECTROGRAMSFROMDOCS - Plot spectrograms from NDI document data for each subject.\n\n    AX = mlt.plot.SpectrogramsFromDocs(S, ...)\n\n    Plots all available spectrograms from all subjects and record types\n    ('heart', 'pylorus', 'gastric') into a single figure with multiple subplots.\n\n    The function first loops through all subjects and record types to find all\n    available spectrograms and determine the total number of subplots needed.\n    It then creates a single figure and plots each spectrogram in a separate\n    subplot. Finally, it links the axes of all subplots.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the data to use as the maximum value for the\n            color scale, clipping extreme values. Must be between 0 and 100.\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot', 'gray').\n\n    Outputs:\n        ax - A column vector of all created axes handles.\n\n    Example:\n        % Plot all spectrograms with a colorbar and a 'hot' colormap\n        ax = mlt.plot.SpectrogramsFromDocs(mySession, 'colorbar', true, 'colormapName', 'hot');\n\n    See also: mlt.plot.Spectrogram, mlt.doc.getSpectrogramData, mlt.ndi.getElement\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/SpectrogramsFromFiles.m/","title":"mlt.plot.SpectrogramsFromFiles","text":"<pre><code> SPECTROGRAMSFROMFILES - Plot spectrograms for PPG elements from pre-calculated files.\n\n    AX = mlt.plot.SpectrogramsFromFiles(S)\n\n    Plots spectrograms for all 'ppg' probes found within an ndi.session or\n    ndi.dataset object S. The spectrograms for all probes are plotted as\n    subplots within a single figure.\n\n    This function searches the NDI session's path for pre-calculated MAT-files\n    that contain spectrogram data. These files are assumed to be named\n    according to the convention:\n\n    'ppg_ppg_AREA_lp_whole_NUMBER.mat'\n\n    ...where AREA is the recording site (e.g., 'heart', 'pylorus') and\n    NUMBER is the element's reference number. Each file must contain the\n    variables: 'spec' (the spectrogram data), 'f' (frequency vector), and\n    'ts' (time vector).\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the data to use as the maximum value for the\n            color scale, clipping extreme values. Must be between 0 and 100.\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot', 'gray').\n        numSubplots (1,1) double = 10\n            The number of vertical subplots to prepare in the figure.\n\n    Outputs:\n        ax - A column vector of axes handles for the generated subplots.\n\n    Example 1: Basic usage\n        % Assuming 'mySession' is an ndi.session object\n        ax = mlt.plot.SpectrogramsFromFiles(mySession);\n\n    Example 2: Plot with color bars and a different colormap\n        ax = mlt.plot.SpectrogramsFromFiles(mySession, 'colorbar', true, 'colormapName', 'hot');\n\n    See also mlt.plot.gracePlotSpectrogram, imagesc, colormap\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/Traces.m/","title":"mlt.plot.Traces","text":"<pre><code>  MLT.PLOT.TRACES - Plot heart beat and spectrogram data traces for specific time intervals.\n\n    MLT.PLOT.TRACES(DATA, TIME_INTERVALS, Name, Value)\n\n    Plots spectrogram, raw data, instantaneous firing rate, and amplitude for\n    specified time intervals. The function searches through an array of data\n    structures to find the appropriate record that contains the requested time\n    interval.\n\n    The upper 40% of the window is the spectrogram.\n    The lower 60% of the window has several axes with line plots:\n       - Raw data (from mlt.ppg.getRawData)\n       - Instantaneous firing rate (from heart beats data)\n       - Amplitude (from heart beats data)\n       - A blank plot for temperature (for future use)\n\n    Inputs:\n       DATA - An array of data structures returned by mlt.doc.getHeartBeatAndSpectrogram.\n       TIME_INTERVALS - An Nx2 matrix of datetime objects, where each row\n           represents a [t0, t1] interval to be plotted.\n\n    Name-Value Pairs:\n       'TitleInterpreter' - The interpreter for the plot titles ('none', 'tex', 'latex').\n                            Default is 'none'.\n       'timePrePostWindow' - The time in seconds to extend the data window\n                             before and after the specified interval.\n                             Default is 180 seconds.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/gracePlotAll.m/","title":"mlt.plot.gracePlotAll","text":"<pre><code> GRACEPLOTALL - Plot all summary data for an NDI session/dataset.\n\n    mlt.plot.gracePlotAll(S)\n\n    Generates a comprehensive set of plots summarizing photoplethysmogram\n    (PPG) data from an ndi.session or ndi.dataset object S. It creates\n    three separate figures:\n        1. Spectrograms of the PPG data.\n        2. Heartbeat statistics plots (raw PPG, frequency, duty cycle).\n        3. Spectrograms with overlaid heartbeat frequency.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        colorbar (1,1) logical = false\n            Whether to display colorbars for the spectrogram plots.\n\n        colormapName (1,:) char = 'parula'\n            The colormap to use for the spectrogram plots.\n\n        maxColorPercentile (1,1) double = 99\n            The percentile of spectrogram data to use as the maximum\n            value for the color scale (for contrast enhancement).\n\n        Linewidth (1,1) double = 1\n            The line width for the heartbeat statistics plots.\n\n    Details:\n        This function calls three other functions to generate the plots:\n            1. mlt.plot.SpectrogramsFromFiles\n            2. mlt.plot.HeartBeatsFromFiles\n            3. mlt.plot.SpectrogramBeatsOverlayFromFiles\n\n        The function then links the x-axes across all generated figures,\n        ensuring that zooming and panning are synchronized.\n\n    Example 1: Basic Usage\n        mlt.plot.gracePlotAll(mySession);\n\n    Example 2: Name-value pair inputs\n        mlt.plot.gracePlotAll(mySession, 'colorbar', true, ...\n            'colormapName', 'hot', 'Linewidth', 1.5);\n\n    See also mlt.plot.SpectrogramsFromFiles, mlt.plot.HeartBeatsFromFiles,\n    mlt.plot.SpectrogramBeatsOverlayFromFiles, linkaxes\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutONOFF.m/","title":"mlt.plot.plotInhibitoryBoutONOFF","text":"<pre><code> MLT.PLOT.PLOTINHIBITORYBOUTONOFF Plots binned beat rates with bout events.\n    ax = mlt.plotInhibitoryBoutONOFF(bouts) creates a plot of the binned\n    beat rate over time and overlays vertical lines indicating the onset\n    (RED) and offset (BLUE) of inhibitory bouts.\n\n    The function uses the binned rate data stored within the 'bouts'\n    structure, which should be generated by mlt.inhibitoryBouts.findInhibitoryBouts.\n\n    SYNTAX:\n    ax = mlt.plot.plotInhibitoryBoutONOFF(bouts)\n\n    INPUTS:\n    bouts               - The output structure from mlt.inhibitoryBouts.findInhibitoryBouts.\n                          It must contain the fields:\n                          .beatRate\n                          .beatRateTimes\n                          .inhibitoryBoutOnset\n                          .inhibitoryBoutOffset\n\n    OUTPUTS:\n    ax                  - The handle to the axes of the generated plot.\n\n    EXAMPLE:\n        % 1. Create synthetic beat data\n        beat_times = [ (0:0.4:10), (10.5:1:20), (20.4:0.4:30) ]';\n\n        % 2. Find the inhibitory bouts (which now includes rate data)\n        bouts = mlt.inhibitoryBouts.findInhibitoryBouts(beat_times);\n\n        % 3. Plot the results directly from the bouts structure\n        figure;\n        ax = mlt.plot.plotInhibitoryBoutONOFF(bouts);\n        title('Inhibitory Bout Detection');\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/plotInhibitoryBoutOnsetOffset.m/","title":"mlt.plot.plotInhibitoryBoutOnsetOffset","text":"<pre><code> MLT.PLOT.PLOTINHIBITORYBOUTONSETOFFSET Plot spectrogram analysis results around onset/offset.\n\n    AX = mlt.plot.plotInhibitoryBoutOnsetOffset(ONSETDATA, OFFSETDATA, Name, Value, ...)\n\n    Creates a 3-panel figure summarizing the spectrogram analysis results\n    obtained from `mlt.spectrogram.spectrogramInhibitoryBoutOnsetOffsetAnalysis`.\n\n    Inputs:\n        ONSETDATA  - Structure containing results from analyzing windows before onsets:\n            .specData_matrix   - Matrix of time-averaged spectra (freq x bouts).\n            .f                 - Frequency vector (column).\n            .fwhm_vector       - Row vector of FWHM values.\n            .low_cutoff_vector - Row vector of low cutoffs.\n            .high_cutoff_vector- Row vector of high cutoffs.\n        OFFSETDATA - Structure containing results from analyzing windows after offsets\n                     (same fields as ONSETDATA).\n\n    Optional Name/Value Pair Arguments:\n        CapSize    - (Default: 15) Numeric scalar specifying the size of the\n                     error bar caps in points for the FWHM plot.\n\n    Outputs:\n        AX         - A 3x1 vector of axes handles for the three subplots created.\n\n    Figure Panels:\n        1. Top Panel: Plots the absolute value of individual time-averaged spectra\n           (gray lines) and the mean absolute spectrum (black line) for the\n           OnsetData vs. frequency. Title: 'Prior to onset'. Y-axis: 'Power'.\n           X-axis: 'Frequency (Hz)'.\n        2. Middle Panel: Plots the absolute value of individual time-averaged spectra\n           (gray lines) and the mean absolute spectrum (black line) for the\n           OffsetData vs. frequency. Title: 'After offset'. Y-axis: 'Power'.\n           X-axis: 'Frequency (Hz)'.\n        3. Bottom Panel: Bar graph comparing a modified FWHM measure\n           (high_cutoff - max(0, low_cutoff)) between OnsetData and OffsetData.\n           Individual data points are overlaid with jitter. Error bars show SEM\n           (plotted thicker, brought to front, cap size adjustable).\n           Title displays the p-value from a paired t-test between the groups.\n           Y-axis: 'FWHM (Hz)'. X-axis labels: 'Onset', 'Offset'.\n\n    Requires:\n        - NDI toolbox (+ndi)\n        - vhlab-toolbox-matlab (+vlt), specifically vlt.signal.fwhm (used by mlt.spectrogram.spectrogramFWHM)\n        - NDIcalc-marder-matlab (+mlt), specifically mlt.spectrogram.spectrogramFWHM,\n          mlt.spectrogram.readSpectrogramTimeWindow, and this function\n          (mlt.plot.plotInhibitoryBoutOnsetOffset).\n        - Associated helper functions like `ndi.fun.data.readngrid` (if not standard)\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bplot/subjectTrace.m/","title":"mlt.plot.subjectTrace","text":"<pre><code> SUBJECTTRACE Plots a detailed summary trace for a single subject and record.\n\n    AX = mlt.plot.subjectTrace(S, subject_name, record_type)\n\n    Generates a comprehensive 4-panel plot for a single recording from a\n    specific subject. It loads the pre-calculated spectrogram and heart beat\n    data from their respective NDI documents and visualizes them together.\n\n    The layout consists of:\n    - Top Panel (50%): Spectrogram.\n    - Bottom Panels: Three plots showing beat instantaneous frequency, \n      amplitude, and duty cycle over time.\n\n    All four plot axes are linked horizontally for synchronized zooming and panning.\n\n    Inputs:\n        S             - An ndi.session or ndi.dataset object.\n        subject_name  - The name of the subject (e.g., 'SubjectA').\n        record_type   - The type of record ('heart', 'gastric', or 'pylorus').\n\n    Optional Name-Value Pair Arguments:\n        Linewidth (1,1) double = 1.5\n            Line width for the time-series plots.\n        colorbar (1,1) logical = false\n            Set to true to display a color bar for each spectrogram.\n        maxColorPercentile (1,1) double = 99\n            The percentile of the data to use as the maximum value for the\n            color scale, clipping extreme values. Must be between 0 and 100.\n        colormapName (1,:) char = 'parula'\n            The name of the colormap to use (e.g., 'jet', 'hot', 'gray').\n\n    Outputs:\n        ax - A struct containing the handles to the four subplot axes.\n\n    Example:\n        % Plot a summary for Subject A's heart recording\n        ax = mlt.plot.subjectTrace(mySession, 'SubjectA', 'heart');\n\n    See also mlt.ndi.getElement, mlt.spectrogram.readTimeWindow, mlt.beats.beatsdoc2struct\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bppg/downsample.m/","title":"mlt.ppg.downsample","text":"<pre><code>  DOWNSAMPLE - downsample PPG data for Marder experiments\n\n  DOWNSAMPLE(S)\n\n  Downsample all ppg probes for an ndi.session or ndi.dataset S.\n\n  Downsamples probes of type 'ppg' by adding '_lp' to their name.\n\n  After downsampling, an element with a single epoch of the ppg record is made\n  by adding '_lp_whole' to the element name. This element is returned in \n  ELEM_OUT_O.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bppg/getRawData.m/","title":"mlt.ppg.getRawData","text":"<pre><code> MLT.PPG.GETRAWDATA Retrieves the raw time series data for a unique PPG element.\n\n    [D, T] = mlt.ppg.getRawData(S, SUBJECT_NAME, RECORD_TYPE, [ELEMENT_LABEL])\n\n    This function finds a unique NDI element for a given subject and record\n    type and returns its entire raw time series data. It uses\n    `mlt.ndi.getElement` to perform the search.\n\n    The function also handles time conversion. If the element's epoch is associated\n    with a global experiment clock, the output time vector 'T' will be a `datetime`\n    vector. Otherwise, it will be a numeric vector in seconds from the start of\n    the recording.\n\n    Inputs:\n        S             - An ndi.session or ndi.dataset object.\n        SUBJECT_NAME  - The name of the subject (e.g., 'SubjectA').\n        RECORD_TYPE   - The type of record ('heart', 'gastric', or 'pylorus').\n        ELEMENT_LABEL - (Optional) A further label to identify the element.\n                        Defaults to 'lp_whole'.\n\n    Outputs:\n        D             - The raw data vector (unnormalized).\n        T             - The time vector (`datetime` or numeric seconds).\n\n    Example:\n        % Get the raw heart PPG data for SubjectA\n        [data, time] = mlt.ppg.getRawData(mySession, 'SubjectA', 'heart');\n\n        % Plot the raw data\n        figure;\n        plot(time, data);\n        title('Raw PPG Signal for SubjectA');\n        xlabel('Time');\n\n    See also: mlt.ndi.getElement, ndi.element.readtimeseries\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/FWHM.m/","title":"mlt.spectrogram.FWHM","text":"<pre><code> FWHM Calculates time-averaged spectrogram and its Full Width at Half Maximum.\n\n    [specData_avg, f, fwhm_val, low_cutoff, high_cutoff] = ...\n        mlt.spectrogram.FWHM(e, t0, t1)\n\n    Calculates the time-averaged power spectrum and its full width at half\n    maximum (FWHM) for a given ndi.element 'e' within a specified time\n    window [t0, t1].\n\n    This function first retrieves the spectrogram data for the specified\n    window and then performs the FWHM calculation on the time-averaged result.\n\n    Inputs:\n        e  - An ndi.element object that has associated 'spectrogram' documents.\n        t0 - A datetime object representing the start of the analysis window.\n        t1 - A datetime object representing the end of the analysis window.\n\n    Outputs:\n        specData_avg - A column vector of the power spectrum averaged over time.\n                       Returns empty if no data is found in the window.\n        f            - The corresponding frequency vector (column vector).\n        fwhm_val     - The full width at half maximum (FWHM) of the spectrum (Hz).\n                       Returns NaN if FWHM cannot be calculated.\n        low_cutoff   - The lower frequency cutoff at half maximum height (Hz).\n        high_cutoff  - The upper frequency cutoff at half maximum height (Hz).\n\n    Example:\n        % Assuming 'my_element' is a valid ndi.element with spectrograms\n        t_start = datetime('2025-09-05 10:00:00');\n        t_end = datetime('2025-09-05 10:05:00');\n        [spec_avg, f, fwhm] = mlt.spectrogram.FWHM(my_element, t_start, t_end);\n\n        % Plot the time-averaged spectrum and its FWHM\n        if ~isempty(spec_avg)\n            figure;\n            plot(f, spec_avg);\n            title(['FWHM: ' num2str(fwhm, '%.2f') ' Hz']);\n            xlabel('Frequency (Hz)');\n            ylabel('Average Power');\n            grid on;\n        end\n\n    See also mlt.spectrogram.readTimeWindow, vlt.signal.fwhm\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForDocs.m/","title":"mlt.spectrogram.calculateForDocs","text":"<pre><code> CALCULATEFORDOCS - Calculate and save PPG spectrograms as NDI documents.\n\n    mlt.spectrogram.calculateForDocs(S)\n\n    This is a high-level wrapper function that automates the process of\n    calculating spectrograms for all PPG (photoplethysmogram) probes within\n    a given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls the core processing function, mlt.wholeDaySpectrogramDoc,\n    to perform the spectrogram calculation and save the results as a\n    'spectrogram' NDI document.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.spectrogram.calculateForDocs(mySession);\n\n    See also mlt.wholeDaySpectrogramDoc, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/calculateForFiles.m/","title":"mlt.spectrogram.calculateForFiles","text":"<pre><code> CALCULATEFORFILES - Calculate and save PPG spectrograms as .mat files.\n\n    mlt.spectrogram.calculateForFiles(S)\n\n    This is a high-level wrapper function that automates the process of\n    calculating spectrograms for all PPG (photoplethysmogram) probes within\n    a given NDI session or dataset.\n\n    For each 'ppg' probe found, the function first identifies its\n    corresponding low-pass filtered data element (e.g., 'ppg_heart_lp_whole').\n    It then calls a core processing function to perform the spectrogram\n    calculation and saves the results to a standalone .mat file in the\n    session's path.\n\n    The output files are named according to the convention:\n    'ppg_ELEMENT-NAME_REFERENCE.mat'\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Example:\n        % Assuming 'mySession' is a valid ndi.session object with PPG data\n        mlt.spectrogram.calculateForFiles(mySession);\n\n    See also mlt.wholeDaySpectrogram, ndi.session\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/readTimeWindow.m/","title":"mlt.spectrogram.readTimeWindow","text":"<pre><code> READTIMEWINDOW Read the first matching spectrogram data within a time window.\n\n    [spectrogram_data, f, t_datetime, spectrogram_doc] = ...\n        mlt.spectrogram.readTimeWindow(e, t0, t1)\n\n    Searches an NDI session for 'spectrogram' documents associated with a\n    given ndi.element 'e'. It finds the first document that temporally\n    overlaps with the window [t0, t1], reads the spectrogram data, and\n    returns only the portion of the data that falls within the window.\n\n    Inputs:\n        e  - An ndi.element object. The session is retrieved from e.session.\n        t0 - A datetime object representing the start of the window.\n        t1 - A datetime object representing the end of the window.\n\n    Outputs:\n        spectrogram_data - The portion of the spectrogram data (numeric matrix,\n                           typically [frequency x time]) that falls within the\n                           [t0, t1] window. Returns [] if no match is found.\n        f                - The frequency vector (column vector) for the data.\n        t_datetime       - A datetime vector for the time axis of the returned data.\n        spectrogram_doc  - The ndi.document object from which the data was extracted.\n\n    Logic:\n        1. Finds all 'spectrogram' documents that depend on the element 'e'.\n        2. For each document, it checks if the document's epoch overlaps with [t0, t1].\n        3. For the first overlapping document, it reads the full ngrid data.\n        4. It converts the data's local timestamps to the session's global time clock.\n        5. It filters the data and timestamps to the requested [t0, t1] window.\n        6. It returns the filtered data and exits. If no match is found, it returns empty.\n\n    Example:\n        % Assuming 'my_element' is a valid ndi.element with spectrograms\n        t_start = datetime('2025-09-05 10:00:00');\n        t_end = datetime('2025-09-05 10:05:00');\n        [spec, freq, time] = mlt.spectrogram.readTimeWindow(my_element, t_start, t_end);\n        if ~isempty(spec)\n            imagesc(time, freq, spec);\n            set(gca, 'YDir', 'normal');\n        end\n\n    See also mlt.spectrogram.FWHM, ndi.session.database_search, ndi.time.syncgraph.time_convert\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogram.m/","title":"mlt.spectrogram.wholeDaySpectrogram","text":"<pre><code> WHOLEDAYSPECTROGRAM Computes a spectrogram for a complete NDI element recording.\n\n    [SPEC, F, TS] = mlt.spectrogram.wholeDaySpectrogram(S, Name, Value, ...)\n\n    Calculates a spectrogram for the entire duration of a specified\n    ndi.element. The function has two primary modes of operation based on\n    the time clocks available for the element's first epoch.\n\n    1.  **Global Clock Mode**: If an 'exp_global_time' clock is found, the\n        function reads the entire time series at once. It then applies a\n        Z-score normalization (either moving or global) to the signal before\n        computing the spectrogram with `mlt.util.computeSpectrogram`.\n\n    2.  **Epoch-by-Epoch Mode**: If no global clock is found, the function\n        iterates through each epoch of the element individually. It computes a\n        spectrogram for each epoch using `mlt.util.makeSpectrogram`, optionally\n        downsamples the result, and concatenates the pieces to form a single,\n        continuous output.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        e_name ('ppg_heart_lp')\n            The name of the ndi.element to analyze.\n        e_reference (1)\n            The reference number of the ndi.element.\n        f (0.1:0.1:10)\n            A vector of frequencies (Hz) to analyze in the spectrogram.\n        windowTime (10)\n            The duration of the sliding window (in seconds) used for the\n            spectrogram calculation.\n        downSample (2)\n            (Epoch-by-Epoch Mode Only) The factor by which to downsample the\n            time dimension of the spectrogram for each epoch. For example, a\n            value of 2 keeps every other time point.\n        zscoreWindowTime (3600)\n            (Global Clock Mode Only) The duration of the moving window (in\n            seconds) for z-score normalization. If set to 0, a global z-score\n            is applied across the entire signal.\n\n    Outputs:\n        spec - The computed spectrogram data matrix ([frequency x time]).\n        f    - The frequency vector (Hz) corresponding to the rows of 'spec'.\n        ts   - The time vector corresponding to the columns of 'spec'. The\n               units are datenum in Global Clock Mode and seconds from the\n               start in Epoch-by-Epoch Mode.\n\n    Example:\n        % Calculate a spectrogram for a specific element\n        [spec, f, ts] = mlt.spectrogram.wholeDaySpectrogram(mySession, ...\n            'e_name', 'ppg_pylorus_lp_whole', 'e_reference', 1);\n\n        % Plot the result\n        figure;\n        imagesc(ts, f, spec);\n        set(gca, 'YDir', 'normal');\n        xlabel('Time');\n        ylabel('Frequency (Hz)');\n\n    See also mlt.util.computeSpectrogram, mlt.util.makeSpectrogram, mlt.util.movzscore, ndi.element\n</code></pre>"},{"location":"reference/%2Bmlt/%2Bspectrogram/wholeDaySpectrogramDoc.m/","title":"mlt.spectrogram.wholeDaySpectrogramDoc","text":"<pre><code> WHOLEDAYSPECTROGRAMDOC Computes and saves a spectrogram as an NDI document.\n\n    [DOC] = mlt.spectrogram.wholeDaySpectrogramDoc(S, Name, Value, ...)\n\n    Calculates a spectrogram for the entire duration of a specified\n    ndi.element and saves the result as an NDI document in the session's\n    database. This function is a key step in pre-processing data for later\n    analysis.\n\n    The function has two primary modes of operation based on the time clocks\n    available for the element's first epoch:\n\n    1.  **Continuous Mode**: If a 'dev_local_time' clock is found, the\n        function reads the entire time series for that epoch at once. It\n        then applies a Z-score normalization before computing the spectrogram.\n\n    2.  **Epoch-by-Epoch Mode**: If no local clock is found, the function\n        iterates through each epoch of the element individually, computes a\n        spectrogram for each, and concatenates the results.\n\n    After calculation, the function creates an 'spectrogram' type NDI document,\n    writes the spectrogram data to a binary .ngrid file, links the file to\n    the document, and adds the document to the database. **Note:** If a\n    spectrogram document for this element's first epoch already exists, it\n    will be removed and replaced.\n\n    Inputs:\n        S - An ndi.session or ndi.dataset object.\n\n    Optional Name-Value Pairs:\n        e_name ('ppg_heart_lp_whole')\n            The name of the ndi.element to analyze.\n        e_reference (1)\n            The reference number of the ndi.element.\n        f (0.1:0.1:10)\n            A vector of frequencies (Hz) to analyze in the spectrogram.\n        windowTime (10)\n            The duration of the sliding window (in seconds) for the calculation.\n        downSample (2)\n            (Epoch-by-Epoch Mode Only) The factor by which to downsample the\n            time dimension of the spectrogram.\n        zscoreWindowTime (3600)\n            (Continuous Mode Only) The duration of the moving window (in\n            seconds) for z-score normalization. If set to 0, a global z-score\n            is applied across the entire signal.\n\n    Outputs:\n        doc - The ndi.document object that was created and added to the database.\n\n    Example:\n        % Calculate a spectrogram and save it as a document for a specific element\n        doc = mlt.spectrogram.wholeDaySpectrogramDoc(mySession, ...\n            'e_name', 'ppg_pylorus_lp_whole', 'e_reference', 1);\n\n    See also mlt.spectrogram.wholeDaySpectrogram, ndi.document, ndi.session.database_add\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/computeChunkedSpectrogram.m/","title":"mlt.util.computeChunkedSpectrogram","text":"<pre><code> COMPUTECHUNKEDSPECTROGRAM Calculates a spectrogram for discontinuously sampled data.\n\n    [spectrogram_data, f, t_s] = computeChunkedSpectrogram(data, t, ...)\n\n    This function is designed to compute a spectrogram for time-series data\n    that may contain gaps or discontinuities in its sampling. It works by\n    identifying large jumps in the time vector, splitting the data into\n    continuous chunks, computing a spectrogram for each chunk, and then\n    concatenating the results.\n\n    This preserves the temporal integrity of the recording, and the output\n    time vector 't_s' will reflect the original gaps.\n\n    Inputs:\n        data - A numeric column vector of time-series data.\n        t    - A numeric or datetime column vector of timestamps for the data.\n\n    Optional Name-Value Pair Arguments:\n        frequencies (1,:) double = 0.1:0.1:10\n            A vector of frequencies (Hz) to evaluate in the spectrogram.\n        windowSizeTime (1,1) double = 10\n            The duration of the sliding window in seconds.\n        useDecibels (1,1) logical = true\n            If true, converts the output power spectrogram to decibels (10*log10(P)).\n        timeIsDatenum (1,1) logical = false\n            If true, the input time vector 't' is treated as MATLAB datenum values.\n        gapThresholdFactor (1,1) double = 2\n            A factor that is multiplied by the median sample interval to\n            determine the time difference that constitutes a gap. Any jump\n            in time greater than this threshold will split the data.\n\n    Outputs:\n        spectrogram_data - The concatenated spectrogram data matrix ([frequency x time]).\n        f                - The frequency vector (Hz) corresponding to the rows.\n        t_s              - The concatenated time vector for the columns. Its type\n                           (numeric or datetime) matches the input time vector 't'\n                           and it will contain the same time gaps.\n\n    See also spectrogram, diff, median\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/computeSpectrogram.m/","title":"mlt.util.computeSpectrogram","text":"<pre><code> COMPUTESPECTROGRAM Calculates a spectrogram with specific toolbox defaults.\n\n    [spectrogram_data, f, t_s] = mlt.util.computeSpectrogram(data, t, ...)\n\n    This is the core spectrogram calculation engine for the toolbox. It serves\n    as a wrapper around MATLAB's built-in `spectrogram` function, providing\n    convenient handling of time vectors (including datetime and datenum) and\n    conversion of the output power to decibels.\n\n    Inputs:\n        data - A numeric column vector of time-series data.\n        t    - A numeric or datetime column vector of timestamps for the data.\n\n    Optional Name-Value Pair Arguments:\n        frequencies (1,:) double = 0.1:0.1:10\n            A vector of frequencies (Hz) to evaluate in the spectrogram.\n        windowSizeTime (1,1) double = 10\n            The duration of the sliding window in seconds.\n        useDecibels (1,1) logical = true\n            If true, converts the output power spectrogram to decibels (10*log10(P)).\n        timeIsDatenum (1,1) logical = false\n            If true, the input time vector 't' is treated as MATLAB datenum values\n            instead of seconds.\n\n    Outputs:\n        spectrogram_data - The computed spectrogram data matrix ([frequency x time]).\n        f                - The frequency vector (Hz) corresponding to the rows.\n        t_s              - The time vector for the columns. Its type (numeric or\n                           datetime) matches the input time vector 't'.\n\n    Example:\n        % Create a sample signal: 2 Hz sine wave for 60 seconds\n        fs = 100; % 100 Hz sampling rate\n        t = (0:1/fs:60-1/fs)';\n        data = sin(2*pi*2*t) + 0.5*randn(size(t));\n        freqs_of_interest = 0:0.5:10;\n\n        [spec, f, ts] = mlt.util.computeSpectrogram(data, t, ...\n            'frequencies', freqs_of_interest, 'windowSizeTime', 5);\n\n    See also spectrogram, datetime, log10\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/makeSpectrogram.m/","title":"mlt.util.makeSpectrogram","text":"<pre><code> MAKESPECTROGRAM Computes a spectrogram for a single NDI element epoch.\n\n    [spectrogram_data, f, t_s] = mlt.util.makeSpectrogram(ndi_element_obj, ...\n        epoch_id, frequencies, windowSizeTime)\n\n    This function serves as a convenient wrapper to compute a spectrogram for\n    the entire time series of a single, specified epoch from an NDI element.\n    It reads the data, normalizes it with a global z-score, and then calls\n    the core `mlt.util.spectrogram` function to perform the calculation.\n\n    Inputs:\n        ndi_element_obj - An ndi.element object.\n        epoch_id        - The character vector or string ID for the epoch to\n                          be analyzed.\n        frequencies     - A vector of frequencies (Hz) to be used in the\n                          spectrogram calculation.\n        windowSizeTime  - The desired window size in seconds.\n\n    Outputs:\n        spectrogram_data - The spectrogram data matrix ([frequency x time]).\n        f                - The frequency vector (Hz) used in the calculation.\n        t_s              - The time vector (seconds) for the spectrogram output.\n\n    Example:\n        % Assume 'my_element' is a valid ndi.element and 'epoch001' is an\n        % ID from its epoch table.\n        freqs = 0.1:0.1:10; % 0.1 to 10 Hz\n        win_sec = 10;       % 10-second window\n        [spec, f, t] = mlt.util.makeSpectrogram(my_element, 'epoch001', freqs, win_sec);\n\n    See also mlt.util.spectrogram, ndi.element.readtimeseries, zscore\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/movzscore.m/","title":"mlt.util.movzscore","text":"<pre><code> MOVZSCORE - Moving z-score calculation.\n\n    Computes the moving z-score of the input data X using a sliding window.\n    The z-score is calculated for each element by centering and scaling\n    the element with the mean and standard deviation of its k neighbors.\n\n    Syntax:\n        Z = MOVZSCORE(X, k)\n            Calculates the moving z-score using a window of length k.\n\n        Z = MOVZSCORE(X, [kb kf])\n            Calculates the moving z-score using a directional window, where\n            kb is the number of elements before and kf is the number of\n            elements after the current element.\n\n        Z = MOVZSCORE(..., Options)\n            Specifies additional options using name-value pairs.\n\n    Input Arguments:\n        X - Input data.\n            Vector, matrix, multidimensional array, table, or timetable.\n\n        k - Window length.\n            Numeric or duration scalar.\n\n        [kb kf] - Directional window length.\n            Numeric or duration row vector containing two elements.\n            kb: Number of elements before the current element.\n            kf: Number of elements after the current element.\n\n        Options - Optional parameters specified as name-value pairs.\n            'Weight'        - Weight indicator for standard deviation.\n                              0 (default): Normalization by N-1.\n                              1: Normalization by N.\n\n            'Dimension'     - Dimension to operate along.\n                              Positive integer scalar.\n\n            'NaNFlag'       - Missing value handling.\n                              'includemissing' (default) or 'includenan': Include NaN/missing values.\n                              'omitmissing' or 'omitnan': Exclude NaN/missing values.\n\n            'Endpoints'     - Method to treat leading and trailing windows.\n                              'shrink' (default): Window shrinks at edges.\n                              'discard': Discard edge values (not supported for tables).\n                              'fill': Fill edge values with NaN.\n                              Numeric or logical scalar: Fill edge values with scalar.\n\n            'SamplePoints'  - Sample points for computation.\n                              Vector.\n\n            'DataVariables' - Table or timetable variables to operate on.\n                              Table variable name, scalar, vector, cell array,\n                              pattern, function handle, or table vartype subscript.\n                              Default: Numeric variables.\n\n            'ReplaceValues' - Replace original values with z-scores.\n                              true (default) or 1: Replace original values.\n                              false or 0: Append z-scores as new variables.\n\n    Output Arguments:\n        Z - Moving z-score.\n            Same type and size as X, or table/timetable with appended z-score\n            variables depending on the 'ReplaceValues' option.\n\n    Example:\n        x = randn(100, 1);\n        z = movzscore(x, 10); % Moving z-score with window length 10.\n\n        x = table(randn(10, 2), randn(10, 2), 'VariableNames', {'A', 'B', 'C', 'D'});\n        z = movzscore(x, 3, 'DataVariables', {'A', 'C'}, 'ReplaceValues', false);\n\n    See also: MOVMEAN, MOVSTD.\n\n    Notes:\n        - When 'Endpoints' is 'discard' and X is a table, 'Endpoints' is\n          automatically set to 'fill' with a warning.\n        - If 'DataVariables' is not specified for tables, numeric variables\n          are used by default.\n\n    Error Handling:\n        - 'MOVZSCORE:endpointsDiscardTabular' : When 'Endpoints' is 'discard' and X is a table.\n        - 'MOVZSCORE:defaultDataVariables' : When DataVariables is not specified for tables.\n        - 'MOVZSCORE:invalidDataVariables' : When DataVariables is an unsupported datatype.\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/mscohere.m/","title":"mlt.util.mscohere","text":"<pre><code> MLT.MSCOHERE Computes magnitude-squared coherence with convenient defaults.\n\n    [cxy, f] = mlt.util.mscohere(X, Y, dt) computes the magnitude-squared\n    coherence estimate between time series X and Y. It is a wrapper for\n    the built-in MATLAB `mscohere` function from the Signal Processing\n    Toolbox, tailored for ease of use with specific defaults.\n\n    SYNTAX:\n    [cxy, f] = mlt.util.mscohere(X, Y, dt)\n    [cxy, f] = mlt.util.mscohere(X, Y, dt, Name, Value, ...)\n\n    INPUTS:\n    X           - First time series, specified as a column vector.\n    Y           - Second time series, specified as a column vector. Must be\n                  the same length as X.\n    dt          - The time step (sampling interval) of the time series, in\n                  seconds. The sampling frequency is calculated as 1/dt.\n\n    OPTIONAL NAME-VALUE PAIR INPUTS:\n    'window_length' - Length of the windowing function. The frequency\n                      resolution is determined by Fs/window_length.\n                      Default: 256\n\n    'n_overlap'     - Number of samples by which consecutive windows overlap.\n                      A 50% overlap is generally a good choice.\n                      Default: 128\n\n    'n_fft'         - Number of points for the Fast Fourier Transform.\n                      Note: This function specifies the exact frequencies\n                      to compute via 'freq_vector', so 'n_fft' is not\n                      passed to the underlying MATLAB function. It is\n                      retained here as a parameter for documentation and\n                      potential future use.\n                      Default: 256\n\n    'freq_vector'   - A column vector of frequencies (in Hz) at which to\n                      compute the coherence. This provides direct control\n                      over the output frequency range.\n                      Default: (0:0.1:10)'\n\n    OUTPUTS:\n    cxy         - The magnitude-squared coherence, returned as a column\n                  vector. Values range from 0 to 1.\n    f           - The vector of frequencies (in Hz) corresponding to the\n                  coherence estimates in cxy.\n\n    EXAMPLE:\n    % Create two signals with a common component at 5 Hz\n    Fs = 200;               % Sampling frequency\n    dt = 1/Fs;              % Time step\n    t = (0:dt:10-dt)';      % Time vector (10 seconds)\n\n    common_signal = 0.5 * sin(2*pi*5*t);\n    noise1 = 0.8 * randn(size(t));\n    noise2 = 0.8 * randn(size(t));\n\n    x = common_signal + noise1;\n    y = common_signal + noise2;\n\n    % Compute coherence using the function's defaults (0-10 Hz)\n    [cxy, f] = mlt.util.mscohere(x, y, dt);\n\n    % Plot the results\n    figure;\n    plot(f, cxy, 'LineWidth', 1.5);\n    grid on;\n    title('Coherence between two noisy signals');\n    xlabel('Frequency (Hz)');\n    ylabel('Magnitude-Squared Coherence');\n    ylim([0 1.05]);\n</code></pre>"},{"location":"reference/%2Bmlt/%2Butil/toolboxdir.m/","title":"mlt.util.toolboxdir","text":"<pre><code>  TOOLBOXDIR - return the full path of the mlt-matlab toolbox\n\n  P = mlt.util.toolboxdir()\n\n  Returns the full path to the mlt-matlab toolbox.\n\n  It is assumed that this function is in the folder\n  [TOOLBOXDIR]/+mlt/+util/\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/demo.m/","title":"ndi.setup.conv.marder.demo","text":"<pre><code>  The problem:\n\n  Find all recording sessions that exhibit variation in a stimulus_parameter\n  called 'Command temperature constant'.  Sessions should be from the marderlab\n  (from subjects that have '@marderlab.brandeis.edu' in the 'local_identifier' field).\n  Then, for each subject, plot epochs from probe that is located in\n  the 'lateral ventricular nerve' as a function of command temperature.\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/plot_epoch.m/","title":"ndi.setup.conv.marder.plot_epoch","text":"<pre><code>  PLOT_EPOCH - plot an epoch\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/postsetup2.m/","title":"ndi.setup.conv.marder.postsetup2","text":"<pre><code>  POSTSETUP - does all post-setup operations for Marder lab data\n\n  POSTSETUP(S)\n\n  1) Generates epochprobemaps for ABF data\n  2) Checks that the probes are available in S\n  3) Generates the metadata with ndi.setup.conv.marder.bath.preptemptable(S)\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/presetup.m/","title":"ndi.setup.conv.marder.presetup","text":"<pre><code>  PRESETUP - set up the Marder lab directory based on the directory name\n\n  S = PRESETUP(DIRNAME, N, Name, Value, ...)\n\n  Sets up a Marderlab directory for import using NDI methods.\n\n  Inputs:\n    DIRNAME - The full path to the directory to be set up. Must be a valid folder.\n    N - An integer identifier (e.g., experiment number), must be &gt;= 1.\n\n  Optional Name-Value Pair Arguments:\n    makeSubjects (logical) - If true, creates subject entries based on N.\n                             Defaults to false.\n    makeProbeTable (logical) - If true, generates the probeTable.csv file from\n                               .abf files and opens it for editing.\n                               Defaults to true.\n\n  Outputs:\n    S - The NDI session object for the created/configured directory.\n\n  Example:\n    % Basic setup, creates probe table by default\n    S = presetup('/path/to/my/experiment', 1);\n\n    % Setup without creating probe table\n    S = presetup('/path/to/my/experiment', 2, 'makeProbeTable', false);\n\n    % Setup and create subject entries\n    S = presetup('/path/to/my/experiment', 3, 'makeSubjects', true);\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/setupInteractive.m/","title":"ndi.setup.conv.marder.setupInteractive","text":"<pre><code>  SETUPINTERACTIVE - an interactive version of presetup\n\n  S = SETUPINTERACTIVE(DIRNAME)\n\n  Interactively sets up a Marderlab directory for import using NDI methods.\n\n  Inputs:\n    DIRNAME - The full path to the directory to be set up. Must be a valid folder.\n              If not provided, the current working directory is used.\n\n  Outputs:\n    S - The NDI session object for the created/configured directory.\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/marderbath.m/","title":"ndi.setup.conv.marder.bath.marderbath","text":"<pre><code>  MARDERBATH - Create NDI documents for bath stimulation information.\n\n  D = MARDERBATH(S)\n\n  Creates NDI documents of type 'stimulus_bath' for a Marder Lab session.\n  This function reads a 'bath_table.csv' file from the session directory, which\n  specifies the chemical mixtures applied to the bath and the epochs during\n  which they were active.\n\n  It uses helper JSON files ('marder_mixtures.json' and 'marder_bathtargets.json')\n  to look up detailed information about the mixtures and their target locations.\n\n  The function generates a 'stimulus_bath' document for each epoch and stimulus\n  combination defined in the bath table, linking them to the appropriate\n  stimulus elements and anatomical locations (via UBERON ontology).\n\n  INPUTS:\n    S: (ndi.session) The NDI session object.\n\n  OUTPUTS:\n    d: (cell array of ndi.document) A cell array of the newly created\n       'stimulus_bath' documents. Note: These documents are NOT automatically\n       added to the database.\n\n  REQUIRED FILES:\n    - [session_path]/bath_table.csv: A table defining bath applications.\n      Columns should include \"firstFile\", \"lastFile\", \"bathTargets\", \"mixtures\".\n    - [toolbox_path]/+ndi/+setup/+conv/+marder/+bath/marder_mixtures.json: Defines the\n      composition of chemical mixtures.\n    - [toolbox_path]/+ndi/+setup/+conv/+marder/+bath/marder_bathtargets.json: Maps\n      target names to UBERON ontology identifiers.\n\n  EXAMPLE:\n    % Assuming S is a valid NDI session object and bath_table.csv exists\n    bath_docs = ndi.setup.conv.marder.bath.marderbath(S);\n    S.database_add(bath_docs); % Add the new documents to the database\n\n  See also: ndi.setup.conv.marder.bath.mixtureStr2mixtureTable, ndi.database.fun.uberon_ontology_lookup\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/mixtureStr2mixtureTable.m/","title":"ndi.setup.conv.marder.bath.mixtureStr2mixtureTable","text":"<pre><code>  MIXTURESTR2MIXTURETABLE - Convert a mixture string to a detailed mixture table.\n\n  T = MIXTURESTR2MIXTURETABLE(STR, MIXTURESTRUCT)\n\n  Converts a compact mixture string into a detailed table of chemical components\n  and their concentrations. The function parses the string, looks up component\n  definitions in a provided structure, and calculates final concentrations.\n\n  INPUTS:\n    str: (string) A comma-separated string describing the mixture.\n         Each element can be a mixture name (e.g., 'normal_saline') or a\n         mixture name with a multiplier (e.g., '2*picrotoxin').\n\n    mixtureStruct: (struct) A structure where each field is a mixture name\n                   (e.g., 'normal_saline'). The value of each field is a\n                   structure array defining the components of that mixture,\n                   with the following fields:\n      - ontologyName: The ontology identifier for the compound (e.g., 'CHEBI:28997').\n      - name: The common name of the compound (e.g., 'picrotoxin').\n      - value: The base concentration of the compound.\n      - ontologyUnit: The ontology identifier for the unit (e.g., 'OM:MolarVolumeUnit').\n      - unitName: The common name of the unit (e.g., 'Molar').\n\n  OUTPUTS:\n    t: (table) A table listing all components from the resolved mixture string,\n       with columns: \"ontologyName\", \"name\", \"value\" (final calculated\n       concentration), \"ontologyUnit\", and \"unitName\".\n\n  EXAMPLE:\n     str = 'normal_saline,2*picrotoxin';\n     marderFolder = fullfile(fileparts(mfilename('fullpath')));\n     mixtureStruct = jsondecode(fileread(fullfile(marderFolder,\"marder_mixtures.json\")));\n     t = ndi.setup.conv.marder.bath.mixtureStr2mixtureTable(str,mixtureStruct);\n     % t will be a table containing all components of normal_saline and\n     % picrotoxin at twice its base concentration.\n\n  See also: jsondecode, readtable\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/preptemp.m/","title":"ndi.setup.conv.marder.bath.preptemp","text":"<pre><code>  PREPTEMP - Identify temperature parameters from a temperature recording.\n\n  OUT = PREPTEMP(T, D, TEMP_TABLE, [OPTIONS])\n\n  Analyzes a temperature recording to determine if it represents a constant\n  temperature or a temperature change. It matches the observed temperatures\n  to a provided table of command temperatures.\n\n  INPUTS:\n    t: (array) A vector of timestamps for the temperature data.\n    d: (array) A vector of temperature data in degrees Celsius.\n    temp_table: (array) A vector of possible command temperatures.\n    OPTIONS: (Optional) A struct with the following fields:\n      change_threshold: (double) The temperature range threshold to classify\n                        a recording as a 'change'. Default is 3.\n      beginning_time: (double) The duration in seconds at the start of the\n                      record to average for the initial temperature. Default is 2.\n      ending_time: (double) The duration in seconds at the end of the record\n                   to average for the final temperature. Default is 2.\n      filter: (array) A convolution filter to smooth the temperature data.\n              Default is `ones(5,1)/5`.\n      interactive: (logical) If true, prompts the user for input. Default is false.\n\n  OUTPUTS:\n    out: (struct) A structure containing the analysis results, with fields:\n      type: ('constant' or 'change') The classification of the recording.\n      temp: (array) The matching command temperature(s) from temp_table.\n            One value for 'constant', two for 'change' (start and end).\n      raw: (array) The raw (averaged) temperature value(s).\n      range: (double) The observed temperature range in the recording.\n\n  EXAMPLE:\n    t = 0:0.1:10;\n    d = 10 + 15 * (t/10); % Ramp from 10 to 25 degrees\n    temp_table = [10, 15, 20, 25];\n    out = ndi.setup.conv.marder.bath.preptemp(t, d, temp_table);\n    % out.type will be 'change'\n    % out.temp will be [10 25]\n\n  See also: ndi.setup.conv.marder.bath.preptemptable, conv, vlt.data.findclosest\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/preptemptable.m/","title":"ndi.setup.conv.marder.bath.preptemptable","text":"<pre><code>  PREPTEMPTABLE - Create and save a temperature analysis table for an NDI session.\n\n  PREPTEMPTABLE(S)\n\n  Analyzes temperature data for all 'thermometer' probes in an NDI session.\n  For each epoch of each thermometer probe, it reads the temperature time\n  series and uses `ndi.setup.conv.marder.bath.preptemp` to classify the\n  temperature profile as 'constant' or 'change' and identify the command\n  temperatures.\n\n  The results are compiled into a table and saved as 'temptable.mat' in the\n  session directory.\n\n  INPUTS:\n    S: (ndi.session) The NDI session object.\n\n  OUTPUTS:\n    This function does not return any values but writes a 'temptable.mat'\n    file in the session directory. The file contains a single table variable\n    named 'temptable' with the following columns:\n      - probe_id: The ID of the thermometer probe.\n      - epoch_id: The ID of the recording epoch.\n      - type: 'constant' or 'change'.\n      - temp: The identified command temperature(s).\n      - raw: The raw averaged temperature(s).\n\n  EXAMPLE:\n    % Assuming S is a valid NDI session with thermometer probes and data\n    ndi.setup.conv.marder.bath.preptemptable(S);\n    % This will create 'temptable.mat' in the session directory.\n    load(fullfile(S.getpath(), 'temptable.mat'));\n    disp(temptable);\n\n  See also: ndi.setup.conv.marder.bath.preptemp, save, load\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bbath/temptable2stimulusparameters.m/","title":"ndi.setup.conv.marder.bath.temptable2stimulusparameters","text":"<pre><code>  TEMPTABLE2STIMULUSPARAMETERS - Create stimulus parameter documents from a temperature table.\n\n  DOCS = TEMPTABLE2STIMULUSPARAMETERS(S)\n\n  Creates 'stimulus_parameter' NDI documents based on the analysis of\n  temperature data stored in 'temptable.mat'. This function links temperature\n  command values to stimulus epochs.\n\n  The function loads 'temptable.mat', which is generated by\n  `ndi.setup.conv.marder.bath.preptemptable`. For each epoch of each 'stimulator'\n  probe, it finds the corresponding temperature information and creates\n  NDI documents that describe the temperature stimulus parameters\n  (e.g., 'Command temperature constant', 'Command temperature start').\n\n  If an epoch does not have a direct temperature measurement, it uses the\n  measurement from the most recent preceding epoch that did.\n\n  INPUTS:\n    S: (ndi.session) The NDI session object.\n\n  OUTPUTS:\n    docs: (cell array of ndi.document) A cell array of the newly created\n          'stimulus_parameter' documents. Note: These documents are NOT\n          automatically added to the database.\n\n  REQUIRED FILES:\n    - [session_path]/temptable.mat: A MAT-file containing the 'temptable'\n      variable, generated by `ndi.setup.conv.marder.bath.preptemptable`.\n\n  EXAMPLE:\n    % First, generate the temperature table\n    ndi.setup.conv.marder.bath.preptemptable(S);\n    % Then, create the stimulus parameter documents\n    stim_docs = ndi.setup.conv.marder.bath.temptable2stimulusparameters(S);\n    S.database_add(stim_docs); % Add the new documents to the database\n\n  See also: ndi.setup.conv.marder.bath.preptemptable, ndi.document\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abf2probetable.m/","title":"ndi.setup.conv.marder.probeMap.abf2probetable","text":"<pre><code>  ABF2PROBETABLE - Create a probetable from Axon Binary Files (ABF).\n\n  PROBETABLE = ABF2PROBETABLE(S, [OPTIONS])\n\n  Creates a Matlab table object ('probetable') for a Marder Lab NDI session\n  by reading metadata from all Axon Binary Files (*.abf) in the session directory.\n  The function identifies channel information, probe types, and subject\n  associations to create a comprehensive probe table.\n\n  This function assumes that the NDI session `S` has been created and that\n  the session path contains the ABF files. It also relies on 'subject*.txt'\n  files to identify the subjects for the experiment.\n\n  INPUTS:\n    S: An NDI_SESSION object representing the Marder Lab session.\n    OPTIONS: (Optional) A struct with the following fields:\n      forceIgnore2: (logical) If true, forces the function to ignore the\n                    second character in channel names when mapping to probe\n                    information. Default is false.\n      defaultProbeType: (string) The default probe type to use when a\n                        channel cannot be identified. Can be 'n-trode' or\n                        'ppg'. Default is 'n-trode'.\n\n  OUTPUTS:\n    PROBETABLE: A Matlab table with the following columns:\n      - channelName: The name of the channel from the ABF file.\n      - probeName: The standardized name of the probe.\n      - probeRef: The reference number for the probe.\n      - probeType: The type of probe (e.g., 'sharp-Vm', 'n-trode').\n      - subject: The identifier for the subject associated with the probe.\n      - firstAppears: The name of the ABF file where the channel first appears.\n\n  EXAMPLE:\n    % Create a new Marder Lab session\n    ref = 'ML001';\n    dirname = '/path/to/marder/data';\n    S = ndi.setup.lab('marderlab', ref, dirname);\n    % Create the probe table\n    probetable = ndi.setup.conv.marder.probeMap.abf2probetable(S);\n    % Write the table to a file\n    writetable(probetable, [dirname filesep 'probeTable.csv']);\n\n  See also: ndi.setup.lab, ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abfepochprobemap.m/","title":"ndi.setup.conv.marder.probeMap.abfepochprobemap","text":"<pre><code>  ABFEPOCHPROBEMAP - Create epochprobemap files from Axon Binary Files (ABF).\n\n  ABFEPOCHPROBEMAP(S, [OPTIONS])\n\n  Creates '.epochprobemap.txt' files for a Marder Lab NDI session by reading\n  metadata from all Axon Binary Files (*.abf) in the session directory.\n  These map files link recording channels to probe information for each epoch.\n\n  This function assumes that the NDI session `S` has been created and that\n  the session path contains the ABF files. It also relies on 'subject*.txt'\n  files to identify the subjects for the experiment and adds them to the NDI\n  database if they do not already exist.\n\n  INPUTS:\n    S: An NDI_SESSION object representing the Marder Lab session.\n    OPTIONS: (Optional) A struct with the following fields:\n      forceIgnore2: (logical) If true, forces the function to ignore the\n                    second character in channel names when mapping to probe\n                    information, preventing misinterpretation as a second prep.\n                    Default is false.\n\n  OUTPUTS:\n    This function does not return any values but writes a\n    '.epochprobemap.txt' file for each ABF file in the session directory.\n    These files define the relationship between data channels and experimental\n    probes for each recording epoch.\n\n  EXAMPLE:\n    % Create a new Marder Lab session\n    ref = 'ML001';\n    dirname = '/path/to/marder/data';\n    S = ndi.setup.lab('marderlab', ref, dirname);\n    % Create the epochprobemap files\n    ndi.setup.conv.marder.probeMap.abfepochprobemap(S);\n\n  See also: ndi.setup.lab, ndi.epoch.epochprobemap_daqsystem, ndr.format.axon.read_abf_header\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/abfprobetable2probemap.m/","title":"ndi.setup.conv.marder.probeMap.abfprobetable2probemap","text":"<pre><code>  ABFPROBETABLE2PROBEMAP - Create epochprobemap files from a probe table.\n\n    ABFPROBETABLE2PROBEMAP(S, [OPTIONS])\n\n    Creates '.epochprobemap.txt' files for a Marder Lab NDI session. This function\n    reads all Axon Binary Files (*.abf) in the session directory and uses a\n    'probeTable.csv' file to map recording channels to probes and subjects for\n    each epoch.\n\n    This function is essential for linking the raw data channels in ABF files\n    to the higher-level probe and subject information managed by NDI.\n\n  INPUTS:\n    S: (ndi.session or ndi.dataset) An NDI session or dataset object. The function\n       operates on the directory associated with this object.\n    OPTIONS: (Optional) A struct with the following fields:\n      acquisitionDelay: (duration) The minimum time that must have passed since\n                        an ABF file's creation to be processed. Useful for\n                        avoiding incomplete files. Default is `seconds(0)`.\n      overwrite: (logical) If true, existing epochprobemap files will be\n                 overwritten. If false, they will be skipped. Default is `false`.\n\n  OUTPUTS:\n    This function does not return any values but writes a '.epochprobemap.txt'\n    file for each new or specified ABF file in the session directory.\n\n  EXAMPLE:\n    % Assuming S is a valid NDI session object\n    % Create epochprobemap files for all new ABF files\n    ndi.setup.conv.marder.probeMap.abfprobetable2probemap(S);\n\n    % Overwrite all existing epochprobemap files\n    ndi.setup.conv.marder.probeMap.abfprobetable2probemap(S, 'overwrite', true);\n\n  See also: ndi.session, ndi.dataset, ndi.epoch.epochprobemap_daqsystem,\n    ndi.setup.conv.marder.probeMap.channelnametable2probename, ndr.format.axon.read_abf_header\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelname2probename.m/","title":"ndi.setup.conv.marder.probeMap.channelname2probename","text":"<pre><code>  CHANNELNAME2PROBENAME - Convert a Marder Lab channel name to a standardized probe name.\n\n  [PROBENAME, PROBEREF, SUBJECTNAME] = CHANNELNAME2PROBENAME(CHNAME, SUBJECTS, [OPTIONS])\n\n  Converts a raw channel name from a Marder Lab recording (e.g., 'DGN1_A',\n  'lvn', 'lvn2') into a standardized probe name, probe reference number, and\n  associated subject name.\n\n  This function identifies the subject by searching for '1' or '2' in the\n  channel name. If neither is found, it defaults to the first subject.\n\n  INPUTS:\n    chName: (string) The channel name to be converted.\n    subjects: (cell array of strings) A list of subject identifiers.\n    OPTIONS: (Optional) A struct with the following fields:\n      forceIgnore2: (logical) If true, ignores '2' in the channel name\n                    and assigns the channel to the first subject. Default is false.\n\n  OUTPUTS:\n    probename: (string) The standardized probe name (e.g., 'dgn_1', 'lvn_2').\n               If no standard name is found, it returns a MATLAB-validated\n               version of the input channel name.\n    proberef: (double) The reference number for the probe, always 1.\n    subjectname: (string) The identifier of the subject associated with the channel.\n\n  EXAMPLE:\n    subjects = {'crab1', 'crab2'};\n    [p_name, p_ref, s_name] = ndi.setup.conv.marder.probeMap.channelname2probename('dgn2_A', subjects)\n    % p_name = 'dgn_2'\n    % p_ref = 1\n    % s_name = 'crab2'\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelnames2daqsystemstrings.m/","title":"ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings","text":"<pre><code>  CHANNELNAMES2DAQSYSTEMSTRINGS - Convert channel names to NDI DAQ system strings and probe info.\n\n  [NAME, REF, DAQSYSSTR, SUBJECTLIST] = CHANNELNAMES2DAQSYSTEMSTRINGS(CHNAMES, DAQNAME, SUBJECTS, [OPTIONS])\n\n  This function processes a list of Marder Lab channel names, converts them\n  into standardized probe names, and generates corresponding NDI DAQ system\n  strings. It also assigns subject identifiers to each channel.\n\n  A special case is handled for 'PhysiTemp' channels: if a temperature\n  channel is found and there are multiple subjects, it is duplicated and\n  assigned to the second subject as well.\n\n  INPUTS:\n    chNames: (cell array of strings) The list of channel names to process.\n    daqname: (string) The name of the DAQ system (e.g., 'marder_abf').\n    subjects: (cell array of strings) A list of subject identifiers.\n    OPTIONS: (Optional) A struct with the following fields:\n      forceIgnore2: (logical) If true, ignores '2' in channel names,\n                    assigning them to the first subject. Default is false.\n      channelnumbers: (array) An array of channel numbers to be used for\n                      generating DAQ system strings. If empty, it defaults\n                      to 1:numel(chNames).\n\n  OUTPUTS:\n    name: (cell array of strings) The standardized probe names.\n    ref: (array) The reference numbers for each probe (always 1).\n    daqsysstr: (ndi.daq.daqsystemstring array) The generated DAQ system strings.\n    subjectlist: (cell array of strings) The subject identifier for each channel.\n\n  EXAMPLE:\n    chNames = {'dgn1_A', 'lvn2_A', 'PhysiTemp'};\n    daqname = 'marder_abf';\n    subjects = {'crab1', 'crab2'};\n    [n, r, d, s] = ndi.setup.conv.marder.probeMap.channelnames2daqsystemstrings(chNames, daqname, subjects);\n    % This will return probe names, references, DAQ strings, and subjects\n    % for each channel, including a duplicated PhysiTemp for the second crab.\n\n  See also: ndi.setup.conv.marder.probeMap.channelname2probename, ndi.daq.daqsystemstring\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/channelnametable2probename.m/","title":"ndi.setup.conv.marder.probeMap.channelnametable2probename","text":"<pre><code>  CHANNELNAMETABLE2PROBENAME - Retrieve probe information from a probe table using a channel name.\n\n  [PROBENAME, PROBEREF, PROBETYPE, SUBJECTNAME] = CHANNELNAMETABLE2PROBENAME(CHNAME, PROBETABLE)\n\n  Searches a probe table for a given channel name and returns the corresponding\n  probe name, reference, type, and subject name.\n\n  This function is a key component in mapping raw data channels to the\n  structured probe and subject information defined in a 'probeTable.csv' file.\n\n  INPUTS:\n    chName: (string) The channel name to look up in the probe table.\n    probetable: (table) A MATLAB table containing probe information. It must\n                include the columns \"channelName\", \"probeName\", \"probeRef\",\n                \"probeType\", and \"subject\".\n\n  OUTPUTS:\n    probename: (string) The name of the probe.\n    proberef: (double) The reference number of the probe.\n    probetype: (string) The type of the probe (e.g., 'n-trode', 'sharp-Vm').\n    subjectname: (string) The identifier of the subject associated with the probe.\n\n  EXAMPLE:\n    % Assume 'myProbeTable.csv' exists and is loaded into a table called 'pt'\n    pt = readtable('myProbeTable.csv');\n    chName = 'dgn_1';\n    [p_name, p_ref, p_type, s_name] = ndi.setup.conv.marder.probeMap.channelnametable2probename(chName, pt);\n    % This will return the probe details for the 'dgn_1' channel.\n\n  See also: readtable, ndi.setup.conv.marder.probeMap.abf2probetable\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/editProbeTable.m/","title":"ndi.setup.conv.marder.probeMap.editProbeTable","text":"<pre><code>  An interactive probe table editor for probe tables created by abf2probetable.m\n  This script allows users to edit a probe table through a text-based interface.\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/freshen.m/","title":"ndi.setup.conv.marder.probeMap.freshen","text":"<pre><code>  FRESHEN - Updates 'firstAppears' field in an existing probe table\n\n  PROBETABLEEXISTING = FRESHEN(PROBETABLEEXISTING, PROBETABLENEW)\n\n  Given an existing probe table (PROBETABLEEXISTING) and a newly\n  generated one (PROBETABLENEW), this function \"freshens\" the existing\n  table by updating the 'firstAppears' column with the values from\n  the new table.\n\n  The channels in the tables do not need to be in the same order, but\n  the set of channels must be identical.\n\n  This function will raise an error if the channel lists of the two\n  tables are not identical.\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/makeVoltageOffsets.m/","title":"ndi.setup.conv.marder.probeMap.makeVoltageOffsets","text":"<pre><code>  MAKEVOLTAGEOFFSETS - Create NDI documents from a table of voltage offset values.\n\n  DOCLIST = MAKEVOLTAGEOFFSETS(S)\n\n  Reads a comma-separated value file named 'MEoffset.txt' from the NDI session's\n  directory. This file should contain microelectrode voltage offset data. The function\n  then creates 'electrode_offset_voltage' documents in the NDI database for any\n  new offset values.\n\n  The 'MEoffset.txt' file must have the following columns:\n    - \"probeName\": The name of the probe associated with the offset.\n    - \"offsetV\": The voltage offset value.\n    - \"T\": The temperature at which the offset was measured.\n\n  If the file does not exist, the function issues a warning and takes no action.\n\n  INPUTS:\n    S: (ndi.session) The NDI session object.\n\n  OUTPUTS:\n    docList: (cell array of ndi.document) A cell array of any newly created\n             'electrode_offset_voltage' documents. These documents are also\n             added to the session's database.\n\n  EXAMPLE:\n    % Create a 'MEoffset.txt' file in the session directory with the columns:\n    % probeName,offsetV,T\n    % dgn_1,0.005,22.5\n\n    % Assuming S is a valid NDI session object\n    new_docs = ndi.setup.conv.marder.probeMap.makeVoltageOffsets(S);\n\n  See also: readtable, ndi.document\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/marderprobe2uberon.m/","title":"ndi.setup.conv.marder.probeMap.marderprobe2uberon","text":"<pre><code>  MARDERPROBE2UBERON - Add probe location information based on Marder probe data.\n\n  D = MARDERPROBE2UBERON(S)\n\n  Creates 'probe_location' NDI documents by mapping probe names in an NDI\n  session to anatomical locations defined in the UBERON ontology.\n\n  The function retrieves all 'n-trode', 'sharp-Vm', 'sharp-Im', and 'ppg'\n  probes from the session. It then uses a lookup table,\n  'marderprobe2uberontable.txt', to find the corresponding UBERON anatomical\n  term for each probe.\n\n  For each match found, it creates a 'probe_location' document that links\n  the probe's ID to the UBERON identifier.\n\n  INPUTS:\n    S: (ndi.session) The NDI session object.\n\n  OUTPUTS:\n    d: (cell array of ndi.document) A cell array of the newly created\n       'probe_location' documents. Note: These documents are NOT automatically\n       added to the database.\n\n  REQUIRED FILES:\n    - [toolbox_path]/+ndi/+setup/+conv/+marder/+probeMap/marderprobe2uberontable.txt:\n      A tab-delimited file that maps probe names to UBERON anatomical terms.\n      It must contain \"probe\" and \"name\" columns.\n\n  EXAMPLE:\n    % Assuming S is a valid NDI session with defined probes\n    location_docs = ndi.setup.conv.marder.probeMap.marderprobe2uberon(S);\n    S.database_add(location_docs); % Add the new documents to the database\n\n  See also: ndi.database.fun.uberon_ontology_lookup, readtable\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2BprobeMap/smrepochprobemap.m/","title":"ndi.setup.conv.marder.probeMap.smrepochprobemap","text":"<pre><code>  SMREPOCHPROBEMAP - Create epochprobemap files from Spike2 SMR files.\n\n  SMREPOCHPROBEMAP(S, [OPTIONS])\n\n  Creates '.epochprobemap.txt' files for a Marder Lab NDI session by reading\n  metadata from all Spike2 SMR files (*.smr) in the session directory. These\n  map files link recording channels to probe information for each epoch.\n\n  This function assumes that the NDI session `S` has been created and that\n  the session path contains the SMR files. It also relies on 'subject*.txt'\n  files to identify subjects and adds them to the NDI database if they do\n  not already exist.\n\n  INPUTS:\n    S: (ndi.session) An NDI_SESSION object for the Marder Lab session.\n    OPTIONS: (Optional) A struct with the following fields:\n      forceIgnore2: (logical) If true, forces the function to ignore '2'\n                    in channel names when mapping to probe information,\n                    preventing misinterpretation as a second prep.\n                    Default is false.\n\n  OUTPUTS:\n    This function does not return any values but writes a\n    '.epochprobemap.txt' file for each SMR file in the session directory.\n    These files define the relationship between data channels and\n    experimental probes for each recording epoch.\n\n  EXAMPLE:\n    % Create a new Marder Lab session\n    ref = 'ML002';\n    dirname = '/path/to/marder/smr_data';\n    S = ndi.setup.lab('marderlab', ref, dirname);\n    % Create the epochprobemap files from SMR data\n    ndi.setup.conv.marder.probeMap.smrepochprobemap(S);\n\n  See also: ndi.setup.lab, ndi.epoch.epochprobemap_daqsystem, ndr.format.ced.read_SOMSMR_header\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/","title":"CLASS ndi.setup.conv.marder.subject.SubjectInformationCreator","text":"<pre><code>  file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#superclasses","title":"Superclasses","text":"<p>ndi.setup.NDIMaker.SubjectInformationCreator, handle</p>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#properties","title":"Properties","text":"<p>none</p>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#methods","title":"Methods","text":"Method Description SubjectInformationCreator file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m addlistener addlistener  Add listener for event. create Generates subject data from a Marder Lab subject string. delete DELETE   Delete a handle object. eq == (EQ)   Test handle equality. findobj FINDOBJ   Find objects matching specified conditions. findprop findprop   Find property of MATLAB handle object. ge &gt;= (GE)   Greater than or equal relation for handles. gt &gt; (GT)   Greater than relation for handles. isvalid ISVALID   Test handle validity. le &lt;= (LE)   Less than or equal relation for handles. listener listener  Add listener for event without binding the listener to the source object. lt &lt; (LT)   Less than relation for handles. ne ~= (NE)   Not equal relation for handles. notify NOTIFY   Notify listeners of event."},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/SubjectInformationCreator.m/#methods-help","title":"Methods help","text":"<p>SubjectInformationCreator - file: +ndi/+setup/+conv/+marder/+subject/SubjectInformationCreator.m</p> <pre><code>Documentation for ndi.setup.conv.marder.subject.SubjectInformationCreator/SubjectInformationCreator\n       doc ndi.setup.conv.marder.subject.SubjectInformationCreator\n</code></pre> <p>addlistener - addlistener  Add listener for event.</p> <pre><code>el = addlistener(hSource, Eventname, callbackFcn) creates a listener\n    for the event named Eventname.  The source of the event is the handle \n    object hSource.  If hSource is an array of source handles, the listener\n    responds to the named event on any handle in the array.  callbackFcn\n    is a function handle that is invoked when the event is triggered.\n\n    el = addlistener(hSource, PropName, Eventname, Callback) adds a \n    listener for a property event.  Eventname must be one of\n    'PreGet', 'PostGet', 'PreSet', or 'PostSet'. Eventname can be\n    a string scalar or character vector.  PropName must be a single \n    property name specified as string scalar or character vector, or a \n    collection of property names specified as a cell array of character \n    vectors or a string array, or as an array of one or more \n    matlab.metadata.Property objects.  The properties must belong to the \n    class of hSource.  If hSource is scalar, PropName can include dynamic \n    properties.\n\n    For all forms, addlistener returns an event.listener.  To remove a\n    listener, delete the object returned by addlistener.  For example,\n    delete(el) calls the handle class delete method to remove the listener\n    and delete it from the workspace.\n\n    addlistener binds the listener's lifecycle to the object that is the \n    source of the event.  Unless you explicitly delete the listener, it is\n    destroyed only when the source object is destroyed.  To control the\n    lifecycle of the listener independently from the event source object, \n    use listener or the event.listener constructor to create the listener.\n\n    See also listener, event.listener, ndi.setup.conv.marder.subject.subjectinformationcreator, matlab.metadata.Property, events\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/addlistener is inherited from superclass handle\n</code></pre> <p>create - Generates subject data from a Marder Lab subject string.</p> <pre><code>[SUBJECTIDENTIFIER, STRAIN, SPECIES, BIOLOGICALSEX] = CREATE(OBJ, TABLEROW)\n\n    This method processes a single row from a table to generate a unique\n    subject identifier and associated species information. The subject ID is\n    read from the 'subject_id' column of the table row.\n\n    Inputs:\n        obj (ndi.setup.conv.marder.subject.SubjectInformationCreator) - The instance of this creator class.\n        tableRow (table) - A single row from a MATLAB table. It must contain the column 'subject_id'.\n\n    Outputs:\n        subjectIdentifier (char) - The unique local identifier for the subject. Returns NaN on failure.\n        strain (NaN) - Not used for this creator; returns NaN.\n        species (openminds.controlledterms.Species) - The species object. Returns NaN on failure.\n        biologicalSex (NaN) - Not used for this creator; returns NaN.\n\n    See also: ndi.setup.NDIMaker.SubjectInformationCreator\n</code></pre> <p>delete - DELETE   Delete a handle object.</p> <pre><code>DELETE(H) deletes all handle objects in array H. After the delete \n    function call, H is an array of invalid objects.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/ISVALID, CLEAR\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/delete is inherited from superclass handle\n</code></pre> <p>eq - == (EQ)   Test handle equality.</p> <pre><code>Handles are equal if they are handles for the same object.\n\n    H1 == H2 performs element-wise comparisons between handle arrays H1 and\n    H2.  H1 and H2 must be of the same dimensions unless one is a scalar.\n    The result is a logical array of the same dimensions, where each\n    element is an element-wise equality result.\n\n    If one of H1 or H2 is scalar, scalar expansion is performed and the \n    result will match the dimensions of the array that is not scalar.\n\n    TF = EQ(H1, H2) stores the result in a logical array of the same \n    dimensions.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/NE\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/eq is inherited from superclass handle\n</code></pre> <p>findobj - FINDOBJ   Find objects matching specified conditions.</p> <pre><code>The FINDOBJ method of the HANDLE class follows the same syntax as the \n    MATLAB FINDOBJ command, except that the first argument must be an array\n    of handles to objects.\n\n    HM = FINDOBJ(H, &lt;conditions&gt;) searches the handle object array H and \n    returns an array of handle objects matching the specified conditions.\n    Only the public members of the objects of H are considered when \n    evaluating the conditions.\n\n    See also FINDOBJ, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/findobj is inherited from superclass handle\n</code></pre> <p>findprop - findprop   Find property of MATLAB handle object.</p> <pre><code>p = findprop(H,PropName) finds and returns the matlab.metadata.Property \n    object associated with property name PropName of scalar handle object H.\n    PropName can be a string scalar or character vector.  It can be the \n    name of a property defined by the class of H or a dynamic property \n    added to scalar object H.\n\n    If no property named PropName exists for object H, an empty \n    matlab.metadata.Property array is returned.\n\n    See also ndi.setup.conv.marder.subject.subjectinformationcreator, ndi.setup.conv.marder.subject.subjectinformationcreator/findobj, dynamicprops, matlab.metadata.Property\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/findprop is inherited from superclass handle\n</code></pre> <p>ge - &gt;= (GE)   Greater than or equal relation for handles.</p> <pre><code>H1 &gt;= H2 performs element-wise comparisons between handle arrays H1 and\n    H2.  H1 and H2 must be of the same dimensions unless one is a scalar.\n    The result is a logical array of the same dimensions, where each\n    element is an element-wise &gt;= result.\n\n    If one of H1 or H2 is scalar, scalar expansion is performed and the \n    result will match the dimensions of the array that is not scalar.\n\n    TF = GE(H1, H2) stores the result in a logical array of the same \n    dimensions.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/EQ, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/NE\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/ge is inherited from superclass handle\n</code></pre> <p>gt - &gt; (GT)   Greater than relation for handles.</p> <pre><code>H1 &gt; H2 performs element-wise comparisons between handle arrays H1 and \n    H2.  H1 and H2 must be of the same dimensions unless one is a scalar.  \n    The result is a logical array of the same dimensions, where each\n    element is an element-wise &gt; result.\n\n    If one of H1 or H2 is scalar, scalar expansion is performed and the \n    result will match the dimensions of the array that is not scalar.\n\n    TF = GT(H1, H2) stores the result in a logical array of the same \n    dimensions.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/EQ, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/NE\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/gt is inherited from superclass handle\n</code></pre> <p>isvalid - ISVALID   Test handle validity.</p> <pre><code>TF = ISVALID(H) performs an element-wise check for validity on the \n    handle elements of H.  The result is a logical array of the same \n    dimensions as H, where each element is the element-wise validity \n    result.\n\n    A handle is invalid if it has been deleted or if it is an element\n    of a handle array and has not yet been initialized.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/DELETE\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/isvalid is inherited from superclass handle\n</code></pre> <p>le - &lt;= (LE)   Less than or equal relation for handles.</p> <pre><code>Handles are equal if they are handles for the same object.  All \n    comparisons use a number associated with each handle object.  Nothing\n    can be assumed about the result of a handle comparison except that the\n    repeated comparison of two handles in the same MATLAB session will \n    yield the same result.  The order of handle values is purely arbitrary \n    and has no connection to the state of the handle objects being \n    compared.\n\n    H1 &lt;= H2 performs element-wise comparisons between handle arrays H1 and\n    H2.  H1 and H2 must be of the same dimensions unless one is a scalar.\n    The result is a logical array of the same dimensions, where each\n    element is an element-wise &gt;= result.\n\n    If one of H1 or H2 is scalar, scalar expansion is performed and the \n    result will match the dimensions of the array that is not scalar.\n\n    TF = LE(H1, H2) stores the result in a logical array of the same \n    dimensions.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/EQ, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/NE\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/le is inherited from superclass handle\n</code></pre> <p>listener - listener  Add listener for event without binding the listener to the source object.</p> <pre><code>el = listener(hSource, Eventname, callbackFcn) creates a listener\n    for the event named Eventname.  The source of the event is the handle  \n    object hSource.  If hSource is an array of source handles, the listener\n    responds to the named event on any handle in the array.  callbackFcn\n    is a function handle that is invoked when the event is triggered.\n\n    el = listener(hSource, PropName, Eventname, callback) adds a \n    listener for a property event.  Eventname must be one of  \n    'PreGet', 'PostGet', 'PreSet', or 'PostSet'. Eventname can be a \n    string sclar or character vector.  PropName must be either a single \n    property name specified as a string scalar or character vector, or \n    a collection of property names specified as a cell array of character \n    vectors or a string array, or as an array of one ore more \n    matlab.metadata.Property objects. The properties must belong to the \n    class of hSource.  If hSource is scalar, PropName can include dynamic \n    properties.\n\n    For all forms, listener returns an event.listener.  To remove a\n    listener, delete the object returned by listener.  For example,\n    delete(el) calls the handle class delete method to remove the listener\n    and delete it from the workspace.  Calling delete(el) on the listener\n    object deletes the listener, which means the event no longer causes\n    the callback function to execute. \n\n    listener does not bind the listener's lifecycle to the object that is\n    the source of the event.  Destroying the source object does not impact\n    the lifecycle of the listener object.  A listener created with listener\n    must be destroyed independently of the source object.  Calling \n    delete(el) explicitly destroys the listener. Redefining or clearing \n    the variable containing the listener can delete the listener if no \n    other references to it exist.  To tie the lifecycle of the listener to \n    the lifecycle of the source object, use addlistener.\n\n    See also addlistener, event.listener, ndi.setup.conv.marder.subject.subjectinformationcreator, matlab.metadata.Property, events\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/listener is inherited from superclass handle\n</code></pre> <p>lt - &lt; (LT)   Less than relation for handles.</p> <pre><code>H1 &lt; H2 performs element-wise comparisons between handle arrays H1 and\n    H2.  H1 and H2 must be of the same dimensions unless one is a scalar.\n    The result is a logical array of the same dimensions, where each\n    element is an element-wise &lt; result.\n\n    If one of H1 or H2 is scalar, scalar expansion is performed and the \n    result will match the dimensions of the array that is not scalar.\n\n    TF = LT(H1, H2) stores the result in a logical array of the same \n    dimensions.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/EQ, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/NE\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/lt is inherited from superclass handle\n</code></pre> <p>ne - ~= (NE)   Not equal relation for handles.</p> <pre><code>Handles are equal if they are handles for the same object and are \n    unequal otherwise.\n\n    H1 ~= H2 performs element-wise comparisons between handle arrays H1 \n    and H2.  H1 and H2 must be of the same dimensions unless one is a \n    scalar.  The result is a logical array of the same dimensions, where \n    each element is an element-wise equality result.\n\n    If one of H1 or H2 is scalar, scalar expansion is performed and the \n    result will match the dimensions of the array that is not scalar.\n\n    TF = NE(H1, H2) stores the result in a logical array of the same\n    dimensions.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/EQ, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/GT, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LE, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LT\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/ne is inherited from superclass handle\n</code></pre> <p>notify - NOTIFY   Notify listeners of event.</p> <pre><code>NOTIFY(H, eventname) notifies listeners added to the event named \n    eventname for handle object array H that the event is taking place. \n    eventname can be a string scalar or character vector.  \n    H is the array of handles to the event source objects, and 'eventname'\n    must be a character vector.\n\n    NOTIFY(H,eventname,ed) provides a way of encapsulating information \n    about an event which can then be accessed by each registered listener.\n    ed must belong to the EVENT.EVENTDATA class.\n\n    See also NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/ADDLISTENER, NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTINFORMATIONCREATOR/LISTENER, EVENT.EVENTDATA, EVENTS\n\nHelp for ndi.setup.conv.marder.subject.SubjectInformationCreator/notify is inherited from superclass handle\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/makesubjects.m/","title":"ndi.setup.conv.marder.subject.makesubjects","text":"<pre><code>  MAKESUBJECTS - Create subject text files for an NDI session.\n\n  MAKESUBJECTS(S, N)\n\n  Creates 'subjectN.txt' files for a specified number of subjects in the\n  NDI session directory. Each file contains a unique subject identifier based\n  on the session directory name and the subject number.\n\n  These files are used by other setup functions to identify and link data\n  to the correct subjects.\n\n  INPUTS:\n    S: (ndi.session) The NDI session object.\n    N: (integer) The number of subjects to create.\n\n  OUTPUTS:\n    This function does not return any values but writes 'subject1.txt',\n    'subject2.txt', etc., to the session directory.\n\n  EXAMPLE:\n    % Assuming S is a valid NDI session object for a directory named 'my_exp'\n    ndi.setup.conv.marder.subject.makesubjects(S, 2);\n    % This will create 'subject1.txt' with content 'my_exp_01@marderlab.brandeis.edu'\n    % and 'subject2.txt' with content 'my_exp_02@marderlab.brandeis.edu'.\n\n  See also: ndi.setup.conv.marder.probeMap.abf2probetable, ndi.setup.conv.marder.probeMap.abfepochprobemap\n</code></pre>"},{"location":"reference/%2Bndi/%2Bsetup/%2Bconv/%2Bmarder/%2Bsubject/subjectSetup.m/","title":"ndi.setup.conv.marder.subject.subjectSetup","text":"<pre><code>  NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTSETUP - An interactive program to set up subject files for Marder lab conversion.\n\n    NDI.SETUP.CONV.MARDER.SUBJECT.SUBJECTSETUP([DIRECTORY])\n\n    Takes as input a directory (default: the pwd) and builds subjectN.txt files\n    to facilitate Marder lab conversion.\n\n    It asks the user a few questions in a loop.\n\n    First, it tells the user which directory is being worked on and prints the\n    existing contents of subjectN.txt files (for N = 1 .. whatever exists).\n\n    Then, it asks the user if they want to:\n      a) Add a crab\n      b) Add a lobster\n      c) Exit\n\n    If they add a crab or lobster, it asks for the preparation number.\n\n    Then, it creates a text file called subjectM.txt (where M is N+1, or 1 if\n    there are no files) that has the contents\n    'gdy_####@marderlab.brandeis.edu', where #### expresses the preparation\n    number as a 4 digit integer (e.g., 0013). If the subject is a lobster,\n    then it is 'gdy_lobsterNNN@marderlab.brandeis.edu', where NNN is a 3-digit integer.\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/","title":"Tutorial 1 Marder Lab data and NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#11-reading-generic-lab-data-with-ndi","title":"1.1 Reading Generic lab data with NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#about-ndi","title":"About NDI","text":"<p>The Neuroscience Data Interface is a data interface that sits between data and analysis code. NDI presents scientific data so it is in the form of a database that can be accessed through an Application Programming Interface (API) and database queries.</p> <p>See our documentation for:</p> <ol> <li>A short introduction to NDI</li> <li>Key concepts and vocabulary</li> </ol>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#sessions-and-datasets","title":"Sessions and datasets","text":"<p>In NDI, data is organized into sessions and datasets. A dataset is comprised of a set of sessions. </p> <p>To open an existing session, one simply uses:</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-111","title":"Code block 1.1.1:","text":"<pre><code>S = ndi.session.dir(path/to/your/session);\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#listing-subjects-in-a-session","title":"Listing subjects in a session","text":"<p>We have a handy helper function to list all of the subjects in a session in a table, along with some information about the global treatments of those subjects:</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-112","title":"Code block 1.1.2:","text":"<pre><code>sT = ndi.fun.docTable.subject(S)\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#seeing-probes-and-elements","title":"Seeing probes and elements","text":"<p>Probes are anything that measures or stimulates a subject, and a session typically has many probe instances. To see the probes for your experiment, you can use</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-113","title":"Code block 1.1.3:","text":"<pre><code>p = S.getprobes()\n</code></pre> <p>Elements are related to probes but they can also contain derived data. All probes are elements, some elements are probes. We can look at all the elements in our session like this:</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-114","title":"Code block 1.1.4:","text":"<pre><code>e = S.elements()\n</code></pre> <p>You can examine the elements, which will be in a cell array, as follows:</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-115","title":"Code block 1.1.5","text":"<pre><code>for i=1:numel(e)\n    e{i} % display the element's information\nend\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#listing-the-epochs-of-elements-or-probes","title":"Listing the epochs of elements or probes","text":"<p>We can get the data for a probe or an element using the epochtable function.</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-116","title":"Code block 1.1.6","text":"<pre><code>elementNumber = 10; % choose an element\net = e{elementNumber}.epochtable;\n\nfor i=1:numel(et),\n    et(i) % display the epoch table entry\nend\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#reading-timeseries-data-from-an-element-during-an-epoch","title":"Reading timeseries data from an element during an epoch","text":"<p>We can read the timeseries data from an element a few different ways. We can ask for the data in the local time coordinates of the data acquisition device very easily:</p>"},{"location":"tutorials/MarderLabDataAndNDI/1_ReadingGenericDataWithNDI/#code-block-117","title":"Code block 1.1.7","text":"<pre><code>epochNumber = 1;\n[d,t] = e{elementNumber}.readtimeseries(epochNumber,-inf,inf); % read all times available\nfigure;\nplot(t,d);\nxlabel('Time(s)');\nylabel('Signal');\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/","title":"Tutorial 1 Marder Lab data and NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/#12-updating-the-software","title":"1.2 Updating the software","text":""},{"location":"tutorials/MarderLabDataAndNDI/2_UpdatingTheSoftware/#updating-the-software","title":"Updating the software","text":"<p>Updating the software is a little tricky at the moment.</p> <ul> <li>Update DID-matlab:</li> <li>On the Matlab command line, navigate to your <code>USERPATH/tools/DID-matlab</code> directory. Make sure you are inside the directory.</li> <li>Run <code>!git pull</code></li> <li>Update NDI-matlab:</li> <li>On the Matlab command line, navigate to your <code>USERPATH/tools/NDI-matlab</code> directory. Make sure you are inside the directory.</li> <li>Run <code>!git pull</code></li> <li>Update vhlab-toolbox-matlab:</li> <li>On the Matlab command line, navigate to your <code>USERPATH/tools/NDI-matlab</code> directory. Make sure you are inside the directory.</li> <li>Run <code>!git pull</code></li> <li>Update NDIcalc-marder-matlab:</li> <li>On the Matlab command line, navigate to your <code>USERPATH/tools/NDIcalc-marder-matlab</code> directory. Make sure you are inside the directory.</li> <li>Run <code>!git pull</code> </li> </ul>"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/","title":"Tutorial 1 Marder Lab data and NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#13-how-we-have-been-organizing-things","title":"1.3 How we have been organizing things","text":""},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#where-are-the-sessions","title":"Where are the sessions?","text":"<p>For the time being, we have been storing the PPG sessions in zipped folders on a shared Google Drive.</p> <p>Soon (overdue) this can all be in the cloud so it will get much easier.</p>"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#opening-a-session","title":"Opening a session","text":"<p>Let's use 994_13 as an example. Find the 994_13.zip file on the shared drive, download it, and put it on your disk where you'd like.</p>"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#code-block-131","title":"Code block 1.3.1:","text":"<pre><code>myDataPath = '/Users/vanhoosr/data/grace';\nmySessionPath = fullfile(myDataPath,'994_13');\nS = ndi.session.dir(mySessionPath);\n</code></pre> <p>Now you can list the subjects and look at the probes and epochs as in the generic tutorial.</p>"},{"location":"tutorials/MarderLabDataAndNDI/3_HowThingsAreOrganized/#importing-new-data-into-a-session","title":"Importing new data into a session","text":"<p>The NDI team has been doing this for the moment. We will document this so we can hand it off.</p>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/","title":"Tutorial 1 Marder Lab data and NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#14-plotting-heart-beats-and-spectrograms-for-ppg-data","title":"1.4 Plotting Heart Beats and Spectrograms for PPG data","text":""},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#141-open-an-example-session","title":"1.4.1 Open an example session","text":"<p>Let's open an example session. Let's use our 994_13 example from before.</p>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-141","title":"Code block 1.4.1:","text":"<pre><code>myDataPath = '/Users/vanhoosr/data/grace';\nmySessionPath = fullfile(myDataPath,'994_13');\nS = ndi.session.dir(mySessionPath);\n</code></pre> <p>Now let's list all of the subjects</p>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-142","title":"Code block 1.4.2:","text":"<pre><code>sT = ndi.fun.docTable.subject(S)\n</code></pre> <p>For me, this returns:</p>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-143-output-only-dont-type-in","title":"Code block 1.4.3 (output only, don't type in)","text":"<pre><code>sT = \n\n  4x2 table\n\n          SubjectDocumentIdentifier                SubjectLocalIdentifier       \n    _____________________________________    ___________________________________\n\n    {'412693a357d10010_c0c02febe68548fc'}    {'gdy_0013@marderlab.brandeis.edu'}\n    {'412693a357d10565_c0d01f184e858a0a'}    {'gdy_0014@marderlab.brandeis.edu'}\n    {'412693a357d10ace_c0cfda142fb3d8ae'}    {'gdy_0015@marderlab.brandeis.edu'}\n    {'412693a357d10f57_40b3eae7d7d2dc09'}    {'gdy_0016@marderlab.brandeis.edu'}\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#142-plot-a-summary-of-a-whole-ppg-session","title":"1.4.2 Plot a summary of a whole PPG session","text":"<p>We can plot a summary of the whole session with the following code:</p>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-144","title":"Code block 1.4.4:","text":"<pre><code>mlt.plot.HeartBeatsFromDocs(S)\nmlt.plot.SpectrogramsFromDocs(S)\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#143-get-the-heart-beat-data-for-a-subject-and-sensor-location","title":"1.4.3 Get the heart beat data for a subject and sensor location","text":"<p>Use the <code>mlt.doc.*</code> functions. You can see the documentation for the heart beat fields by typing <code>help mlt.beats.beatdocs2struct</code>.</p>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-145","title":"Code block 1.4.5","text":"<pre><code>[heartBeatDocs,HeartBeatData] = mlt.doc.getHeartBeats(S,'gdy_0013@marderlab.brandeis.edu','heart');\n\nHeartBeatData{1}, % display the first structure\n\nfigure;\nplot([HeartBeatData{1}.onset],[HeartBeatData{1}.instant_freq],'k-');\nxlabel('Time (UTC)');\nylabel('Instantaneous frequency')\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#144-get-the-spectrogram-data-for-a-subject-and-sensor-location","title":"1.4.4 Get the spectrogram data for a subject and sensor location","text":""},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#code-block-145_1","title":"Code block 1.4.5","text":"<pre><code>[SpectrogramDocs,SpectrogramData] = mlt.doc.getSpectograms(S,'gdy_0013@marderlab.brandeis.edu','heart');\n\nSpectrogramData{1}, % display the first structure\nmlt.plot.Spectrogram(SpectrogramData{1}.spec,SpectrogramData{1}.f,SpectrogramData{1}.ts);\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#145-get-the-heart-and-spectrogram-data-all-together","title":"1.4.5 Get the heart and spectrogram data all together!","text":"<pre><code>mySubjectData = mlt.doc.getHeartBeatAndSpectrogram(S,'gdy_0013@marderlab.brandeis.edu','heart');\nmlt.plot.Traces(S,mySubjectData,1)\n</code></pre>"},{"location":"tutorials/MarderLabDataAndNDI/4_HowToPlotHeartBeatsAndSpectrograms/#146-notes","title":"1.4.6 Notes:","text":"<p>The functions that read from local files where we initially stored the heart beat and spectrogram information are not recommended anymore. We will eventually remove them. These were quick and dirty treatments to get started looking at the data:</p> <ul> <li><code>mlt.plot.HeartBeatsFromFiles</code> - Not recommended</li> <li><code>mlt.plot.SpectrogramsFromFiles</code> - Not recommended</li> <li><code>SpectrogramsBeatsOverlayFromFiles</code> - Not recommended</li> </ul>"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/","title":"Tutorial 1 Marder Lab data and NDI","text":""},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#15-importing-data-from-a-session","title":"1.5 Importing data from a session","text":""},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-1-files","title":"Step 1: Files","text":"<p>Make sure you have your files.</p> <p>The files should be a set of Axon Instruments ABF files (<code>EXP_0000.abf</code>, <code>EXP_0001.abf</code>, etc). EXP is usually a string like <code>972_120</code>; the first number (<code>972</code>) is the lab notebook number and the second number is the page number where the experiment is written (<code>120</code>).</p> <p>Your directory might look like this:</p> <p></p>"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-2-subjects","title":"Step 2: Subjects","text":"<p>One needs to make subject files. Some of Grace\u2019s recordings have two subjects. One makes a subject file simply by creating a text file called <code>subject1.txt</code> and <code>subject2.txt</code> etc. The text file has a single name. We\u2019ve been naming Grace\u2019s crabs as <code>gdy007@marderlab.brandeis.edu</code>, etc.</p>"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-3-bath-table","title":"Step 3: Bath Table","text":"<p>The Marder lab experiments often involve manipulations of the drugs in the bath. Further, the drugs provided to different tissues can vary; the experimenters can make vaseline wells and restrict the perfusion of certain drugs to specific tissues.</p> <p>The bath table is a comma separated file: </p> <p>The mixture strings indicate which mixture(s) in <code>USERPATH/tools/NDIc-marder-matlab/+ndi/+setup/+conv/+marder/+bath/marder_mixtures.json</code> and applies them to targets <code>USERPATH/tools/NDIc-marder-matlab/+ndi/+setup/+conv/+marder/+bath/marder_bathtargets.json</code></p>"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-5-initial-build-of-ndisession-object","title":"Step 5: Initial build of ndi.session object","text":"<p>Run the initial setup that uses the files and the text files to build an ndi.session object:</p> <p><code>S = ndi.setup.conv.marder.presetup(pwd,2)</code></p>"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-6-probe-table","title":"Step 6: Probe table","text":"<p>Update the probe table (<code>probeTable.csv</code>, a text file). For Grace\u2019s project the probeName values should be <code>ppg_heart</code> or <code>ppg_pylorus</code>, as appropriate, the <code>probeType</code> is <code>ppg</code>, and the reference set to be 1 for the first crab, 2 for the second crab, etc. The table for one experiment looks like: </p>"},{"location":"tutorials/MarderLabDataAndNDI/5_ImportingNewData/#step-7-do-the-final-post-setup","title":"Step 7: Do the final post-setup","text":"<p>Run the command <code>ndi.setup.conv.marder.postsetup(S)</code></p>"}]}